#define IKFAST_NAMESPACE ik_katana5d_trans
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2014-10-08 15:52:02.140958
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16;
x0=IKcos(j[0]);
x1=IKsin(j[1]);
x2=IKcos(j[1]);
x3=IKsin(j[2]);
x4=IKcos(j[2]);
x5=IKsin(j[3]);
x6=IKsin(j[0]);
x7=IKcos(j[3]);
x8=((0.139)*x0);
x9=((0.273)*x0);
x10=((0.273)*x6);
x11=((0.139)*x6);
x12=((0.19)*x1);
x13=(x2*x3);
x14=(x1*x3);
x15=(x1*x4);
x16=(x2*x4);
eetrans[0]=(((x0*x12))+((x5*(((((-1.0)*x16*x9))+((x14*x9))))))+((x13*x8))+((x7*((((x13*x9))+((x15*x9))))))+((x15*x8)));
IkReal x17=((1.0)*x10);
IkReal x18=((1.0)*x11);
eetrans[1]=((((-1.0)*x12*x6))+((x5*(((((-1.0)*x14*x17))+((x10*x16))))))+(((-1.0)*x13*x18))+(((-1.0)*x15*x18))+((x7*(((((-1.0)*x13*x17))+(((-1.0)*x15*x17)))))));
eetrans[2]=((0.2015)+((x7*(((((-0.273)*x14))+(((0.273)*x16))))))+(((-0.139)*x14))+((x5*(((((0.273)*x15))+(((0.273)*x13))))))+(((0.19)*x2))+(((0.139)*x16)));
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {3, 4}; return freeparams; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x33000003; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j4,cj4,sj4,htj4,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1;  _ij3[0] = -1; _ij3[1] = -1; _nj3 = 0;  _ij4[0] = -1; _ij4[1] = -1; _nj4 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j3=pfree[0]; cj3=cos(pfree[0]); sj3=sin(pfree[0]);
j4=pfree[1]; cj4=cos(pfree[1]); sj4=sin(pfree[1]);
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_px=px;
new_py=((-1.0)*py);
new_pz=((0.2015)+(((-1.0)*pz)));
px = new_px; py = new_py; pz = new_pz;
pp=((px*px)+(py*py)+(pz*pz));
{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
j2eval[0]=((IKabs(sj3))+(((9.63948332369385)*(IKabs(((0.05282)+(((0.10374)*cj3))))))));
j2eval[1]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[2];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((IKabs(sj3))+(((9.63948332369385)*(IKabs(((0.05282)+(((0.10374)*cj3))))))));
j2eval[1]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
CheckValue<IkReal> x19=IKPowWithIntegerCheck(pz,-1);
if(!x19.valid){
continue;
}
cj1array[0]=((2.63157894736842)*(x19.value)*(((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))))));
if( cj1array[0] >= -1-IKFAST_SINCOS_THRESH && cj1array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j1valid[0] = j1valid[1] = true;
    j1array[0] = IKacos(cj1array[0]);
    sj1array[0] = IKsin(j1array[0]);
    cj1array[1] = cj1array[0];
    j1array[1] = -j1array[0];
    sj1array[1] = -sj1array[0];
}
else if( isnan(cj1array[0]) )
{
    // probably any value will work
    j1valid[0] = true;
    cj1array[0] = 1; sj1array[0] = 0; j1array[0] = 0;
}
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x20=((273000.0)*pz);
IkReal x21=((139000.0)*pz);
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=((IKabs(((26410.0)+((sj1*sj3*x20))+((cj1*x21))+(((51870.0)*cj3))+((cj1*cj3*x20)))))+(IKabs(((((-1.0)*cj3*sj1*x20))+((cj1*sj3*x20))+(((51870.0)*sj3))+(((-1.0)*sj1*x21))))));
j2eval[2]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x22=pz*pz;
IkReal x23=(pz*sj1);
IkReal x24=((13650000.0)*x22);
j2eval[0]=((1.23659314306796)+cj3);
j2eval[1]=IKsign(((1783150.0)+(((1441986.0)*cj3))));
j2eval[2]=((IKabs(((-903152.5)+(((-5187000.0)*sj3*x23))+(((-2301280.8)*cj3))+(((6950000.0)*x22))+((cj3*x24))+(((-1035953.1)*(cj3*cj3))))))+(IKabs(((((-1773817.5)*sj3))+(((5187000.0)*cj3*x23))+((sj3*x24))+(((-1035953.1)*cj3*sj3))+(((2641000.0)*x23))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[1];
px=0;
py=0;
pp=pz*pz;
j2eval[0]=((((-1.23659314306796)*cj1))+(((-1.0)*cj1*cj3)));
if( IKabs(j2eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x25=((273000.0)*pz);
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=((IKabs(((26410.0)+((sj3*x25))+(((51870.0)*cj3)))))+(IKabs(((((51870.0)*sj3))+(((-139000.0)*pz))+(((-1.0)*cj3*x25))))));
j2eval[2]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x26=pz*pz;
IkReal x27=cj3*cj3;
IkReal x28=(cj3*x26);
j2eval[0]=((3.46268674455821)+(((26.6463004583164)*x26))+(((-3.97184425371572)*x27))+(((52.3341009001465)*x28))+(((-1.0)*cj3)));
j2eval[1]=((IKabs(((-501790.0)+(((-5187000.0)*pz*sj3))+(((-985530.0)*cj3)))))+(IKabs(((((68345323.7410072)*(pz*pz*pz)))+(((-985530.0)*sj3))+(((-1305942.44604317)*pz))))));
j2eval[2]=IKsign(((1234525.0)+(((18658273.381295)*x28))+(((-1416051.0)*x27))+(((-356522.287769784)*cj3))+(((9500000.0)*x26))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x29=pz*pz;
CheckValue<IkReal> x30=IKPowWithIntegerCheck(IKsign(((1234525.0)+(((-1416051.0)*(cj3*cj3)))+(((-356522.287769784)*cj3))+(((18658273.381295)*cj3*x29))+(((9500000.0)*x29)))),-1);
if(!x30.valid){
continue;
}
CheckValue<IkReal> x31 = IKatan2WithCheck(IkReal(((((68345323.7410072)*(pz*pz*pz)))+(((-985530.0)*sj3))+(((-1305942.44604317)*pz)))),((-501790.0)+(((-5187000.0)*pz*sj3))+(((-985530.0)*cj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x31.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x30.value)))+(x31.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x32=IKcos(j2);
IkReal x33=IKsin(j2);
IkReal x34=((0.273)*cj3);
IkReal x35=(sj3*x33);
evalcond[0]=((-0.19)+(((-1.0)*x32*x34))+(((-0.273)*x35))+(((-0.139)*x32)));
evalcond[1]=((0.0722)+(((1.36690647482014)*x32*(pz*pz)))+(((0.10374)*x35))+(((-0.0261188489208633)*x32)));
evalcond[2]=((((0.139)*x33))+(((-0.273)*sj3*x32))+(((-1.0)*pz))+((x33*x34)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x36=((273000.0)*pz);
CheckValue<IkReal> x37=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x37.valid){
continue;
}
CheckValue<IkReal> x38 = IKatan2WithCheck(IkReal(((((51870.0)*sj3))+(((-139000.0)*pz))+(((-1.0)*cj3*x36)))),((26410.0)+(((51870.0)*cj3))+((sj3*x36))),IKFAST_ATAN2_MAGTHRESH);
if(!x38.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x37.value)))+(x38.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x39=IKcos(j2);
IkReal x40=IKsin(j2);
IkReal x41=((0.273)*cj3);
IkReal x42=(sj3*x40);
evalcond[0]=((-0.19)+(((-1.0)*x39*x41))+(((-0.139)*x39))+(((-0.273)*x42)));
evalcond[1]=((0.0722)+(((1.36690647482014)*x39*(pz*pz)))+(((0.10374)*x42))+(((-0.0261188489208633)*x39)));
evalcond[2]=((((0.139)*x40))+((x40*x41))+(((-0.273)*sj3*x39))+(((-1.0)*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x43=((273000.0)*pz);
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=((IKabs((((cj3*x43))+(((51870.0)*sj3))+(((139000.0)*pz)))))+(IKabs(((26410.0)+(((51870.0)*cj3))+(((-1.0)*sj3*x43))))));
j2eval[2]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[3];
px=0;
py=0;
pp=pz*pz;
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x44=pz*pz;
IkReal x45=cj3*cj3;
IkReal x46=(cj3*x44);
j2eval[0]=((-3.46268674455821)+cj3+(((-26.6463004583164)*x44))+(((-52.3341009001465)*x46))+(((3.97184425371572)*x45)));
j2eval[1]=((IKabs(((((68345323.7410072)*(pz*pz*pz)))+(((985530.0)*sj3))+(((-1305942.44604317)*pz)))))+(IKabs(((501790.0)+(((-5187000.0)*pz*sj3))+(((985530.0)*cj3))))));
j2eval[2]=IKsign(((-1234525.0)+(((356522.287769784)*cj3))+(((1416051.0)*x45))+(((-9500000.0)*x44))+(((-18658273.381295)*x46))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j0, j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x47=pz*pz;
CheckValue<IkReal> x48 = IKatan2WithCheck(IkReal(((((68345323.7410072)*(pz*pz*pz)))+(((985530.0)*sj3))+(((-1305942.44604317)*pz)))),((501790.0)+(((-5187000.0)*pz*sj3))+(((985530.0)*cj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x48.valid){
continue;
}
CheckValue<IkReal> x49=IKPowWithIntegerCheck(IKsign(((-1234525.0)+(((356522.287769784)*cj3))+(((1416051.0)*(cj3*cj3)))+(((-9500000.0)*x47))+(((-18658273.381295)*cj3*x47)))),-1);
if(!x49.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x48.value)+(((1.5707963267949)*(x49.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x50=IKcos(j2);
IkReal x51=IKsin(j2);
IkReal x52=((0.273)*cj3);
IkReal x53=(sj3*x51);
evalcond[0]=((-0.19)+(((-0.139)*x50))+(((-0.273)*x53))+(((-1.0)*x50*x52)));
evalcond[1]=((((0.139)*x51))+pz+((x51*x52))+(((-0.273)*sj3*x50)));
evalcond[2]=((0.0722)+(((1.36690647482014)*x50*(pz*pz)))+(((0.10374)*x53))+(((-0.0261188489208633)*x50)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x54=((273000.0)*pz);
CheckValue<IkReal> x55 = IKatan2WithCheck(IkReal(((((51870.0)*sj3))+(((139000.0)*pz))+((cj3*x54)))),((26410.0)+(((51870.0)*cj3))+(((-1.0)*sj3*x54))),IKFAST_ATAN2_MAGTHRESH);
if(!x55.valid){
continue;
}
CheckValue<IkReal> x56=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x56.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x55.value)+(((1.5707963267949)*(x56.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x57=IKcos(j2);
IkReal x58=IKsin(j2);
IkReal x59=((0.273)*cj3);
IkReal x60=(sj3*x58);
evalcond[0]=((-0.19)+(((-0.139)*x57))+(((-0.273)*x60))+(((-1.0)*x57*x59)));
evalcond[1]=(((x58*x59))+(((0.139)*x58))+pz+(((-0.273)*sj3*x57)));
evalcond[2]=((0.0722)+(((1.36690647482014)*x57*(pz*pz)))+(((-0.0261188489208633)*x57))+(((0.10374)*x60)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x61=cj1*cj1;
IkReal x62=(cj1*cj3);
IkReal x63=(cj1*sj3);
IkReal x64=(pz*sj1);
IkReal x65=(pz*x61);
CheckValue<IkReal> x66=IKPowWithIntegerCheck(((((-75.894)*x62))+(((-93.85)*cj1))),-1);
if(!x66.valid){
continue;
}
CheckValue<IkReal> x67=IKPowWithIntegerCheck(((((9385.0)*cj1))+(((7589.4)*x62))),-1);
if(!x67.valid){
continue;
}
if( IKabs(((x66.value)*(((((273.0)*sj3*x65))+(((-139.0)*cj1*x64))+(((51.87)*x63))+(((-273.0)*x62*x64)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x67.value)*(((((-27300.0)*cj3*x65))+(((-5187.0)*x62))+(((-27300.0)*x63*x64))+(((-13900.0)*x65))+(((-2641.0)*cj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x66.value)*(((((273.0)*sj3*x65))+(((-139.0)*cj1*x64))+(((51.87)*x63))+(((-273.0)*x62*x64))))))+IKsqr(((x67.value)*(((((-27300.0)*cj3*x65))+(((-5187.0)*x62))+(((-27300.0)*x63*x64))+(((-13900.0)*x65))+(((-2641.0)*cj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j2array[0]=IKatan2(((x66.value)*(((((273.0)*sj3*x65))+(((-139.0)*cj1*x64))+(((51.87)*x63))+(((-273.0)*x62*x64))))), ((x67.value)*(((((-27300.0)*cj3*x65))+(((-5187.0)*x62))+(((-27300.0)*x63*x64))+(((-13900.0)*x65))+(((-2641.0)*cj1))))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x68=IKsin(j2);
IkReal x69=IKcos(j2);
IkReal x70=(sj1*sj3);
IkReal x71=((1.0)*pz);
IkReal x72=(cj3*x69);
IkReal x73=((0.273)*x68);
IkReal x74=((0.139)*x68);
IkReal x75=((0.139)*x69);
IkReal x76=((0.273)*sj3*x69);
evalcond[0]=((((-1.0)*x76))+(((-1.0)*sj1*x71))+x74+((cj3*x73)));
evalcond[1]=((-0.19)+(((-0.273)*x72))+(((-1.0)*x75))+(((-1.0)*sj3*x73))+(((-1.0)*cj1*x71)));
evalcond[2]=((0.12995)+(((0.10374)*sj3*x68))+(((0.10374)*x72))+(((0.075894)*cj3))+(((0.05282)*x69))+(((-1.0)*pz*x71)));
evalcond[3]=((((0.19)*sj1))+((cj1*cj3*x73))+(((0.273)*sj1*x72))+((sj1*x75))+((x70*x73))+((cj1*x74))+(((-1.0)*cj1*x76)));
evalcond[4]=((((-0.273)*cj1*x72))+(((-0.273)*x69*x70))+(((-1.0)*x71))+(((-0.19)*cj1))+((cj3*sj1*x73))+((sj1*x74))+(((-1.0)*cj1*sj3*x73))+(((-1.0)*cj1*x75)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x77=pz*pz;
IkReal x78=(pz*sj1);
IkReal x79=((13650000.0)*x77);
CheckValue<IkReal> x80 = IKatan2WithCheck(IkReal(((((-1773817.5)*sj3))+(((-1035953.1)*cj3*sj3))+((sj3*x79))+(((5187000.0)*cj3*x78))+(((2641000.0)*x78)))),((-903152.5)+(((-5187000.0)*sj3*x78))+(((-2301280.8)*cj3))+(((6950000.0)*x77))+((cj3*x79))+(((-1035953.1)*(cj3*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x80.valid){
continue;
}
CheckValue<IkReal> x81=IKPowWithIntegerCheck(IKsign(((1783150.0)+(((1441986.0)*cj3)))),-1);
if(!x81.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x80.value)+(((1.5707963267949)*(x81.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x82=IKsin(j2);
IkReal x83=IKcos(j2);
IkReal x84=(sj1*sj3);
IkReal x85=((1.0)*pz);
IkReal x86=(cj3*x83);
IkReal x87=((0.273)*x82);
IkReal x88=((0.139)*x82);
IkReal x89=((0.139)*x83);
IkReal x90=((0.273)*sj3*x83);
evalcond[0]=((((-1.0)*sj1*x85))+((cj3*x87))+x88+(((-1.0)*x90)));
evalcond[1]=((-0.19)+(((-0.273)*x86))+(((-1.0)*sj3*x87))+(((-1.0)*cj1*x85))+(((-1.0)*x89)));
evalcond[2]=((0.12995)+(((0.10374)*x86))+(((0.10374)*sj3*x82))+(((0.075894)*cj3))+(((0.05282)*x83))+(((-1.0)*pz*x85)));
evalcond[3]=(((x84*x87))+(((0.19)*sj1))+((sj1*x89))+(((0.273)*sj1*x86))+(((-1.0)*cj1*x90))+((cj1*x88))+((cj1*cj3*x87)));
evalcond[4]=(((cj3*sj1*x87))+(((-0.273)*x83*x84))+(((-0.19)*cj1))+((sj1*x88))+(((-1.0)*cj1*x89))+(((-1.0)*x85))+(((-0.273)*cj1*x86))+(((-1.0)*cj1*sj3*x87)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x91=((273000.0)*pz);
IkReal x92=((139000.0)*pz);
CheckValue<IkReal> x93 = IKatan2WithCheck(IkReal(((((-1.0)*sj1*x92))+(((51870.0)*sj3))+(((-1.0)*cj3*sj1*x91))+((cj1*sj3*x91)))),((26410.0)+(((51870.0)*cj3))+((sj1*sj3*x91))+((cj1*x92))+((cj1*cj3*x91))),IKFAST_ATAN2_MAGTHRESH);
if(!x93.valid){
continue;
}
CheckValue<IkReal> x94=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x94.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x93.value)+(((1.5707963267949)*(x94.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x95=IKsin(j2);
IkReal x96=IKcos(j2);
IkReal x97=(sj1*sj3);
IkReal x98=((1.0)*pz);
IkReal x99=(cj3*x96);
IkReal x100=((0.273)*x95);
IkReal x101=((0.139)*x95);
IkReal x102=((0.139)*x96);
IkReal x103=((0.273)*sj3*x96);
evalcond[0]=((((-1.0)*sj1*x98))+((cj3*x100))+(((-1.0)*x103))+x101);
evalcond[1]=((-0.19)+(((-1.0)*sj3*x100))+(((-0.273)*x99))+(((-1.0)*x102))+(((-1.0)*cj1*x98)));
evalcond[2]=((0.12995)+(((-1.0)*pz*x98))+(((0.10374)*x99))+(((0.10374)*sj3*x95))+(((0.075894)*cj3))+(((0.05282)*x96)));
evalcond[3]=(((sj1*x102))+((x100*x97))+(((-1.0)*cj1*x103))+((cj1*x101))+((cj1*cj3*x100))+(((0.19)*sj1))+(((0.273)*sj1*x99)));
evalcond[4]=((((-0.273)*cj1*x99))+((sj1*x101))+(((-1.0)*cj1*x102))+(((-0.273)*x96*x97))+(((-0.19)*cj1))+((cj3*sj1*x100))+(((-1.0)*x98))+(((-1.0)*cj1*sj3*x100)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x104=((0.05282)+(((0.10374)*cj3)));
CheckValue<IkReal> x107 = IKatan2WithCheck(IkReal(x104),((0.10374)*sj3),IKFAST_ATAN2_MAGTHRESH);
if(!x107.valid){
continue;
}
IkReal x105=((1.0)*(x107.value));
if((((x104*x104)+(((0.0107619876)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x108=IKPowWithIntegerCheck(IKabs(IKsqrt(((x104*x104)+(((0.0107619876)*(sj3*sj3)))))),-1);
if(!x108.valid){
continue;
}
if( (((x108.value)*(((0.12995)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))))))) < -1-IKFAST_SINCOS_THRESH || (((x108.value)*(((0.12995)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x106=IKasin(((x108.value)*(((0.12995)+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))))));
j2array[0]=((((-1.0)*x105))+(((-1.0)*x106)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x105))+x106);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x109=((0.273)*sj2);
IkReal x110=((0.273)*cj2);
j1eval[0]=pz;
j1eval[1]=((IKabs((((cj3*x109))+(((0.139)*sj2))+(((-1.0)*sj3*x110)))))+(IKabs(((-0.19)+(((-1.0)*sj3*x109))+(((-1.0)*cj3*x110))+(((-0.139)*cj2))))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
IkReal x111=((1.96402877697842)*pz);
j1eval[0]=((((1.36690647482014)*pz))+((cj2*pz))+((cj2*cj3*x111))+((sj2*sj3*x111)));
j1eval[1]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x112=((0.075894)*cj3);
IkReal x113=((0.273)*cj3);
IkReal x114=(sj2*sj3);
evalcond[0]=IKabs(pz);
evalcond[1]=((0.12995)+(((0.10374)*x114))+x112+(((0.05282)*cj2))+(((0.10374)*cj2*cj3)));
evalcond[2]=((-0.19)+(((-0.273)*x114))+(((-1.0)*cj2*x113))+(((-0.139)*cj2)));
evalcond[3]=(((sj2*x113))+(((0.139)*sj2))+(((-0.273)*cj2*sj3)));
evalcond[4]=((0.05775)+x112);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x115=((0.273)*sj3);
j1eval[0]=((IKabs(((((-1.0)*cj2*x115))+(((-0.0687338129496403)*sj2)))))+(IKabs(((-0.19)+(((0.0687338129496403)*cj2))+(((-1.0)*sj2*x115))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x116=((0.273)*sj3);
j1eval[0]=((IKabs(((((-1.0)*cj2*x116))+(((-0.0687338129496403)*sj2)))))+(IKabs(((0.19)+(((-0.0687338129496403)*cj2))+((sj2*x116))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x117=((0.273)*sj3);
CheckValue<IkReal> x119 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*x117))+(((-0.0687338129496403)*sj2)))),((0.19)+(((-0.0687338129496403)*cj2))+((sj2*x117))),IKFAST_ATAN2_MAGTHRESH);
if(!x119.valid){
continue;
}
IkReal x118=x119.value;
j1array[0]=((-1.0)*x118);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x118)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x120=IKcos(j1);
IkReal x121=IKsin(j1);
IkReal x122=((0.273)*sj3);
evalcond[0]=((((0.0687338129496403)*cj2*x120))+(((-1.0)*cj2*x121*x122))+(((-0.0687338129496403)*sj2*x121))+(((-0.19)*x120))+(((-1.0)*sj2*x120*x122)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x123=((0.273)*sj3);
CheckValue<IkReal> x125 = IKatan2WithCheck(IkReal(((-0.19)+(((-1.0)*sj2*x123))+(((0.0687338129496403)*cj2)))),((((-1.0)*cj2*x123))+(((-0.0687338129496403)*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x125.valid){
continue;
}
IkReal x124=x125.value;
j1array[0]=((-1.0)*x124);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x124)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x126=IKsin(j1);
IkReal x127=IKcos(j1);
IkReal x128=((0.273)*sj3);
evalcond[0]=(((sj2*x126*x128))+(((-0.0687338129496403)*sj2*x127))+(((-0.0687338129496403)*cj2*x126))+(((-1.0)*cj2*x127*x128))+(((0.19)*x126)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x129=pz*pz;
IkReal x130=(cj3*sj2);
IkReal x131=(cj2*cj3);
IkReal x132=((5.187)*pz);
IkReal x133=(cj2*sj3);
IkReal x134=((13.65)*x129);
CheckValue<IkReal> x135=IKPowWithIntegerCheck(((((2.641)*cj2*pz))+((x131*x132))+((sj2*sj3*x132))+(((3.61)*pz))),-1);
if(!x135.valid){
continue;
}
CheckValue<IkReal> x136=IKPowWithIntegerCheck(pz,-1);
if(!x136.valid){
continue;
}
if( IKabs(((x135.value)*(((((-1.3157508)*x130))+(((-1.0)*x133*x134))+((x130*x134))+(((-0.4013625)*sj2))+(((-1.0359531)*cj3*x130))+(((0.7882875)*x133))+(((1.0359531)*sj3*x131))+(((6.95)*sj2*x129)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0526315789473684)*(x136.value)*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*x129)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x135.value)*(((((-1.3157508)*x130))+(((-1.0)*x133*x134))+((x130*x134))+(((-0.4013625)*sj2))+(((-1.0359531)*cj3*x130))+(((0.7882875)*x133))+(((1.0359531)*sj3*x131))+(((6.95)*sj2*x129))))))+IKsqr(((0.0526315789473684)*(x136.value)*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*x129))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x135.value)*(((((-1.3157508)*x130))+(((-1.0)*x133*x134))+((x130*x134))+(((-0.4013625)*sj2))+(((-1.0359531)*cj3*x130))+(((0.7882875)*x133))+(((1.0359531)*sj3*x131))+(((6.95)*sj2*x129))))), ((0.0526315789473684)*(x136.value)*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*x129))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x137=IKcos(j1);
IkReal x138=IKsin(j1);
IkReal x139=((0.273)*sj2);
IkReal x140=((1.0)*pz);
IkReal x141=((0.273)*cj3);
IkReal x142=((0.273)*cj2);
IkReal x143=((0.139)*cj2);
IkReal x144=((0.139)*sj2);
IkReal x145=(sj2*x138);
IkReal x146=(cj3*x137);
IkReal x147=(cj2*x138);
IkReal x148=(sj3*x137);
evalcond[0]=((0.05775)+(((-1.0)*pz*x140))+(((0.075894)*cj3))+(((-0.38)*pz*x137)));
evalcond[1]=((((-1.0)*x138*x140))+((cj3*x139))+x144+(((-1.0)*sj3*x142)));
evalcond[2]=((-0.19)+(((-1.0)*x143))+(((-1.0)*x137*x140))+(((-1.0)*sj3*x139))+(((-1.0)*cj2*x141)));
evalcond[3]=((((-1.0)*x142*x148))+((x137*x144))+((sj3*x138*x139))+((x138*x143))+((x141*x147))+(((0.19)*x138))+((x139*x146)));
evalcond[4]=((((-1.0)*x140))+(((-1.0)*x137*x143))+((x138*x144))+(((-1.0)*x139*x148))+(((-1.0)*sj3*x138*x142))+(((-0.19)*x137))+(((-1.0)*cj2*x137*x141))+((cj3*x138*x139)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x150=IKPowWithIntegerCheck(pz,-1);
if(!x150.valid){
continue;
}
IkReal x149=x150.value;
CheckValue<IkReal> x151=IKPowWithIntegerCheck(x149,-2);
if(!x151.valid){
continue;
}
if( IKabs((x149*(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0526315789473684)*x149*(((2.8875)+(((-50.0)*(x151.value)))+(((3.7947)*cj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x149*(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3))))))+IKsqr(((0.0526315789473684)*x149*(((2.8875)+(((-50.0)*(x151.value)))+(((3.7947)*cj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x149*(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3))))), ((0.0526315789473684)*x149*(((2.8875)+(((-50.0)*(x151.value)))+(((3.7947)*cj3))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x152=IKcos(j1);
IkReal x153=IKsin(j1);
IkReal x154=((0.273)*sj2);
IkReal x155=((1.0)*pz);
IkReal x156=((0.273)*cj3);
IkReal x157=((0.273)*cj2);
IkReal x158=((0.139)*cj2);
IkReal x159=((0.139)*sj2);
IkReal x160=(sj2*x153);
IkReal x161=(cj3*x152);
IkReal x162=(cj2*x153);
IkReal x163=(sj3*x152);
evalcond[0]=((0.05775)+(((-1.0)*pz*x155))+(((-0.38)*pz*x152))+(((0.075894)*cj3)));
evalcond[1]=((((-1.0)*x153*x155))+((cj3*x154))+x159+(((-1.0)*sj3*x157)));
evalcond[2]=((-0.19)+(((-1.0)*x158))+(((-1.0)*x152*x155))+(((-1.0)*cj2*x156))+(((-1.0)*sj3*x154)));
evalcond[3]=(((x153*x158))+(((-1.0)*x157*x163))+((x152*x159))+((sj3*x153*x154))+((x156*x162))+((x154*x161))+(((0.19)*x153)));
evalcond[4]=(((x153*x159))+(((-1.0)*x154*x163))+(((-1.0)*x155))+(((-0.19)*x152))+(((-1.0)*sj3*x153*x157))+((cj3*x153*x154))+(((-1.0)*x152*x158))+(((-1.0)*cj2*x152*x156)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x164=((0.273)*sj2);
IkReal x165=((0.273)*cj2);
CheckValue<IkReal> x166 = IKatan2WithCheck(IkReal(((((0.139)*sj2))+((cj3*x164))+(((-1.0)*sj3*x165)))),((-0.19)+(((-1.0)*cj3*x165))+(((-1.0)*sj3*x164))+(((-0.139)*cj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x166.valid){
continue;
}
CheckValue<IkReal> x167=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x167.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x166.value)+(((1.5707963267949)*(x167.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x168=IKcos(j1);
IkReal x169=IKsin(j1);
IkReal x170=((0.273)*sj2);
IkReal x171=((1.0)*pz);
IkReal x172=((0.273)*cj3);
IkReal x173=((0.273)*cj2);
IkReal x174=((0.139)*cj2);
IkReal x175=((0.139)*sj2);
IkReal x176=(sj2*x169);
IkReal x177=(cj3*x168);
IkReal x178=(cj2*x169);
IkReal x179=(sj3*x168);
evalcond[0]=((0.05775)+(((-0.38)*pz*x168))+(((-1.0)*pz*x171))+(((0.075894)*cj3)));
evalcond[1]=(((cj3*x170))+x175+(((-1.0)*x169*x171))+(((-1.0)*sj3*x173)));
evalcond[2]=((-0.19)+(((-1.0)*x174))+(((-1.0)*cj2*x172))+(((-1.0)*x168*x171))+(((-1.0)*sj3*x170)));
evalcond[3]=((((0.19)*x169))+((x168*x175))+((x169*x174))+((x172*x178))+((x170*x177))+((sj3*x169*x170))+(((-1.0)*x173*x179)));
evalcond[4]=((((-1.0)*x171))+(((-1.0)*sj3*x169*x173))+((x169*x175))+(((-0.19)*x168))+(((-1.0)*cj2*x168*x172))+(((-1.0)*x170*x179))+((cj3*x169*x170))+(((-1.0)*x168*x174)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1, j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x180=((0.05282)+(((0.10374)*cj3)));
CheckValue<IkReal> x183 = IKatan2WithCheck(IkReal(x180),((0.10374)*sj3),IKFAST_ATAN2_MAGTHRESH);
if(!x183.valid){
continue;
}
IkReal x181=((1.0)*(x183.value));
if((((((0.0107619876)*(sj3*sj3)))+(x180*x180))) < -0.00001)
continue;
CheckValue<IkReal> x184=IKPowWithIntegerCheck(IKabs(IKsqrt(((((0.0107619876)*(sj3*sj3)))+(x180*x180)))),-1);
if(!x184.valid){
continue;
}
if( (((x184.value)*(((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x184.value)*(((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x182=IKasin(((x184.value)*(((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x181))+(((-1.0)*x182)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+(((-1.0)*x181))+x182);
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j0eval[1];
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x185=sj2*sj2;
IkReal x186=cj2*cj2;
IkReal x187=sj3*sj3;
IkReal x188=cj3*cj3;
IkReal x189=((3.92805755395683)*cj3);
IkReal x190=(sj2*sj3);
IkReal x191=(cj2*cj3);
IkReal x192=((3.85740903679934)*x186);
IkReal x193=((3.85740903679934)*x185);
j1eval[0]=((IKabs(((-0.19)+(((-0.273)*x191))+(((-0.273)*x190))+(((-0.139)*cj2)))))+(IKabs(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3))))));
j1eval[1]=((1.86843331090523)+(((2.73381294964029)*cj2))+((x186*x189))+((x187*x193))+((x187*x192))+(((5.36928730396977)*x190))+(((5.36928730396977)*x191))+((x188*x193))+((x188*x192))+((x185*x189))+x185+x186);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
evalcond[2]=((0.12995)+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.05282)*cj2))+(((0.10374)*cj2*cj3))+(((0.10374)*sj2*sj3)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
px=0;
py=0;
pp=pz*pz;
IkReal x194=((0.273)*sj2);
IkReal x195=((0.273)*cj2);
j1eval[0]=pz;
j1eval[1]=((IKabs(((-0.19)+(((-1.0)*sj3*x194))+(((-1.0)*cj3*x195))+(((-0.139)*cj2)))))+(IKabs(((((0.139)*sj2))+((cj3*x194))+(((-1.0)*sj3*x195))))));
j1eval[2]=IKsign(pz);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=pz*pz;
j1eval[0]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
px=0;
py=0;
pp=pz*pz;
IkReal x196=((1.96402877697842)*pz);
j1eval[0]=((((1.36690647482014)*pz))+((sj2*sj3*x196))+((cj2*cj3*x196))+((cj2*pz)));
j1eval[1]=pz;
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x197=((0.273)*sj2);
IkReal x198=((0.273)*cj2);
evalcond[0]=IKabs(pz);
evalcond[1]=((-0.19)+(((-1.0)*sj3*x197))+(((-1.0)*cj3*x198))+(((-0.139)*cj2)));
evalcond[2]=((((0.139)*sj2))+((cj3*x197))+(((-1.0)*sj3*x198)));
evalcond[3]=((0.05775)+(((0.075894)*cj3)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x199=((0.273)*sj3);
j1eval[0]=((IKabs(((((-0.0687338129496403)*sj2))+(((-1.0)*cj2*x199)))))+(IKabs(((-0.19)+(((0.0687338129496403)*cj2))+(((-1.0)*sj2*x199))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
{
IkReal j1eval[1];
px=0;
py=0;
pp=0;
pz=0;
IkReal x200=((0.273)*sj3);
j1eval[0]=((IKabs(((0.19)+(((-0.0687338129496403)*cj2))+((sj2*x200)))))+(IKabs(((((-1.0)*cj2*x200))+(((-0.0687338129496403)*sj2))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j0, j1]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x201=((0.273)*sj3);
CheckValue<IkReal> x203 = IKatan2WithCheck(IkReal(((((-1.0)*cj2*x201))+(((-0.0687338129496403)*sj2)))),((0.19)+(((-0.0687338129496403)*cj2))+((sj2*x201))),IKFAST_ATAN2_MAGTHRESH);
if(!x203.valid){
continue;
}
IkReal x202=x203.value;
j1array[0]=((-1.0)*x202);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x202)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x204=IKcos(j1);
IkReal x205=IKsin(j1);
IkReal x206=((0.273)*sj3);
evalcond[0]=((((0.0687338129496403)*cj2*x204))+(((-0.0687338129496403)*sj2*x205))+(((-1.0)*sj2*x204*x206))+(((-1.0)*cj2*x205*x206))+(((-0.19)*x204)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x207=((0.273)*sj3);
CheckValue<IkReal> x209 = IKatan2WithCheck(IkReal(((-0.19)+(((0.0687338129496403)*cj2))+(((-1.0)*sj2*x207)))),((((-1.0)*cj2*x207))+(((-0.0687338129496403)*sj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x209.valid){
continue;
}
IkReal x208=x209.value;
j1array[0]=((-1.0)*x208);
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x208)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[1];
IkReal x210=IKsin(j1);
IkReal x211=IKcos(j1);
IkReal x212=((0.273)*sj3);
evalcond[0]=((((-0.0687338129496403)*cj2*x210))+(((-1.0)*cj2*x211*x212))+((sj2*x210*x212))+(((-0.0687338129496403)*sj2*x211))+(((0.19)*x210)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x213=pz*pz;
IkReal x214=(cj3*sj2);
IkReal x215=(cj2*cj3);
IkReal x216=((5.187)*pz);
IkReal x217=(cj2*sj3);
IkReal x218=((13.65)*x213);
CheckValue<IkReal> x219=IKPowWithIntegerCheck(((((2.641)*cj2*pz))+((sj2*sj3*x216))+((x215*x216))+(((3.61)*pz))),-1);
if(!x219.valid){
continue;
}
CheckValue<IkReal> x220=IKPowWithIntegerCheck(pz,-1);
if(!x220.valid){
continue;
}
if( IKabs(((x219.value)*(((((0.7882875)*x217))+((x214*x218))+(((6.95)*sj2*x213))+(((1.0359531)*sj3*x215))+(((-1.3157508)*x214))+(((-1.0)*x217*x218))+(((-1.0359531)*cj3*x214))+(((-0.4013625)*sj2)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0526315789473684)*(x220.value)*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*x213)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x219.value)*(((((0.7882875)*x217))+((x214*x218))+(((6.95)*sj2*x213))+(((1.0359531)*sj3*x215))+(((-1.3157508)*x214))+(((-1.0)*x217*x218))+(((-1.0359531)*cj3*x214))+(((-0.4013625)*sj2))))))+IKsqr(((0.0526315789473684)*(x220.value)*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*x213))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2(((x219.value)*(((((0.7882875)*x217))+((x214*x218))+(((6.95)*sj2*x213))+(((1.0359531)*sj3*x215))+(((-1.3157508)*x214))+(((-1.0)*x217*x218))+(((-1.0359531)*cj3*x214))+(((-0.4013625)*sj2))))), ((0.0526315789473684)*(x220.value)*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*x213))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x221=IKcos(j1);
IkReal x222=IKsin(j1);
IkReal x223=((0.273)*sj2);
IkReal x224=((1.0)*pz);
IkReal x225=((0.273)*cj3);
IkReal x226=((0.273)*cj2);
IkReal x227=((0.139)*cj2);
IkReal x228=((0.139)*sj2);
IkReal x229=(sj2*x222);
IkReal x230=(cj3*x221);
IkReal x231=(cj2*x222);
IkReal x232=(sj3*x221);
evalcond[0]=((0.05775)+(((-1.0)*pz*x224))+(((0.075894)*cj3))+(((-0.38)*pz*x221)));
evalcond[1]=(((cj3*x223))+(((-1.0)*x222*x224))+x228+(((-1.0)*sj3*x226)));
evalcond[2]=((-0.19)+(((-1.0)*sj3*x223))+(((-1.0)*cj2*x225))+(((-1.0)*x221*x224))+(((-1.0)*x227)));
evalcond[3]=(((x222*x227))+((sj3*x222*x223))+(((0.19)*x222))+((x225*x231))+(((-1.0)*x226*x232))+((x221*x228))+((x223*x230)));
evalcond[4]=(((cj3*x222*x223))+(((-0.19)*x221))+(((-1.0)*cj2*x221*x225))+((x222*x228))+(((-1.0)*sj3*x222*x226))+(((-1.0)*x223*x232))+(((-1.0)*x221*x227))+(((-1.0)*x224)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
CheckValue<IkReal> x234=IKPowWithIntegerCheck(pz,-1);
if(!x234.valid){
continue;
}
IkReal x233=x234.value;
CheckValue<IkReal> x235=IKPowWithIntegerCheck(x233,-2);
if(!x235.valid){
continue;
}
if( IKabs((x233*(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.0526315789473684)*x233*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*(x235.value))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x233*(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3))))))+IKsqr(((0.0526315789473684)*x233*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*(x235.value)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j1array[0]=IKatan2((x233*(((((0.139)*sj2))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3))))), ((0.0526315789473684)*x233*(((2.8875)+(((3.7947)*cj3))+(((-50.0)*(x235.value)))))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x236=IKcos(j1);
IkReal x237=IKsin(j1);
IkReal x238=((0.273)*sj2);
IkReal x239=((1.0)*pz);
IkReal x240=((0.273)*cj3);
IkReal x241=((0.273)*cj2);
IkReal x242=((0.139)*cj2);
IkReal x243=((0.139)*sj2);
IkReal x244=(sj2*x237);
IkReal x245=(cj3*x236);
IkReal x246=(cj2*x237);
IkReal x247=(sj3*x236);
evalcond[0]=((0.05775)+(((-1.0)*pz*x239))+(((0.075894)*cj3))+(((-0.38)*pz*x236)));
evalcond[1]=(((cj3*x238))+(((-1.0)*sj3*x241))+x243+(((-1.0)*x237*x239)));
evalcond[2]=((-0.19)+(((-1.0)*cj2*x240))+(((-1.0)*x236*x239))+(((-1.0)*x242))+(((-1.0)*sj3*x238)));
evalcond[3]=(((x240*x246))+((sj3*x237*x238))+((x237*x242))+((x238*x245))+(((0.19)*x237))+((x236*x243))+(((-1.0)*x241*x247)));
evalcond[4]=(((cj3*x237*x238))+(((-1.0)*cj2*x236*x240))+((x237*x243))+(((-1.0)*x236*x242))+(((-1.0)*x239))+(((-1.0)*x238*x247))+(((-1.0)*sj3*x237*x241))+(((-0.19)*x236)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x248=((0.273)*sj2);
IkReal x249=((0.273)*cj2);
CheckValue<IkReal> x250 = IKatan2WithCheck(IkReal(((((-1.0)*sj3*x249))+(((0.139)*sj2))+((cj3*x248)))),((-0.19)+(((-1.0)*sj3*x248))+(((-1.0)*cj3*x249))+(((-0.139)*cj2))),IKFAST_ATAN2_MAGTHRESH);
if(!x250.valid){
continue;
}
CheckValue<IkReal> x251=IKPowWithIntegerCheck(IKsign(pz),-1);
if(!x251.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x250.value)+(((1.5707963267949)*(x251.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x252=IKcos(j1);
IkReal x253=IKsin(j1);
IkReal x254=((0.273)*sj2);
IkReal x255=((1.0)*pz);
IkReal x256=((0.273)*cj3);
IkReal x257=((0.273)*cj2);
IkReal x258=((0.139)*cj2);
IkReal x259=((0.139)*sj2);
IkReal x260=(sj2*x253);
IkReal x261=(cj3*x252);
IkReal x262=(cj2*x253);
IkReal x263=(sj3*x252);
evalcond[0]=((0.05775)+(((-1.0)*pz*x255))+(((0.075894)*cj3))+(((-0.38)*pz*x252)));
evalcond[1]=(((cj3*x254))+x259+(((-1.0)*sj3*x257))+(((-1.0)*x253*x255)));
evalcond[2]=((-0.19)+(((-1.0)*x252*x255))+(((-1.0)*sj3*x254))+(((-1.0)*cj2*x256))+(((-1.0)*x258)));
evalcond[3]=((((0.19)*x253))+((sj3*x253*x254))+((x254*x261))+((x253*x258))+((x256*x262))+((x252*x259))+(((-1.0)*x257*x263)));
evalcond[4]=((((-1.0)*x252*x258))+(((-0.19)*x252))+((cj3*x253*x254))+((x253*x259))+(((-1.0)*cj2*x252*x256))+(((-1.0)*sj3*x253*x257))+(((-1.0)*x254*x263))+(((-1.0)*x255)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0, j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x264=((0.273)*cj3);
IkReal x265=((0.273)*sj3);
IkReal x266=((((0.139)*sj2))+((sj2*x264))+(((-1.0)*cj2*x265)));
IkReal x267=((-0.19)+(((-1.0)*sj2*x265))+(((-1.0)*cj2*x264))+(((-0.139)*cj2)));
CheckValue<IkReal> x270 = IKatan2WithCheck(IkReal(x267),x266,IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
IkReal x268=((1.0)*(x270.value));
if((((x266*x266)+(x267*x267))) < -0.00001)
continue;
CheckValue<IkReal> x271=IKPowWithIntegerCheck(IKabs(IKsqrt(((x266*x266)+(x267*x267)))),-1);
if(!x271.valid){
continue;
}
if( ((pz*(x271.value))) < -1-IKFAST_SINCOS_THRESH || ((pz*(x271.value))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x269=IKasin((pz*(x271.value)));
j1array[0]=(x269+(((-1.0)*x268)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x269))+(((-1.0)*x268)));
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j0eval[3];
IkReal x272=((139.0)*sj2);
IkReal x273=((1000.0)*pz*sj1);
IkReal x274=((273.0)*cj2*sj3);
IkReal x275=((273.0)*cj3*sj2);
IkReal x276=(((cj1*(px*px)))+((cj1*(py*py))));
j0eval[0]=x276;
j0eval[1]=((IKabs((((py*x272))+((py*x275))+(((-1.0)*py*x273))+(((-1.0)*py*x274)))))+(IKabs((((px*x272))+((px*x275))+(((-1.0)*px*x273))+(((-1.0)*px*x274))))));
j0eval[2]=IKsign(x276);
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x277=(cj2*py);
IkReal x278=((273.0)*px);
IkReal x279=(sj2*sj3);
IkReal x280=((1000.0)*cj1*pz);
IkReal x281=(((sj1*(py*py)))+((sj1*(px*px))));
j0eval[0]=x281;
j0eval[1]=IKsign(x281);
j0eval[2]=((IKabs(((((139.0)*cj2*px))+(((190.0)*px))+((cj2*cj3*x278))+((x278*x279))+((px*x280)))))+(IKabs(((((190.0)*py))+(((139.0)*x277))+(((273.0)*py*x279))+(((273.0)*cj3*x277))+((py*x280))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
IkReal x282=px*px;
IkReal x283=py*py;
IkReal x284=pz*pz;
IkReal x285=((37947.0)*cj3);
IkReal x286=((500000.0)*px);
IkReal x287=((500000.0)*py);
IkReal x288=(sj1*x282);
IkReal x289=(sj1*x283);
IkReal x290=((190000.0)*cj1*pz);
j0eval[0]=(x289+x288);
j0eval[1]=IKsign(((((19.0)*x288))+(((19.0)*x289))));
j0eval[2]=((IKabs((((x284*x286))+(((-1.0)*px*x285))+((px*x290))+(((-28875.0)*px))+((x283*x286))+((x286*(px*px))))))+(IKabs((((x284*x287))+((x287*(py*py)))+((py*x290))+(((-1.0)*py*x285))+(((-28875.0)*py))+((x282*x287))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[8];
bool bgotonextstatement = true;
do
{
IkReal x291=((0.075894)*cj3);
IkReal x292=(cj2*cj3);
IkReal x293=(sj2*sj3);
IkReal x294=((1.0)*(px*px));
IkReal x295=((1.0)*(py*py));
IkReal x296=((1.0)*(pz*pz));
IkReal x297=(x294+x295+x296);
IkReal x298=((-0.19)+(((-1.0)*pz))+(((-0.273)*x292))+(((-0.273)*x293))+(((-0.139)*cj2)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=((0.12995)+(((0.10374)*x292))+(((0.10374)*x293))+(((-1.0)*x297))+x291+(((0.05282)*cj2)));
evalcond[2]=x298;
evalcond[3]=((0.05775)+(((-0.38)*pz))+(((-1.0)*x297))+x291);
evalcond[4]=x298;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x299=(px*sj2);
IkReal x300=((273.0)*cj3);
IkReal x301=(py*sj2);
IkReal x302=((273.0)*cj2*sj3);
IkReal x303=((px*px)+(py*py));
j0eval[0]=x303;
j0eval[1]=IKsign(x303);
j0eval[2]=((IKabs(((((-1.0)*px*x302))+((x299*x300))+(((139.0)*x299)))))+(IKabs(((((139.0)*x301))+(((-1.0)*py*x302))+((x300*x301))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x304=x266;
evalcond[0]=((px*px)+(py*py));
evalcond[1]=0;
evalcond[2]=x304;
evalcond[3]=x304;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x305=x266;
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
evalcond[2]=x305;
evalcond[3]=x305;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=0;
sj3=0;
cj3=1.0;
j2=0;
sj2=0;
cj2=1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x307 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);
if(!x307.valid){
continue;
}
IkReal x306=x307.value;
j0array[0]=((-1.0)*x306);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x306)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j2, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=0;
sj3=0;
cj3=1.0;
j2=3.14159265358979;
sj2=0;
cj2=-1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x309 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);
if(!x309.valid){
continue;
}
IkReal x308=x309.value;
j0array[0]=((-1.0)*x308);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x308)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=0;
sj2=0;
cj2=1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x311 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);
if(!x311.valid){
continue;
}
IkReal x310=x311.value;
j0array[0]=((-1.0)*x310);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x310)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j2, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=1.0;
j1=0;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=3.14159265358979;
sj2=0;
cj2=-1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x313 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);
if(!x313.valid){
continue;
}
IkReal x312=x313.value;
j0array[0]=((-1.0)*x312);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x312)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*py*(IKsin(j0))))+(((-1.0)*px*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x314=(px*sj2);
IkReal x315=((0.273)*cj3);
IkReal x316=(py*sj2);
IkReal x317=((0.273)*cj2*sj3);
CheckValue<IkReal> x318 = IKatan2WithCheck(IkReal(((((0.139)*x316))+((x315*x316))+(((-1.0)*py*x317)))),((((0.139)*x314))+((x314*x315))+(((-1.0)*px*x317))),IKFAST_ATAN2_MAGTHRESH);
if(!x318.valid){
continue;
}
CheckValue<IkReal> x319=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x319.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x318.value)+(((1.5707963267949)*(x319.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x320=IKcos(j0);
IkReal x321=IKsin(j0);
IkReal x322=((1.0)*px);
evalcond[0]=((((-1.0)*x321*x322))+((py*x320)));
evalcond[1]=((((-1.0)*py*x321))+(((0.139)*sj2))+(((-1.0)*x320*x322))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x323=((0.075894)*cj3);
IkReal x324=((0.139)*cj2);
IkReal x325=(cj2*cj3);
IkReal x326=(sj2*sj3);
IkReal x327=((0.273)*x325);
IkReal x328=((0.273)*x326);
IkReal x329=(x324+x327+x328);
IkReal x330=((((1.0)*(px*px)))+(((1.0)*(py*py)))+(((1.0)*(pz*pz))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=((0.12995)+x323+(((0.10374)*x325))+(((0.10374)*x326))+(((-1.0)*x330))+(((0.05282)*cj2)));
evalcond[2]=((-0.19)+(((-1.0)*x329))+pz);
evalcond[3]=((0.05775)+(((0.38)*pz))+x323+(((-1.0)*x330)));
evalcond[4]=((0.19)+x329+(((-1.0)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x331=(px*sj2);
IkReal x332=((273.0)*cj3);
IkReal x333=(py*sj2);
IkReal x334=((273.0)*cj2*sj3);
IkReal x335=((((-1.0)*(px*px)))+(((-1.0)*(py*py))));
j0eval[0]=x335;
j0eval[1]=IKsign(x335);
j0eval[2]=((IKabs(((((139.0)*x331))+(((-1.0)*px*x334))+((x331*x332)))))+(IKabs(((((139.0)*x333))+((x332*x333))+(((-1.0)*py*x334))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x336=((0.273)*cj2*sj3);
IkReal x337=((((0.139)*sj2))+(((0.273)*cj3*sj2)));
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
evalcond[2]=(x337+(((-1.0)*x336)));
evalcond[3]=(x336+(((-1.0)*x337)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=0;
sj3=0;
cj3=1.0;
j2=0;
sj2=0;
cj2=1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x339 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);
if(!x339.valid){
continue;
}
IkReal x338=x339.value;
j0array[0]=((-1.0)*x338);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x338)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*px*(IKsin(j0))))+((py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j2, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j3), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=0;
sj3=0;
cj3=1.0;
j2=3.14159265358979;
sj2=0;
cj2=-1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x341 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);
if(!x341.valid){
continue;
}
IkReal x340=x341.value;
j0array[0]=((-1.0)*x340);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x340)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*px*(IKsin(j0))))+((py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j2), 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=0;
sj2=0;
cj2=1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
IkReal x342=x343.value;
j0array[0]=((-1.0)*x342);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x342)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*px*(IKsin(j0))))+((py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j3, 6.28318530717959)))))+(IKabs(((-3.14159265358979)+(IKfmod(j2, 6.28318530717959))))));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[1];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j3=3.14159265358979;
sj3=0;
cj3=-1.0;
j2=3.14159265358979;
sj2=0;
cj2=-1.0;
j0eval[0]=((IKabs(px))+(IKabs(py)));
if( IKabs(j0eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x345 = IKatan2WithCheck(IkReal(px),py,IKFAST_ATAN2_MAGTHRESH);
if(!x345.valid){
continue;
}
IkReal x344=x345.value;
j0array[0]=((-1.0)*x344);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x344)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*px*(IKsin(j0))))+((py*(IKcos(j0)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x346=(px*sj2);
IkReal x347=((0.273)*cj3);
IkReal x348=(py*sj2);
IkReal x349=((0.273)*cj2*sj3);
CheckValue<IkReal> x350=IKPowWithIntegerCheck(IKsign(((((-1.0)*(px*px)))+(((-1.0)*(py*py))))),-1);
if(!x350.valid){
continue;
}
CheckValue<IkReal> x351 = IKatan2WithCheck(IkReal((((x347*x348))+(((0.139)*x348))+(((-1.0)*py*x349)))),((((-1.0)*px*x349))+((x346*x347))+(((0.139)*x346))),IKFAST_ATAN2_MAGTHRESH);
if(!x351.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x350.value)))+(x351.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[2];
IkReal x352=IKsin(j0);
IkReal x353=IKcos(j0);
evalcond[0]=(((py*x353))+(((-1.0)*px*x352)));
evalcond[1]=(((px*x353))+(((0.139)*sj2))+((py*x352))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x354=((((0.139)*sj2))+(((-1.0)*pz))+(((0.273)*cj3*sj2))+(((-0.273)*cj2*sj3)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.05282)*cj2))+(((0.10374)*cj2*cj3))+(((-1.0)*(py*py)))+(((0.10374)*sj2*sj3)));
evalcond[2]=x354;
evalcond[3]=x354;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x355=(cj2*py);
IkReal x356=((273.0)*cj3);
IkReal x357=(cj2*px);
IkReal x358=((273.0)*sj2*sj3);
IkReal x359=((((-1.0)*(px*px)))+(((-1.0)*(py*py))));
j0eval[0]=x359;
j0eval[1]=IKsign(x359);
j0eval[2]=((IKabs(((((-139.0)*x355))+(((-190.0)*py))+(((-1.0)*py*x358))+(((-1.0)*x355*x356)))))+(IKabs(((((-139.0)*x357))+(((-190.0)*px))+(((-1.0)*px*x358))+(((-1.0)*x356*x357))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x360=py*py;
IkReal x361=px*px;
IkReal x362=pz*pz;
IkReal x363=((500000.0)*px);
IkReal x364=((500000.0)*py);
IkReal x365=((37947.0)*cj3);
j0eval[0]=((((-1.0)*x360))+(((-1.0)*x361)));
j0eval[1]=IKsign(((((-19.0)*x360))+(((-19.0)*x361))));
j0eval[2]=((IKabs(((((-1.0)*x362*x363))+(((-1.0)*x360*x363))+(((28875.0)*px))+((px*x365))+(((-1.0)*x363*(px*px))))))+(IKabs(((((-1.0)*x362*x364))+(((-1.0)*x361*x364))+(((28875.0)*py))+((py*x365))+(((-1.0)*x364*(py*py)))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x366=((0.139)*cj2);
IkReal x367=((0.273)*cj2*cj3);
IkReal x368=((0.273)*sj2*sj3);
IkReal x369=(x368+x366+x367);
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
evalcond[2]=((-0.19)+(((-1.0)*x369)));
evalcond[3]=((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))));
evalcond[4]=((0.19)+x369);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x370=pz*pz;
IkReal x371=py*py;
IkReal x372=px*px;
IkReal x373=((50.0)*px);
IkReal x374=((50.0)*py);
IkReal x375=((3.7947)*cj3);
CheckValue<IkReal> x376=IKPowWithIntegerCheck(IKsign(((((-19.0)*x371))+(((-19.0)*x372)))),-1);
if(!x376.valid){
continue;
}
CheckValue<IkReal> x377 = IKatan2WithCheck(IkReal(((((-1.0)*x370*x374))+(((-1.0)*x372*x374))+((py*x375))+(((-1.0)*x374*(py*py)))+(((2.8875)*py)))),((((-1.0)*x373*(px*px)))+(((-1.0)*x370*x373))+((px*x375))+(((-1.0)*x371*x373))+(((2.8875)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x377.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x376.value)))+(x377.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x378=IKsin(j0);
IkReal x379=IKcos(j0);
IkReal x380=(px*x379);
IkReal x381=(py*x378);
evalcond[0]=(((py*x379))+(((-1.0)*px*x378)));
evalcond[1]=((-0.19)+(((-0.273)*sj2*sj3))+x380+x381+(((-0.273)*cj2*cj3))+(((-0.139)*cj2)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.38)*x381))+(((0.38)*x380))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x382=(cj2*px);
IkReal x383=((0.273)*cj3);
IkReal x384=(cj2*py);
IkReal x385=((0.273)*sj2*sj3);
CheckValue<IkReal> x386=IKPowWithIntegerCheck(IKsign(((((-1.0)*(px*px)))+(((-1.0)*(py*py))))),-1);
if(!x386.valid){
continue;
}
CheckValue<IkReal> x387 = IKatan2WithCheck(IkReal(((((-1.0)*py*x385))+(((-0.139)*x384))+(((-0.19)*py))+(((-1.0)*x383*x384)))),((((-0.139)*x382))+(((-0.19)*px))+(((-1.0)*px*x385))+(((-1.0)*x382*x383))),IKFAST_ATAN2_MAGTHRESH);
if(!x387.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x386.value)))+(x387.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x388=IKsin(j0);
IkReal x389=IKcos(j0);
IkReal x390=(px*x389);
IkReal x391=(py*x388);
evalcond[0]=((((-1.0)*px*x388))+((py*x389)));
evalcond[1]=((-0.19)+(((-0.273)*sj2*sj3))+x391+x390+(((-0.273)*cj2*cj3))+(((-0.139)*cj2)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((0.38)*x390))+(((0.38)*x391))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x392=((0.139)*sj2);
IkReal x393=((0.273)*cj2*sj3);
IkReal x394=((0.273)*cj3*sj2);
IkReal x395=(x394+x392);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.05282)*cj2))+(((0.10374)*cj2*cj3))+(((-1.0)*(py*py)))+(((0.10374)*sj2*sj3)));
evalcond[2]=((((-1.0)*x393))+x395+pz);
evalcond[3]=((((-1.0)*x395))+x393+(((-1.0)*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x396=(cj2*py);
IkReal x397=((273.0)*px);
IkReal x398=(sj2*sj3);
IkReal x399=((px*px)+(py*py));
j0eval[0]=x399;
j0eval[1]=IKsign(x399);
j0eval[2]=((IKabs(((((-139.0)*x396))+(((-273.0)*py*x398))+(((-190.0)*py))+(((-273.0)*cj3*x396)))))+(IKabs(((((-190.0)*px))+(((-1.0)*cj2*cj3*x397))+(((-1.0)*x397*x398))+(((-139.0)*cj2*px))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal j0eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x400=py*py;
IkReal x401=px*px;
IkReal x402=pz*pz;
IkReal x403=((500000.0)*px);
IkReal x404=((500000.0)*py);
IkReal x405=((37947.0)*cj3);
j0eval[0]=(x401+x400);
j0eval[1]=IKsign(((((19.0)*x400))+(((19.0)*x401))));
j0eval[2]=((IKabs((((py*x405))+(((28875.0)*py))+(((-1.0)*x402*x404))+(((-1.0)*x401*x404))+(((-1.0)*x404*(py*py))))))+(IKabs(((((-1.0)*x403*(px*px)))+(((28875.0)*px))+((px*x405))+(((-1.0)*x402*x403))+(((-1.0)*x400*x403))))));
if( IKabs(j0eval[0]) < 0.0000010000000000  || IKabs(j0eval[1]) < 0.0000010000000000  || IKabs(j0eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
IkReal x406=x267;
evalcond[0]=((px*px)+(py*py));
evalcond[1]=0;
evalcond[2]=x406;
evalcond[3]=((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))));
evalcond[4]=x406;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x407=x267;
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
evalcond[2]=x407;
evalcond[3]=((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz))));
evalcond[4]=x407;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x408=pz*pz;
IkReal x409=py*py;
IkReal x410=px*px;
IkReal x411=((50.0)*px);
IkReal x412=((50.0)*py);
IkReal x413=((3.7947)*cj3);
CheckValue<IkReal> x414 = IKatan2WithCheck(IkReal((((py*x413))+(((-1.0)*x412*(py*py)))+(((-1.0)*x410*x412))+(((2.8875)*py))+(((-1.0)*x408*x412)))),((((-1.0)*x411*(px*px)))+((px*x413))+(((2.8875)*px))+(((-1.0)*x408*x411))+(((-1.0)*x409*x411))),IKFAST_ATAN2_MAGTHRESH);
if(!x414.valid){
continue;
}
CheckValue<IkReal> x415=IKPowWithIntegerCheck(IKsign(((((19.0)*x410))+(((19.0)*x409)))),-1);
if(!x415.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(x414.value)+(((1.5707963267949)*(x415.value))));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x416=IKcos(j0);
IkReal x417=IKsin(j0);
IkReal x418=(px*x416);
IkReal x419=(py*x417);
evalcond[0]=(((py*x416))+(((-1.0)*px*x417)));
evalcond[1]=((-0.19)+(((-0.273)*sj2*sj3))+(((-0.273)*cj2*cj3))+(((-0.139)*cj2))+(((-1.0)*x418))+(((-1.0)*x419)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-0.38)*x418))+(((-0.38)*x419))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x420=((0.139)*cj2);
IkReal x421=((0.273)*sj2*sj3);
IkReal x422=((0.273)*cj2*cj3);
CheckValue<IkReal> x423=IKPowWithIntegerCheck(IKsign(((px*px)+(py*py))),-1);
if(!x423.valid){
continue;
}
CheckValue<IkReal> x424 = IKatan2WithCheck(IkReal(((((-0.19)*py))+(((-1.0)*py*x421))+(((-1.0)*py*x420))+(((-1.0)*py*x422)))),((((-1.0)*px*x422))+(((-1.0)*px*x420))+(((-1.0)*px*x421))+(((-0.19)*px))),IKFAST_ATAN2_MAGTHRESH);
if(!x424.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x423.value)))+(x424.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[3];
IkReal x425=IKcos(j0);
IkReal x426=IKsin(j0);
IkReal x427=(px*x425);
IkReal x428=(py*x426);
evalcond[0]=((((-1.0)*px*x426))+((py*x425)));
evalcond[1]=((-0.19)+(((-0.273)*sj2*sj3))+(((-1.0)*x427))+(((-1.0)*x428))+(((-0.273)*cj2*cj3))+(((-0.139)*cj2)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-0.38)*x428))+(((-0.38)*x427))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x429=((0.075894)*cj3);
IkReal x430=(sj1*sj2);
IkReal x431=(cj2*cj3);
IkReal x432=(cj1*pz);
IkReal x433=((0.273)*sj3);
IkReal x434=((1.0)*pz);
IkReal x435=((0.273)*cj3);
IkReal x436=((0.139)*cj2);
IkReal x437=((0.139)*sj2);
IkReal x438=(pz*x434);
IkReal x439=(sj2*x433);
evalcond[0]=((IKabs(px))+(IKabs(py)));
evalcond[1]=0;
evalcond[2]=((0.12995)+(((-1.0)*x438))+(((0.10374)*x431))+x429+(((0.05282)*cj2))+(((0.10374)*sj2*sj3)));
evalcond[3]=((-0.19)+(((-0.273)*x431))+(((-1.0)*x436))+(((-1.0)*x439))+(((-1.0)*x432)));
evalcond[4]=((((-1.0)*sj1*x434))+(((-1.0)*cj2*x433))+x437+((sj2*x435)));
evalcond[5]=((0.05775)+(((-1.0)*x438))+(((-0.38)*x432))+x429);
evalcond[6]=((((-1.0)*x434))+(((-0.273)*cj1*x431))+(((-0.19)*cj1))+(((-1.0)*cj1*x439))+(((-1.0)*cj1*x436))+((x430*x435))+(((0.139)*x430))+(((-1.0)*cj2*sj1*x433)));
evalcond[7]=(((cj1*x437))+(((0.19)*sj1))+((x430*x433))+((cj1*sj2*x435))+(((0.273)*sj1*x431))+(((-1.0)*cj1*cj2*x433))+((sj1*x436)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j0array[4], cj0array[4], sj0array[4];
bool j0valid[4]={false};
_nj0 = 4;
j0array[0]=0;
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=1.5707963267949;
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
j0array[2]=3.14159265358979;
sj0array[2]=IKsin(j0array[2]);
cj0array[2]=IKcos(j0array[2]);
j0array[3]=-1.5707963267949;
sj0array[3]=IKsin(j0array[3]);
cj0array[3]=IKcos(j0array[3]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
if( j0array[2] > IKPI )
{
    j0array[2]-=IK2PI;
}
else if( j0array[2] < -IKPI )
{    j0array[2]+=IK2PI;
}
j0valid[2] = true;
if( j0array[3] > IKPI )
{
    j0array[3]-=IK2PI;
}
else if( j0array[3] < -IKPI )
{    j0array[3]+=IK2PI;
}
j0valid[3] = true;
for(int ij0 = 0; ij0 < 4; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 4; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j0]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x440=px*px;
IkReal x441=py*py;
IkReal x442=pz*pz;
IkReal x443=((50.0)*px);
IkReal x444=((50.0)*py);
IkReal x445=((19.0)*sj1);
IkReal x446=((3.7947)*cj3);
IkReal x447=((19.0)*cj1*pz);
CheckValue<IkReal> x448=IKPowWithIntegerCheck(IKsign((((x440*x445))+((x441*x445)))),-1);
if(!x448.valid){
continue;
}
CheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(((((-2.8875)*py))+((x444*(py*py)))+((py*x447))+((x440*x444))+(((-1.0)*py*x446))+((x442*x444)))),((((-2.8875)*px))+((px*x447))+((x441*x443))+((x442*x443))+((x443*(px*px)))+(((-1.0)*px*x446))),IKFAST_ATAN2_MAGTHRESH);
if(!x449.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x448.value)))+(x449.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x450=IKcos(j0);
IkReal x451=IKsin(j0);
IkReal x452=((1.0)*px);
IkReal x453=(cj1*pz);
IkReal x454=((0.273)*cj3);
IkReal x455=((0.139)*cj2);
IkReal x456=((0.139)*sj2);
IkReal x457=((0.273)*sj2*sj3);
IkReal x458=((0.273)*cj2*sj3);
IkReal x459=(py*sj1*x451);
IkReal x460=((1.0)*py*x451);
IkReal x461=(px*sj1*x450);
evalcond[0]=((((-1.0)*x451*x452))+((py*x450)));
evalcond[1]=((-0.19)+(((-1.0)*x453))+(((-1.0)*x455))+(((-1.0)*x457))+x459+x461+(((-1.0)*cj2*x454)));
evalcond[2]=(((sj2*x454))+(((-1.0)*cj1*x450*x452))+(((-1.0)*x458))+(((-1.0)*cj1*x460))+x456+(((-1.0)*pz*sj1)));
evalcond[3]=((0.05775)+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*px*x452))+(((-1.0)*(py*py)))+(((0.38)*x461))+(((-0.38)*x453))+(((0.38)*x459)));
evalcond[4]=(((cj1*x456))+(((0.19)*sj1))+(((-1.0)*x460))+(((-1.0)*cj1*x458))+((sj1*x455))+((sj1*x457))+(((-1.0)*x450*x452))+((cj1*sj2*x454))+((cj2*sj1*x454)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x462=((0.139)*cj2);
IkReal x463=(cj1*pz);
IkReal x464=((0.273)*sj2*sj3);
IkReal x465=((0.273)*cj2*cj3);
CheckValue<IkReal> x466=IKPowWithIntegerCheck(IKsign((((sj1*(py*py)))+((sj1*(px*px))))),-1);
if(!x466.valid){
continue;
}
CheckValue<IkReal> x467 = IKatan2WithCheck(IkReal(((((0.19)*py))+((py*x465))+((py*x463))+((py*x462))+((py*x464)))),((((0.19)*px))+((px*x462))+((px*x463))+((px*x465))+((px*x464))),IKFAST_ATAN2_MAGTHRESH);
if(!x467.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x466.value)))+(x467.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x468=IKcos(j0);
IkReal x469=IKsin(j0);
IkReal x470=((1.0)*px);
IkReal x471=(cj1*pz);
IkReal x472=((0.273)*cj3);
IkReal x473=((0.139)*cj2);
IkReal x474=((0.139)*sj2);
IkReal x475=((0.273)*sj2*sj3);
IkReal x476=((0.273)*cj2*sj3);
IkReal x477=(py*sj1*x469);
IkReal x478=((1.0)*py*x469);
IkReal x479=(px*sj1*x468);
evalcond[0]=((((-1.0)*x469*x470))+((py*x468)));
evalcond[1]=((-0.19)+(((-1.0)*x475))+(((-1.0)*x473))+(((-1.0)*x471))+x477+x479+(((-1.0)*cj2*x472)));
evalcond[2]=((((-1.0)*x476))+(((-1.0)*cj1*x468*x470))+(((-1.0)*cj1*x478))+x474+(((-1.0)*pz*sj1))+((sj2*x472)));
evalcond[3]=((0.05775)+(((-1.0)*px*x470))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-0.38)*x471))+(((-1.0)*(py*py)))+(((0.38)*x479))+(((0.38)*x477)));
evalcond[4]=(((cj1*sj2*x472))+(((-1.0)*x468*x470))+((cj2*sj1*x472))+(((0.19)*sj1))+(((-1.0)*x478))+((cj1*x474))+(((-1.0)*cj1*x476))+((sj1*x473))+((sj1*x475)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j0array[1], cj0array[1], sj0array[1];
bool j0valid[1]={false};
_nj0 = 1;
IkReal x480=(px*sj2);
IkReal x481=((0.273)*cj3);
IkReal x482=(py*sj2);
IkReal x483=((1.0)*pz*sj1);
IkReal x484=((0.273)*cj2*sj3);
CheckValue<IkReal> x485=IKPowWithIntegerCheck(IKsign((((cj1*(px*px)))+((cj1*(py*py))))),-1);
if(!x485.valid){
continue;
}
CheckValue<IkReal> x486 = IKatan2WithCheck(IkReal(((((0.139)*x482))+((x481*x482))+(((-1.0)*py*x483))+(((-1.0)*py*x484)))),((((0.139)*x480))+(((-1.0)*px*x484))+(((-1.0)*px*x483))+((x480*x481))),IKFAST_ATAN2_MAGTHRESH);
if(!x486.valid){
continue;
}
j0array[0]=((-1.5707963267949)+(((1.5707963267949)*(x485.value)))+(x486.value));
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
for(int ij0 = 0; ij0 < 1; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 1; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
{
IkReal evalcond[5];
IkReal x487=IKcos(j0);
IkReal x488=IKsin(j0);
IkReal x489=((1.0)*px);
IkReal x490=(cj1*pz);
IkReal x491=((0.273)*cj3);
IkReal x492=((0.139)*cj2);
IkReal x493=((0.139)*sj2);
IkReal x494=((0.273)*sj2*sj3);
IkReal x495=((0.273)*cj2*sj3);
IkReal x496=(py*sj1*x488);
IkReal x497=((1.0)*py*x488);
IkReal x498=(px*sj1*x487);
evalcond[0]=(((py*x487))+(((-1.0)*x488*x489)));
evalcond[1]=((-0.19)+(((-1.0)*x492))+(((-1.0)*x494))+(((-1.0)*cj2*x491))+(((-1.0)*x490))+x498+x496);
evalcond[2]=((((-1.0)*x495))+(((-1.0)*cj1*x497))+x493+(((-1.0)*cj1*x487*x489))+(((-1.0)*pz*sj1))+((sj2*x491)));
evalcond[3]=((0.05775)+(((-0.38)*x490))+(((0.38)*x496))+(((0.38)*x498))+(((-1.0)*px*x489))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
evalcond[4]=((((-1.0)*x497))+(((-1.0)*cj1*x495))+(((0.19)*sj1))+((cj1*sj2*x491))+((sj1*x494))+((sj1*x492))+(((-1.0)*x487*x489))+((cj1*x493))+((cj2*sj1*x491)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x500 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);
if(!x500.valid){
continue;
}
IkReal x499=x500.value;
j0array[0]=((-1.0)*x499);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x499)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j1eval[2];
IkReal x501=py*py;
IkReal x502=cj0*cj0;
IkReal x503=(((x501*x502))+(((-1.0)*x502*(px*px)))+(((-1.0)*(pz*pz)))+(((-2.0)*cj0*px*py*sj0))+(((-1.0)*x501)));
j1eval[0]=x503;
j1eval[1]=IKsign(x503);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x504=(cj0*px);
IkReal x505=((0.139)*sj2);
IkReal x506=(cj2*pz);
IkReal x507=(py*sj0);
IkReal x508=((1.96402877697842)*sj2);
IkReal x509=(pz*sj3);
IkReal x510=((1.0)*sj2);
IkReal x511=((0.273)*sj2);
IkReal x512=((0.273)*cj2*sj3);
IkReal x513=((1.96402877697842)*cj2*sj3);
j1eval[0]=(((x507*x513))+(((-1.0)*cj3*x504*x508))+(((-1.0)*x508*x509))+(((-1.0)*x504*x510))+((x504*x513))+(((-1.0)*cj3*x507*x508))+(((-1.36690647482014)*pz))+(((-1.0)*x506))+(((-1.96402877697842)*cj3*x506))+(((-1.0)*x507*x510)));
j1eval[1]=IKsign((((x507*x512))+(((-1.0)*x505*x507))+(((-0.273)*cj3*x506))+((x504*x512))+(((-0.139)*x506))+(((-0.19)*pz))+(((-1.0)*cj3*x504*x511))+(((-1.0)*cj3*x507*x511))+(((-1.0)*x504*x505))+(((-1.0)*x509*x511))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x514=((0.273)*cj3);
IkReal x515=(pz*sj2);
IkReal x516=((1.96402877697842)*cj3);
IkReal x517=(py*sj0);
IkReal x518=((1.96402877697842)*sj3);
IkReal x519=(cj2*pz);
IkReal x520=(cj0*px);
IkReal x521=((0.273)*sj3);
IkReal x522=(cj2*x520);
IkReal x523=(sj2*sj3*x517);
j1eval[0]=((((-1.36690647482014)*x517))+(((-1.0)*cj2*x517))+(((-1.36690647482014)*x520))+(((-1.0)*cj2*x516*x517))+(((-1.0)*x522))+(((-1.0)*x518*x519))+(((-1.0)*sj2*x517*x518))+x515+(((-1.0)*x516*x522))+((x515*x516))+(((-1.0)*sj2*x518*x520)));
j1eval[1]=IKsign(((((-0.19)*x517))+(((-0.139)*x522))+(((-0.139)*cj2*x517))+((x514*x515))+(((-1.0)*sj2*x517*x521))+(((-1.0)*cj2*x514*x517))+(((0.139)*x515))+(((-1.0)*sj2*x520*x521))+(((-0.19)*x520))+(((-1.0)*x519*x521))+(((-1.0)*x514*x522))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x524=cj2*cj2;
IkReal x525=cj3*cj3;
IkReal x526=((0.273)*cj3);
IkReal x527=(cj0*px);
IkReal x528=(py*sj0);
IkReal x529=(pz*sj2);
IkReal x530=((0.139)*cj2);
IkReal x531=((0.075894)*cj3);
IkReal x532=(cj2*sj2);
IkReal x533=(cj2*sj3);
IkReal x534=(cj3*sj3);
IkReal x535=((0.075894)*sj3);
IkReal x536=((0.273)*sj2*sj3);
IkReal x537=((0.149058)*x525);
CheckValue<IkReal> x538=IKPowWithIntegerCheck(IKsign(((((-1.0)*x527*x530))+(((-1.0)*x527*x536))+(((-0.273)*pz*x533))+(((0.139)*x529))+((x526*x529))+(((-1.0)*x528*x530))+(((-1.0)*x528*x536))+(((-1.0)*cj2*x526*x527))+(((-1.0)*cj2*x526*x528))+(((-0.19)*x527))+(((-0.19)*x528)))),-1);
if(!x538.valid){
continue;
}
CheckValue<IkReal> x539 = IKatan2WithCheck(IkReal(((-0.110629)+(((-1.0)*x532*x535))+(((-0.10374)*sj2*sj3))+(((-1.0)*x524*x531))+(((-1.0)*x524*x537))+(((0.074529)*x525))+(((0.055208)*x524))+(((-0.149058)*x532*x534))+(pz*pz)+(((-0.05282)*cj2))+(((-0.10374)*cj2*cj3)))),((((-1.0)*x532*x537))+((pz*x528))+((pz*x527))+(((-0.02641)*sj2))+(((-0.05187)*cj3*sj2))+(((-1.0)*x531*x532))+(((0.055208)*x532))+(((-0.074529)*x534))+(((0.05187)*x533))+((x524*x535))+(((0.149058)*x524*x534))+(((-0.037947)*sj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x539.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x538.value)))+(x539.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x540=IKsin(j1);
IkReal x541=IKcos(j1);
IkReal x542=((0.273)*sj3);
IkReal x543=(cj0*px);
IkReal x544=((0.273)*cj3);
IkReal x545=(py*sj0);
IkReal x546=((1.0)*pz);
IkReal x547=((0.139)*sj2);
IkReal x548=(sj2*x540);
IkReal x549=((1.0)*x541);
IkReal x550=(cj2*x541);
IkReal x551=(cj2*x540);
IkReal x552=((0.38)*x540);
IkReal x553=(sj2*x541);
evalcond[0]=((-0.19)+(((-1.0)*x541*x546))+(((-1.0)*sj2*x542))+(((-1.0)*cj2*x544))+((x540*x543))+((x540*x545))+(((-0.139)*cj2)));
evalcond[1]=((((-1.0)*x545*x549))+(((-1.0)*cj2*x542))+((sj2*x544))+(((-1.0)*x540*x546))+x547+(((-1.0)*x543*x549)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-0.38)*pz*x541))+(((-1.0)*pz*x546))+(((0.075894)*cj3))+((x543*x552))+(((-1.0)*(py*py)))+((x545*x552)));
evalcond[3]=((((-0.139)*x550))+((x544*x548))+(((-1.0)*x544*x550))+((x540*x547))+(((-1.0)*x546))+(((-0.19)*x541))+(((-1.0)*x542*x553))+(((-1.0)*x542*x551)));
evalcond[4]=((((0.19)*x540))+((x541*x547))+(((-1.0)*x543))+(((-1.0)*x545))+((x542*x548))+((x544*x553))+((x544*x551))+(((0.139)*x551))+(((-1.0)*x542*x550)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x554=cj2*cj2;
IkReal x555=cj3*cj3;
IkReal x556=(cj3*sj3);
IkReal x557=(cj2*sj2);
IkReal x558=((0.075894)*cj3);
IkReal x559=(cj2*pz);
IkReal x560=(cj2*sj3);
IkReal x561=((0.273)*sj2);
IkReal x562=(cj0*px);
IkReal x563=((1.0)*pz);
IkReal x564=(py*sj0);
IkReal x565=((0.139)*sj2);
IkReal x566=((0.075894)*x554);
IkReal x567=((0.149058)*x555);
CheckValue<IkReal> x568=IKPowWithIntegerCheck(IKsign(((((-1.0)*x564*x565))+(((-1.0)*cj3*x561*x564))+(((-1.0)*cj3*x561*x562))+(((-0.139)*x559))+(((0.273)*x560*x564))+(((0.273)*x560*x562))+(((-1.0)*pz*sj3*x561))+(((-0.19)*pz))+(((-1.0)*x562*x565))+(((-0.273)*cj3*x559)))),-1);
if(!x568.valid){
continue;
}
CheckValue<IkReal> x569 = IKatan2WithCheck(IkReal((((sj3*x566))+(((-0.02641)*sj2))+(((-0.05187)*cj3*sj2))+(((0.05187)*x560))+(((0.055208)*x557))+(((-1.0)*x562*x563))+(((0.149058)*x554*x556))+(((-1.0)*x557*x567))+(((-0.074529)*x556))+(((-1.0)*x563*x564))+(((-1.0)*x557*x558))+(((-0.037947)*sj3)))),((-0.019321)+(((0.149058)*x556*x557))+((x554*x558))+(((0.075894)*sj3*x557))+(pz*pz)+(((-1.0)*x558))+(((-0.074529)*x555))+(((-0.055208)*x554))+((x554*x567))),IKFAST_ATAN2_MAGTHRESH);
if(!x569.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x568.value)))+(x569.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x570=IKsin(j1);
IkReal x571=IKcos(j1);
IkReal x572=((0.273)*sj3);
IkReal x573=(cj0*px);
IkReal x574=((0.273)*cj3);
IkReal x575=(py*sj0);
IkReal x576=((1.0)*pz);
IkReal x577=((0.139)*sj2);
IkReal x578=(sj2*x570);
IkReal x579=((1.0)*x571);
IkReal x580=(cj2*x571);
IkReal x581=(cj2*x570);
IkReal x582=((0.38)*x570);
IkReal x583=(sj2*x571);
evalcond[0]=((-0.19)+(((-1.0)*cj2*x574))+(((-1.0)*sj2*x572))+(((-1.0)*x571*x576))+(((-0.139)*cj2))+((x570*x573))+((x570*x575)));
evalcond[1]=((((-1.0)*cj2*x572))+(((-1.0)*x573*x579))+(((-1.0)*x570*x576))+(((-1.0)*x575*x579))+((sj2*x574))+x577);
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-0.38)*pz*x571))+((x575*x582))+((x573*x582))+(((-1.0)*pz*x576))+(((0.075894)*cj3))+(((-1.0)*(py*py))));
evalcond[3]=((((-0.139)*x580))+(((-1.0)*x572*x581))+(((-1.0)*x572*x583))+((x574*x578))+(((-1.0)*x576))+(((-1.0)*x574*x580))+((x570*x577))+(((-0.19)*x571)));
evalcond[4]=(((x571*x577))+(((-1.0)*x572*x580))+(((0.139)*x581))+((x574*x581))+((x574*x583))+(((-1.0)*x573))+(((-1.0)*x575))+(((0.19)*x570))+((x572*x578)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x584=py*py;
IkReal x585=cj0*cj0;
IkReal x586=((0.273)*cj3);
IkReal x587=(py*sj0);
IkReal x588=((0.273)*sj3);
IkReal x589=(pz*sj2);
IkReal x590=((0.139)*cj2);
IkReal x591=(cj0*px);
IkReal x592=(cj2*pz);
IkReal x593=((0.139)*sj2);
IkReal x594=(cj2*x591);
CheckValue<IkReal> x595=IKPowWithIntegerCheck(IKsign((((x584*x585))+(((-1.0)*x584))+(((-1.0)*(pz*pz)))+(((-2.0)*x587*x591))+(((-1.0)*x585*(px*px))))),-1);
if(!x595.valid){
continue;
}
CheckValue<IkReal> x596 = IKatan2WithCheck(IkReal(((((-0.139)*x589))+(((-1.0)*x587*x590))+(((-1.0)*x586*x594))+(((-1.0)*x586*x589))+(((-1.0)*x590*x591))+(((-1.0)*sj2*x588*x591))+(((-0.19)*x591))+((x588*x592))+(((-1.0)*cj2*x586*x587))+(((-1.0)*sj2*x587*x588))+(((-0.19)*x587)))),(((cj2*x587*x588))+(((0.19)*pz))+(((-1.0)*x587*x593))+((pz*x590))+((x588*x589))+(((-1.0)*sj2*x586*x591))+(((-1.0)*sj2*x586*x587))+((x588*x594))+(((-1.0)*x591*x593))+((x586*x592))),IKFAST_ATAN2_MAGTHRESH);
if(!x596.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x595.value)))+(x596.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x597=IKsin(j1);
IkReal x598=IKcos(j1);
IkReal x599=((0.273)*sj3);
IkReal x600=(cj0*px);
IkReal x601=((0.273)*cj3);
IkReal x602=(py*sj0);
IkReal x603=((1.0)*pz);
IkReal x604=((0.139)*sj2);
IkReal x605=(sj2*x597);
IkReal x606=((1.0)*x598);
IkReal x607=(cj2*x598);
IkReal x608=(cj2*x597);
IkReal x609=((0.38)*x597);
IkReal x610=(sj2*x598);
evalcond[0]=((-0.19)+(((-1.0)*cj2*x601))+((x597*x602))+((x597*x600))+(((-1.0)*sj2*x599))+(((-1.0)*x598*x603))+(((-0.139)*cj2)));
evalcond[1]=((((-1.0)*x602*x606))+(((-1.0)*x597*x603))+(((-1.0)*cj2*x599))+(((-1.0)*x600*x606))+x604+((sj2*x601)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-0.38)*pz*x598))+((x600*x609))+(((0.075894)*cj3))+((x602*x609))+(((-1.0)*pz*x603))+(((-1.0)*(py*py))));
evalcond[3]=(((x601*x605))+(((-0.139)*x607))+(((-1.0)*x599*x610))+((x597*x604))+(((-1.0)*x599*x608))+(((-0.19)*x598))+(((-1.0)*x603))+(((-1.0)*x601*x607)));
evalcond[4]=(((x601*x608))+((x601*x610))+(((-1.0)*x600))+(((-1.0)*x602))+(((0.139)*x608))+(((-1.0)*x599*x607))+(((0.19)*x597))+((x599*x605))+((x598*x604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j0array[2], cj0array[2], sj0array[2];
bool j0valid[2]={false};
_nj0 = 2;
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal(py),((-1.0)*px),IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
IkReal x611=x612.value;
j0array[0]=((-1.0)*x611);
sj0array[0]=IKsin(j0array[0]);
cj0array[0]=IKcos(j0array[0]);
j0array[1]=((3.14159265358979)+(((-1.0)*x611)));
sj0array[1]=IKsin(j0array[1]);
cj0array[1]=IKcos(j0array[1]);
if( j0array[0] > IKPI )
{
    j0array[0]-=IK2PI;
}
else if( j0array[0] < -IKPI )
{    j0array[0]+=IK2PI;
}
j0valid[0] = true;
if( j0array[1] > IKPI )
{
    j0array[1]-=IK2PI;
}
else if( j0array[1] < -IKPI )
{    j0array[1]+=IK2PI;
}
j0valid[1] = true;
for(int ij0 = 0; ij0 < 2; ++ij0)
{
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < 2; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

{
IkReal j2eval[2];
j2eval[0]=((IKabs(sj3))+(((9.63948332369385)*(IKabs(((0.05282)+(((0.10374)*cj3))))))));
j2eval[1]=((1.0)+(((3.92805755395683)*cj3))+(((3.85740903679934)*(sj3*sj3)))+(((3.85740903679934)*(cj3*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x613=(py*sj0);
IkReal x614=(cj0*px);
j1eval[0]=((x614*x614)+(x613*x613)+(((2.0)*x613*x614))+(pz*pz));
j1eval[1]=((((2.63157894736842)*(IKabs(((((0.38)*x614))+(((0.38)*x613)))))))+(IKabs(pz)));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1, j2]

} else
{
{
IkReal j1array[2], cj1array[2], sj1array[2];
bool j1valid[2]={false};
_nj1 = 2;
IkReal x615=pz*pz;
IkReal x616=((((0.38)*cj0*px))+(((0.38)*py*sj0)));
CheckValue<IkReal> x619 = IKatan2WithCheck(IkReal(((-0.38)*pz)),x616,IKFAST_ATAN2_MAGTHRESH);
if(!x619.valid){
continue;
}
IkReal x617=((1.0)*(x619.value));
if((((x616*x616)+(((0.1444)*x615)))) < -0.00001)
continue;
CheckValue<IkReal> x620=IKPowWithIntegerCheck(IKabs(IKsqrt(((x616*x616)+(((0.1444)*x615))))),-1);
if(!x620.valid){
continue;
}
if( (((x620.value)*(((0.05775)+(((-1.0)*(px*px)))+(((-1.0)*x615))+(((0.075894)*cj3))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x620.value)*(((0.05775)+(((-1.0)*(px*px)))+(((-1.0)*x615))+(((0.075894)*cj3))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x618=IKasin(((x620.value)*(((0.05775)+(((-1.0)*(px*px)))+(((-1.0)*x615))+(((0.075894)*cj3))+(((-1.0)*(py*py)))))));
j1array[0]=((((-1.0)*x618))+(((-1.0)*x617)));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
j1array[1]=((3.14159265358979)+(((-1.0)*x617))+x618);
sj1array[1]=IKsin(j1array[1]);
cj1array[1]=IKcos(j1array[1]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
if( j1array[1] > IKPI )
{
    j1array[1]-=IK2PI;
}
else if( j1array[1] < -IKPI )
{    j1array[1]+=IK2PI;
}
j1valid[1] = true;
for(int ij1 = 0; ij1 < 2; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 2; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];

{
IkReal j2eval[2];
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x621=(cj1*cj3);
j2eval[0]=(x621+(((1.23659314306796)*cj1)));
j2eval[1]=IKsign(((((75.894)*x621))+(((93.85)*cj1))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
IkReal x622=(cj3*sj1);
j2eval[0]=((((-1.23659314306796)*sj1))+(((-1.0)*x622)));
j2eval[1]=IKsign(((((-93.85)*sj1))+(((-75.894)*x622))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j1))), 6.28318530717959)));
evalcond[1]=((((-1.0)*px*sj0))+((cj0*py)));
evalcond[2]=((0.05775)+(((-0.38)*pz))+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=0;
cj1=1.0;
j1=0;
IkReal x623=(cj0*px);
IkReal x624=((273000.0)*sj3);
IkReal x625=(py*sj0);
IkReal x626=((273000.0)*cj3);
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=((IKabs((((pz*x624))+(((-1.0)*x623*x626))+(((51870.0)*sj3))+(((-1.0)*x625*x626))+(((-139000.0)*x623))+(((-139000.0)*x625)))))+(IKabs(((26410.0)+((pz*x626))+(((51870.0)*cj3))+((x624*x625))+(((139000.0)*pz))+((x623*x624))))));
j2eval[2]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=0;
cj1=1.0;
j1=0;
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-1783150.0)+(((-1441986.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x627=px*px;
IkReal x628=py*py;
IkReal x629=pz*pz;
IkReal x630=((13650000.0)*sj3);
IkReal x631=((13650000.0)*cj3);
IkReal x632=(py*sj0);
IkReal x633=((5187000.0)*cj0*px);
CheckValue<IkReal> x634 = IKatan2WithCheck(IkReal(((((1035953.1)*cj3*sj3))+(((-1.0)*x629*x630))+(((-5187000.0)*cj3*x632))+(((-1.0)*x628*x630))+(((-2641000.0)*x632))+(((-1.0)*x627*x630))+(((1773817.5)*sj3))+(((-2641000.0)*cj0*px))+(((-1.0)*cj3*x633)))),((903152.5)+(((-1.0)*x629*x631))+(((5187000.0)*sj3*x632))+(((-1.0)*x628*x631))+((sj3*x633))+(((-6950000.0)*x627))+(((-6950000.0)*x629))+(((-6950000.0)*x628))+(((2301280.8)*cj3))+(((-1.0)*x627*x631))+(((1035953.1)*(cj3*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x634.valid){
continue;
}
CheckValue<IkReal> x635=IKPowWithIntegerCheck(IKsign(((-1783150.0)+(((-1441986.0)*cj3)))),-1);
if(!x635.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x634.value)+(((1.5707963267949)*(x635.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x636=IKcos(j2);
IkReal x637=IKsin(j2);
IkReal x638=((0.273)*cj3);
IkReal x639=(sj3*x637);
evalcond[0]=((-0.19)+(((-0.273)*x639))+(((-1.0)*pz))+(((-1.0)*x636*x638))+(((-0.139)*x636)));
evalcond[1]=((((0.139)*x637))+(((-0.273)*sj3*x636))+(((-1.0)*py*sj0))+(((-1.0)*cj0*px))+((x637*x638)));
evalcond[2]=((0.12995)+(((0.10374)*x639))+(((-1.0)*(px*px)))+(((0.10374)*cj3*x636))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.05282)*x636))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x640=(cj0*px);
IkReal x641=((273000.0)*sj3);
IkReal x642=(py*sj0);
IkReal x643=((273000.0)*cj3);
CheckValue<IkReal> x644 = IKatan2WithCheck(IkReal(((((-1.0)*x642*x643))+(((-1.0)*x640*x643))+(((51870.0)*sj3))+((pz*x641))+(((-139000.0)*x640))+(((-139000.0)*x642)))),((26410.0)+((x640*x641))+((pz*x643))+((x641*x642))+(((51870.0)*cj3))+(((139000.0)*pz))),IKFAST_ATAN2_MAGTHRESH);
if(!x644.valid){
continue;
}
CheckValue<IkReal> x645=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x645.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x644.value)+(((1.5707963267949)*(x645.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x646=IKcos(j2);
IkReal x647=IKsin(j2);
IkReal x648=((0.273)*cj3);
IkReal x649=(sj3*x647);
evalcond[0]=((-0.19)+(((-1.0)*x646*x648))+(((-1.0)*pz))+(((-0.139)*x646))+(((-0.273)*x649)));
evalcond[1]=((((0.139)*x647))+(((-1.0)*py*sj0))+(((-0.273)*sj3*x646))+(((-1.0)*cj0*px))+((x647*x648)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.05282)*x646))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.10374)*x649))+(((-1.0)*(py*py)))+(((0.10374)*cj3*x646)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j1)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*px*sj0))+((cj0*py)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((0.38)*pz))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
IkReal x650=(cj0*px);
IkReal x651=((273000.0)*sj3);
IkReal x652=(py*sj0);
IkReal x653=((273000.0)*cj3);
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=((IKabs(((((139000.0)*x652))+(((139000.0)*x650))+((x652*x653))+(((51870.0)*sj3))+(((-1.0)*pz*x651))+((x650*x653)))))+(IKabs(((26410.0)+(((-1.0)*x651*x652))+(((-139000.0)*pz))+(((51870.0)*cj3))+(((-1.0)*pz*x653))+(((-1.0)*x650*x651))))));
j2eval[2]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=0;
cj1=-1.0;
j1=3.14159265358979;
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-1783150.0)+(((-1441986.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x654=px*px;
IkReal x655=py*py;
IkReal x656=pz*pz;
IkReal x657=((13650000.0)*sj3);
IkReal x658=(py*sj0);
IkReal x659=((5187000.0)*cj3);
IkReal x660=((13650000.0)*cj3);
IkReal x661=(cj0*px);
IkReal x662=((5187000.0)*sj3);
IkReal x663=((13650000.0)*x656);
CheckValue<IkReal> x664 = IKatan2WithCheck(IkReal(((((1035953.1)*cj3*sj3))+(((2641000.0)*x661))+(((-1.0)*x655*x657))+(((-1.0)*x656*x657))+(((2641000.0)*x658))+((x659*x661))+(((1773817.5)*sj3))+((x658*x659))+(((-1.0)*x654*x657)))),((903152.5)+(((-1.0)*x654*x660))+(((-6950000.0)*x654))+(((-6950000.0)*x656))+(((-6950000.0)*x655))+(((-1.0)*x661*x662))+(((-1.0)*x658*x662))+(((2301280.8)*cj3))+(((-1.0)*x656*x660))+(((-1.0)*x655*x660))+(((1035953.1)*(cj3*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x664.valid){
continue;
}
CheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign(((-1783150.0)+(((-1441986.0)*cj3)))),-1);
if(!x665.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x664.value)+(((1.5707963267949)*(x665.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x666=IKcos(j2);
IkReal x667=IKsin(j2);
IkReal x668=((0.273)*cj3);
IkReal x669=(sj3*x667);
evalcond[0]=((-0.19)+(((-0.139)*x666))+pz+(((-1.0)*x666*x668))+(((-0.273)*x669)));
evalcond[1]=(((x667*x668))+(((0.139)*x667))+(((-0.273)*sj3*x666))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.10374)*x669))+(((0.05282)*x666))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.10374)*cj3*x666))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x670=(cj0*px);
IkReal x671=((273000.0)*sj3);
IkReal x672=(py*sj0);
IkReal x673=((273000.0)*cj3);
CheckValue<IkReal> x674=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x674.valid){
continue;
}
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((((x672*x673))+((x670*x673))+(((51870.0)*sj3))+(((-1.0)*pz*x671))+(((139000.0)*x672))+(((139000.0)*x670)))),((26410.0)+(((-139000.0)*pz))+(((-1.0)*pz*x673))+(((-1.0)*x670*x671))+(((51870.0)*cj3))+(((-1.0)*x671*x672))),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x674.value)))+(x675.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x676=IKcos(j2);
IkReal x677=IKsin(j2);
IkReal x678=((0.273)*cj3);
IkReal x679=(sj3*x677);
evalcond[0]=((-0.19)+(((-0.139)*x676))+(((-0.273)*x679))+pz+(((-1.0)*x676*x678)));
evalcond[1]=((((-0.273)*sj3*x676))+((x677*x678))+(((0.139)*x677))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.10374)*x679))+(((0.05282)*x676))+(((0.10374)*cj3*x676))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*px*sj0))+((cj0*py)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((0.38)*cj0*px))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((0.38)*py*sj0)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x680=(cj0*px);
IkReal x681=((273000.0)*sj3);
IkReal x682=(py*sj0);
IkReal x683=((273000.0)*cj3);
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=((IKabs(((26410.0)+(((-1.0)*x680*x683))+(((51870.0)*cj3))+(((-1.0)*x682*x683))+((pz*x681))+(((-139000.0)*x680))+(((-139000.0)*x682)))))+(IKabs(((((-1.0)*x681*x682))+(((-1.0)*x680*x681))+(((51870.0)*sj3))+(((-139000.0)*pz))+(((-1.0)*pz*x683))))));
j2eval[2]=IKsign(((-93850.0)+(((-75894.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
j2eval[0]=((1.23659314306796)+cj3);
j2eval[1]=IKsign(((1783150.0)+(((1441986.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x684=px*px;
IkReal x685=py*py;
IkReal x686=pz*pz;
IkReal x687=((13650000.0)*sj3);
IkReal x688=((13650000.0)*cj3);
IkReal x689=((5187000.0)*pz);
CheckValue<IkReal> x690 = IKatan2WithCheck(IkReal(((((2641000.0)*pz))+((x686*x687))+(((-1773817.5)*sj3))+((x685*x687))+(((-1035953.1)*cj3*sj3))+((x684*x687))+((cj3*x689)))),((-903152.5)+((x686*x688))+((x685*x688))+(((-2301280.8)*cj3))+(((6950000.0)*x684))+(((6950000.0)*x685))+(((6950000.0)*x686))+(((-1.0)*sj3*x689))+((x684*x688))+(((-1035953.1)*(cj3*cj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x690.valid){
continue;
}
CheckValue<IkReal> x691=IKPowWithIntegerCheck(IKsign(((1783150.0)+(((1441986.0)*cj3)))),-1);
if(!x691.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x690.value)+(((1.5707963267949)*(x691.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x692=IKsin(j2);
IkReal x693=IKcos(j2);
IkReal x694=((0.273)*cj3);
IkReal x695=(sj3*x692);
evalcond[0]=((((0.139)*x692))+((x692*x694))+(((-1.0)*pz))+(((-0.273)*sj3*x693)));
evalcond[1]=((-0.19)+(((-1.0)*x693*x694))+(((-0.139)*x693))+(((-0.273)*x695))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.10374)*cj3*x693))+(((0.05282)*x693))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.10374)*x695))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x696=(cj0*px);
IkReal x697=((273000.0)*sj3);
IkReal x698=(py*sj0);
IkReal x699=((273000.0)*cj3);
CheckValue<IkReal> x700 = IKatan2WithCheck(IkReal(((((-1.0)*x696*x697))+(((-1.0)*x697*x698))+(((51870.0)*sj3))+(((-139000.0)*pz))+(((-1.0)*pz*x699)))),((26410.0)+(((-139000.0)*x698))+(((-139000.0)*x696))+(((-1.0)*x696*x699))+((pz*x697))+(((51870.0)*cj3))+(((-1.0)*x698*x699))),IKFAST_ATAN2_MAGTHRESH);
if(!x700.valid){
continue;
}
CheckValue<IkReal> x701=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x701.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x700.value)+(((1.5707963267949)*(x701.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x702=IKsin(j2);
IkReal x703=IKcos(j2);
IkReal x704=((0.273)*cj3);
IkReal x705=(sj3*x702);
evalcond[0]=(((x702*x704))+(((-1.0)*pz))+(((0.139)*x702))+(((-0.273)*sj3*x703)));
evalcond[1]=((-0.19)+(((-0.139)*x703))+(((-1.0)*x703*x704))+(((-0.273)*x705))+((cj0*px))+((py*sj0)));
evalcond[2]=((0.12995)+(((0.10374)*cj3*x703))+(((-1.0)*(px*px)))+(((0.05282)*x703))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((0.10374)*x705)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*px*sj0))+((cj0*py)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-0.38)*py*sj0))+(((-0.38)*cj0*px))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j2eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x706=(cj0*px);
IkReal x707=((273000.0)*sj3);
IkReal x708=(py*sj0);
IkReal x709=((273000.0)*cj3);
j2eval[0]=((1.23659314306796)+cj3);
j2eval[1]=IKsign(((93850.0)+(((75894.0)*cj3))));
j2eval[2]=((IKabs(((((-1.0)*pz*x709))+(((-1.0)*x706*x707))+(((-1.0)*x707*x708))+(((-139000.0)*pz))+(((-51870.0)*sj3)))))+(IKabs(((-26410.0)+(((-1.0)*x706*x709))+(((-139000.0)*x706))+(((-139000.0)*x708))+(((-1.0)*x708*x709))+((pz*x707))+(((-51870.0)*cj3))))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  || IKabs(j2eval[2]) < 0.0000010000000000  )
{
{
IkReal j2eval[2];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
j2eval[0]=((-1.23659314306796)+(((-1.0)*cj3)));
j2eval[1]=IKsign(((-1783150.0)+(((-1441986.0)*cj3))));
if( IKabs(j2eval[0]) < 0.0000010000000000  || IKabs(j2eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j2]

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x710=px*px;
IkReal x711=py*py;
IkReal x712=pz*pz;
IkReal x713=((13650000.0)*sj3);
IkReal x714=((13650000.0)*cj3);
IkReal x715=((5187000.0)*pz);
CheckValue<IkReal> x716 = IKatan2WithCheck(IkReal(((((1035953.1)*cj3*sj3))+(((2641000.0)*pz))+(((-1.0)*x711*x713))+(((-1.0)*x710*x713))+(((1773817.5)*sj3))+(((-1.0)*x712*x713))+((cj3*x715)))),((903152.5)+(((-1.0)*x711*x714))+(((-1.0)*x710*x714))+(((2301280.8)*cj3))+(((-1.0)*x712*x714))+(((1035953.1)*(cj3*cj3)))+(((-6950000.0)*x711))+(((-6950000.0)*x710))+(((-6950000.0)*x712))+(((-1.0)*sj3*x715))),IKFAST_ATAN2_MAGTHRESH);
if(!x716.valid){
continue;
}
CheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(((-1783150.0)+(((-1441986.0)*cj3)))),-1);
if(!x717.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x716.value)+(((1.5707963267949)*(x717.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x718=IKsin(j2);
IkReal x719=IKcos(j2);
IkReal x720=((0.273)*cj3);
IkReal x721=(sj3*x718);
evalcond[0]=((((0.139)*x718))+pz+((x718*x720))+(((-0.273)*sj3*x719)));
evalcond[1]=((-0.19)+(((-0.139)*x719))+(((-1.0)*py*sj0))+(((-1.0)*x719*x720))+(((-1.0)*cj0*px))+(((-0.273)*x721)));
evalcond[2]=((0.12995)+(((0.05282)*x719))+(((-1.0)*(px*px)))+(((0.10374)*cj3*x719))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))+(((0.10374)*x721)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x722=(cj0*px);
IkReal x723=((273000.0)*sj3);
IkReal x724=(py*sj0);
IkReal x725=((273000.0)*cj3);
CheckValue<IkReal> x726=IKPowWithIntegerCheck(IKsign(((93850.0)+(((75894.0)*cj3)))),-1);
if(!x726.valid){
continue;
}
CheckValue<IkReal> x727 = IKatan2WithCheck(IkReal(((((-1.0)*x723*x724))+(((-1.0)*x722*x723))+(((-139000.0)*pz))+(((-51870.0)*sj3))+(((-1.0)*pz*x725)))),((-26410.0)+(((-1.0)*x724*x725))+(((-1.0)*x722*x725))+(((-139000.0)*x724))+(((-139000.0)*x722))+((pz*x723))+(((-51870.0)*cj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x727.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x726.value)))+(x727.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[3];
IkReal x728=IKsin(j2);
IkReal x729=IKcos(j2);
IkReal x730=((0.273)*cj3);
IkReal x731=(sj3*x728);
evalcond[0]=(((x728*x730))+(((0.139)*x728))+pz+(((-0.273)*sj3*x729)));
evalcond[1]=((-0.19)+(((-0.139)*x729))+(((-1.0)*py*sj0))+(((-0.273)*x731))+(((-1.0)*cj0*px))+(((-1.0)*x729*x730)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.10374)*cj3*x729))+(((0.05282)*x729))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((0.10374)*x731))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j2]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x732=cj1*cj1;
IkReal x733=(cj0*px);
IkReal x734=((139.0)*pz);
IkReal x735=(cj3*sj1);
IkReal x736=((273.0)*sj3);
IkReal x737=((273.0)*cj3);
IkReal x738=((273.0)*cj1);
IkReal x739=(cj1*sj1);
IkReal x740=((273.0)*py*sj0);
IkReal x741=((139.0)*py*sj0);
IkReal x742=(pz*x732);
CheckValue<IkReal> x743 = IKatan2WithCheck(IkReal(((((-139.0)*x733*x739))+(((51.87)*sj1*sj3))+(((-1.0)*py*sj0*x736))+(((-1.0)*x733*x735*x738))+((x732*x733*x736))+(((-1.0)*x733*x736))+((pz*x736*x739))+(((-1.0)*x734))+(((-1.0)*py*sj0*x735*x738))+((x737*x742))+(((-1.0)*x739*x741))+(((-1.0)*pz*x737))+((py*sj0*x732*x736))+((x732*x734)))),((((-139.0)*x733))+((py*sj0*x736*x739))+(((-1.0)*py*sj0*x737))+((x733*x736*x739))+((x734*x739))+((x732*x733*x737))+(((-1.0)*x733*x737))+((pz*x735*x738))+(((26.41)*sj1))+((x732*x741))+((pz*x736))+(((139.0)*x732*x733))+(((-1.0)*x741))+((py*sj0*x732*x737))+(((51.87)*x735))+(((-1.0)*x736*x742))),IKFAST_ATAN2_MAGTHRESH);
if(!x743.valid){
continue;
}
CheckValue<IkReal> x744=IKPowWithIntegerCheck(IKsign(((((-93.85)*sj1))+(((-75.894)*x735)))),-1);
if(!x744.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x743.value)+(((1.5707963267949)*(x744.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x745=IKcos(j2);
IkReal x746=IKsin(j2);
IkReal x747=(cj0*px);
IkReal x748=(py*sj0);
IkReal x749=((1.0)*pz);
IkReal x750=((0.273)*cj1);
IkReal x751=((1.0)*cj1);
IkReal x752=((0.273)*sj1);
IkReal x753=(cj3*x745);
IkReal x754=((0.139)*x746);
IkReal x755=((0.139)*x745);
IkReal x756=(sj3*x746);
IkReal x757=((0.273)*cj3*x746);
IkReal x758=((0.273)*sj3*x745);
evalcond[0]=((-0.19)+((sj1*x748))+((sj1*x747))+(((-0.273)*x756))+(((-0.273)*x753))+(((-1.0)*cj1*x749))+(((-1.0)*x755)));
evalcond[1]=((((-1.0)*sj1*x749))+(((-1.0)*x747*x751))+x754+x757+(((-1.0)*x748*x751))+(((-1.0)*x758)));
evalcond[2]=((0.12995)+(((0.05282)*x745))+(((-1.0)*(px*px)))+(((-1.0)*pz*x749))+(((0.075894)*cj3))+(((0.10374)*x753))+(((0.10374)*x756))+(((-1.0)*(py*py))));
evalcond[3]=((((-1.0)*x750*x753))+(((-1.0)*x750*x756))+(((-0.19)*cj1))+((sj1*x754))+(((-1.0)*sj3*x745*x752))+(((-1.0)*cj1*x755))+((cj3*x746*x752))+(((-1.0)*x749)));
evalcond[4]=(((cj1*x754))+((x752*x753))+((x752*x756))+(((0.19)*sj1))+((sj1*x755))+(((-1.0)*sj3*x745*x750))+(((-1.0)*x747))+(((-1.0)*x748))+((cj3*x746*x750)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x759=cj1*cj1;
IkReal x760=(cj0*px);
IkReal x761=(py*sj0);
IkReal x762=(cj3*pz);
IkReal x763=((51.87)*cj1);
IkReal x764=(pz*sj3);
IkReal x765=((273.0)*cj1*sj1);
IkReal x766=((273.0)*x759);
IkReal x767=((139.0)*cj1*sj1);
IkReal x768=((139.0)*x759);
CheckValue<IkReal> x769=IKPowWithIntegerCheck(IKsign(((((93.85)*cj1))+(((75.894)*cj1*cj3)))),-1);
if(!x769.valid){
continue;
}
CheckValue<IkReal> x770 = IKatan2WithCheck(IkReal((((sj3*x761*x765))+((x760*x768))+((sj3*x760*x765))+((x761*x768))+(((-1.0)*x764*x766))+((cj3*x760*x766))+((cj3*x761*x766))+((x762*x765))+((pz*x767))+(((-1.0)*sj3*x763)))),((((-1.0)*x762*x766))+(((-1.0)*sj3*x761*x766))+(((-26.41)*cj1))+(((-1.0)*cj3*x763))+(((-1.0)*sj3*x760*x766))+((x760*x767))+((x761*x767))+(((-1.0)*x764*x765))+((cj3*x760*x765))+((cj3*x761*x765))+(((-1.0)*pz*x768))),IKFAST_ATAN2_MAGTHRESH);
if(!x770.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(((1.5707963267949)*(x769.value)))+(x770.value));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x771=IKcos(j2);
IkReal x772=IKsin(j2);
IkReal x773=(cj0*px);
IkReal x774=(py*sj0);
IkReal x775=((1.0)*pz);
IkReal x776=((0.273)*cj1);
IkReal x777=((1.0)*cj1);
IkReal x778=((0.273)*sj1);
IkReal x779=(cj3*x771);
IkReal x780=((0.139)*x772);
IkReal x781=((0.139)*x771);
IkReal x782=(sj3*x772);
IkReal x783=((0.273)*cj3*x772);
IkReal x784=((0.273)*sj3*x771);
evalcond[0]=((-0.19)+(((-1.0)*x781))+((sj1*x774))+((sj1*x773))+(((-0.273)*x782))+(((-0.273)*x779))+(((-1.0)*cj1*x775)));
evalcond[1]=((((-1.0)*x774*x777))+(((-1.0)*x784))+x783+x780+(((-1.0)*x773*x777))+(((-1.0)*sj1*x775)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.10374)*x782))+(((0.10374)*x779))+(((-1.0)*pz*x775))+(((0.075894)*cj3))+(((-1.0)*(py*py)))+(((0.05282)*x771)));
evalcond[3]=(((cj3*x772*x778))+(((-0.19)*cj1))+((sj1*x780))+(((-1.0)*x776*x782))+(((-1.0)*cj1*x781))+(((-1.0)*x776*x779))+(((-1.0)*x775))+(((-1.0)*sj3*x771*x778)));
evalcond[4]=(((cj3*x772*x776))+((cj1*x780))+(((0.19)*sj1))+((sj1*x781))+((x778*x779))+((x778*x782))+(((-1.0)*x773))+(((-1.0)*x774))+(((-1.0)*sj3*x771*x776)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j2array[1], cj2array[1], sj2array[1];
bool j2valid[1]={false};
_nj2 = 1;
IkReal x785=((139000.0)*cj1);
IkReal x786=(py*sj0);
IkReal x787=(cj0*px);
IkReal x788=((273000.0)*cj3);
IkReal x789=((139000.0)*sj1);
IkReal x790=((273000.0)*cj1*sj3);
IkReal x791=((273000.0)*sj1*sj3);
CheckValue<IkReal> x792 = IKatan2WithCheck(IkReal(((((-1.0)*pz*sj1*x788))+(((-1.0)*cj1*x787*x788))+(((-1.0)*cj1*x786*x788))+(((51870.0)*sj3))+((pz*x790))+(((-1.0)*x787*x791))+(((-1.0)*x786*x791))+(((-1.0)*x785*x787))+(((-1.0)*x785*x786))+(((-1.0)*pz*x789)))),((26410.0)+(((-1.0)*sj1*x786*x788))+((x786*x790))+((x787*x790))+((pz*x791))+((pz*x785))+(((-1.0)*sj1*x787*x788))+(((51870.0)*cj3))+(((-1.0)*x787*x789))+(((-1.0)*x786*x789))+((cj1*pz*x788))),IKFAST_ATAN2_MAGTHRESH);
if(!x792.valid){
continue;
}
CheckValue<IkReal> x793=IKPowWithIntegerCheck(IKsign(((-93850.0)+(((-75894.0)*cj3)))),-1);
if(!x793.valid){
continue;
}
j2array[0]=((-1.5707963267949)+(x792.value)+(((1.5707963267949)*(x793.value))));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
for(int ij2 = 0; ij2 < 1; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 1; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];
{
IkReal evalcond[5];
IkReal x794=IKcos(j2);
IkReal x795=IKsin(j2);
IkReal x796=(cj0*px);
IkReal x797=(py*sj0);
IkReal x798=((1.0)*pz);
IkReal x799=((0.273)*cj1);
IkReal x800=((1.0)*cj1);
IkReal x801=((0.273)*sj1);
IkReal x802=(cj3*x794);
IkReal x803=((0.139)*x795);
IkReal x804=((0.139)*x794);
IkReal x805=(sj3*x795);
IkReal x806=((0.273)*cj3*x795);
IkReal x807=((0.273)*sj3*x794);
evalcond[0]=((-0.19)+(((-0.273)*x802))+(((-0.273)*x805))+((sj1*x796))+((sj1*x797))+(((-1.0)*cj1*x798))+(((-1.0)*x804)));
evalcond[1]=((((-1.0)*x796*x800))+(((-1.0)*x797*x800))+x806+x803+(((-1.0)*x807))+(((-1.0)*sj1*x798)));
evalcond[2]=((0.12995)+(((-1.0)*(px*px)))+(((0.10374)*x802))+(((0.10374)*x805))+(((0.05282)*x794))+(((0.075894)*cj3))+(((-1.0)*pz*x798))+(((-1.0)*(py*py))));
evalcond[3]=(((cj3*x795*x801))+(((-1.0)*x798))+(((-1.0)*sj3*x794*x801))+(((-1.0)*x799*x802))+(((-1.0)*x799*x805))+(((-0.19)*cj1))+(((-1.0)*cj1*x804))+((sj1*x803)));
evalcond[4]=((((0.19)*sj1))+((cj1*x803))+((x801*x805))+((x801*x802))+((sj1*x804))+(((-1.0)*sj3*x794*x799))+(((-1.0)*x796))+(((-1.0)*x797))+((cj3*x795*x799)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j2array[2], cj2array[2], sj2array[2];
bool j2valid[2]={false};
_nj2 = 2;
IkReal x808=((0.05282)+(((0.10374)*cj3)));
CheckValue<IkReal> x811 = IKatan2WithCheck(IkReal(x808),((0.10374)*sj3),IKFAST_ATAN2_MAGTHRESH);
if(!x811.valid){
continue;
}
IkReal x809=((1.0)*(x811.value));
if((((x808*x808)+(((0.0107619876)*(sj3*sj3))))) < -0.00001)
continue;
CheckValue<IkReal> x812=IKPowWithIntegerCheck(IKabs(IKsqrt(((x808*x808)+(((0.0107619876)*(sj3*sj3)))))),-1);
if(!x812.valid){
continue;
}
if( (((x812.value)*(((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) < -1-IKFAST_SINCOS_THRESH || (((x812.value)*(((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py))))))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x810=IKasin(((x812.value)*(((0.12995)+(((-1.0)*(px*px)))+(((0.075894)*cj3))+(((-1.0)*(pz*pz)))+(((-1.0)*(py*py)))))));
j2array[0]=((((-1.0)*x810))+(((-1.0)*x809)));
sj2array[0]=IKsin(j2array[0]);
cj2array[0]=IKcos(j2array[0]);
j2array[1]=((3.14159265358979)+x810+(((-1.0)*x809)));
sj2array[1]=IKsin(j2array[1]);
cj2array[1]=IKcos(j2array[1]);
if( j2array[0] > IKPI )
{
    j2array[0]-=IK2PI;
}
else if( j2array[0] < -IKPI )
{    j2array[0]+=IK2PI;
}
j2valid[0] = true;
if( j2array[1] > IKPI )
{
    j2array[1]-=IK2PI;
}
else if( j2array[1] < -IKPI )
{    j2array[1]+=IK2PI;
}
j2valid[1] = true;
for(int ij2 = 0; ij2 < 2; ++ij2)
{
if( !j2valid[ij2] )
{
    continue;
}
_ij2[0] = ij2; _ij2[1] = -1;
for(int iij2 = ij2+1; iij2 < 2; ++iij2)
{
if( j2valid[iij2] && IKabs(cj2array[ij2]-cj2array[iij2]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij2]-sj2array[iij2]) < IKFAST_SOLUTION_THRESH )
{
    j2valid[iij2]=false; _ij2[1] = iij2; break; 
}
}
j2 = j2array[ij2]; cj2 = cj2array[ij2]; sj2 = sj2array[ij2];

{
IkReal j1eval[2];
IkReal x813=py*py;
IkReal x814=cj0*cj0;
IkReal x815=((((-1.0)*x814*(px*px)))+((x813*x814))+(((-1.0)*x813))+(((-1.0)*(pz*pz)))+(((-2.0)*cj0*px*py*sj0)));
j1eval[0]=x815;
j1eval[1]=IKsign(x815);
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x816=(cj0*px);
IkReal x817=((0.139)*sj2);
IkReal x818=(cj2*pz);
IkReal x819=(py*sj0);
IkReal x820=((1.96402877697842)*sj2);
IkReal x821=(pz*sj3);
IkReal x822=((1.0)*sj2);
IkReal x823=((0.273)*sj2);
IkReal x824=((0.273)*cj2*sj3);
IkReal x825=((1.96402877697842)*cj2*sj3);
j1eval[0]=((((-1.0)*x816*x822))+(((-1.96402877697842)*cj3*x818))+(((-1.0)*cj3*x816*x820))+(((-1.0)*x819*x822))+((x819*x825))+((x816*x825))+(((-1.0)*x818))+(((-1.0)*x820*x821))+(((-1.36690647482014)*pz))+(((-1.0)*cj3*x819*x820)));
j1eval[1]=IKsign(((((-1.0)*cj3*x816*x823))+(((-1.0)*x816*x817))+(((-1.0)*x817*x819))+((x819*x824))+(((-0.19)*pz))+((x816*x824))+(((-1.0)*x821*x823))+(((-0.139)*x818))+(((-1.0)*cj3*x819*x823))+(((-0.273)*cj3*x818))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x826=((0.273)*cj3);
IkReal x827=(pz*sj2);
IkReal x828=((1.96402877697842)*cj3);
IkReal x829=(py*sj0);
IkReal x830=((1.96402877697842)*sj3);
IkReal x831=(cj2*pz);
IkReal x832=(cj0*px);
IkReal x833=((0.273)*sj3);
IkReal x834=(cj2*x832);
IkReal x835=(sj2*sj3*x829);
j1eval[0]=((((-1.0)*cj2*x829))+(((-1.0)*sj2*x830*x832))+(((-1.0)*sj2*x829*x830))+(((-1.0)*x828*x834))+(((-1.36690647482014)*x832))+(((-1.0)*x830*x831))+(((-1.36690647482014)*x829))+(((-1.0)*x834))+(((-1.0)*cj2*x828*x829))+x827+((x827*x828)));
j1eval[1]=IKsign(((((-1.0)*sj2*x829*x833))+(((-1.0)*sj2*x832*x833))+(((-1.0)*x826*x834))+(((-1.0)*cj2*x826*x829))+(((-0.139)*x834))+(((-0.19)*x829))+(((0.139)*x827))+(((-0.19)*x832))+(((-0.139)*cj2*x829))+((x826*x827))+(((-1.0)*x831*x833))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x836=cj2*cj2;
IkReal x837=cj3*cj3;
IkReal x838=((0.273)*cj3);
IkReal x839=(cj0*px);
IkReal x840=(py*sj0);
IkReal x841=(pz*sj2);
IkReal x842=((0.139)*cj2);
IkReal x843=((0.075894)*cj3);
IkReal x844=(cj2*sj2);
IkReal x845=(cj2*sj3);
IkReal x846=(cj3*sj3);
IkReal x847=((0.075894)*sj3);
IkReal x848=((0.273)*sj2*sj3);
IkReal x849=((0.149058)*x837);
CheckValue<IkReal> x850 = IKatan2WithCheck(IkReal(((-0.110629)+(((-0.10374)*sj2*sj3))+(((-0.149058)*x844*x846))+(((-1.0)*x836*x849))+(((-1.0)*x836*x843))+(((0.074529)*x837))+(pz*pz)+(((0.055208)*x836))+(((-1.0)*x844*x847))+(((-0.05282)*cj2))+(((-0.10374)*cj2*cj3)))),((((-0.02641)*sj2))+(((-0.074529)*x846))+(((-0.05187)*cj3*sj2))+((pz*x839))+(((0.055208)*x844))+((pz*x840))+(((-1.0)*x843*x844))+((x836*x847))+(((0.149058)*x836*x846))+(((-1.0)*x844*x849))+(((0.05187)*x845))+(((-0.037947)*sj3))),IKFAST_ATAN2_MAGTHRESH);
if(!x850.valid){
continue;
}
CheckValue<IkReal> x851=IKPowWithIntegerCheck(IKsign((((x838*x841))+(((-1.0)*x840*x842))+(((-1.0)*x840*x848))+(((-1.0)*cj2*x838*x840))+(((-0.273)*pz*x845))+(((-1.0)*cj2*x838*x839))+(((-0.19)*x840))+(((-1.0)*x839*x848))+(((-1.0)*x839*x842))+(((-0.19)*x839))+(((0.139)*x841)))),-1);
if(!x851.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x850.value)+(((1.5707963267949)*(x851.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x852=IKsin(j1);
IkReal x853=IKcos(j1);
IkReal x854=((0.273)*sj3);
IkReal x855=(cj0*px);
IkReal x856=((0.273)*cj3);
IkReal x857=(py*sj0);
IkReal x858=((1.0)*pz);
IkReal x859=((0.139)*sj2);
IkReal x860=(sj2*x852);
IkReal x861=((1.0)*x853);
IkReal x862=(cj2*x853);
IkReal x863=(cj2*x852);
IkReal x864=((0.38)*x852);
IkReal x865=(sj2*x853);
evalcond[0]=((-0.19)+(((-1.0)*x853*x858))+(((-1.0)*cj2*x856))+(((-1.0)*sj2*x854))+((x852*x857))+((x852*x855))+(((-0.139)*cj2)));
evalcond[1]=(((sj2*x856))+(((-1.0)*x852*x858))+(((-1.0)*cj2*x854))+x859+(((-1.0)*x857*x861))+(((-1.0)*x855*x861)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+((x855*x864))+(((-0.38)*pz*x853))+(((0.075894)*cj3))+(((-1.0)*pz*x858))+(((-1.0)*(py*py)))+((x857*x864)));
evalcond[3]=((((-0.139)*x862))+(((-1.0)*x854*x865))+(((-1.0)*x854*x863))+(((-1.0)*x858))+(((-0.19)*x853))+((x856*x860))+(((-1.0)*x856*x862))+((x852*x859)));
evalcond[4]=((((-1.0)*x854*x862))+(((-1.0)*x855))+(((-1.0)*x857))+(((0.139)*x863))+((x856*x865))+((x856*x863))+(((0.19)*x852))+((x853*x859))+((x854*x860)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x866=cj2*cj2;
IkReal x867=cj3*cj3;
IkReal x868=(cj3*sj3);
IkReal x869=(cj2*sj2);
IkReal x870=((0.075894)*cj3);
IkReal x871=(cj2*pz);
IkReal x872=(cj2*sj3);
IkReal x873=((0.273)*sj2);
IkReal x874=(cj0*px);
IkReal x875=((1.0)*pz);
IkReal x876=(py*sj0);
IkReal x877=((0.139)*sj2);
IkReal x878=((0.075894)*x866);
IkReal x879=((0.149058)*x867);
CheckValue<IkReal> x880=IKPowWithIntegerCheck(IKsign(((((-0.139)*x871))+(((-1.0)*x876*x877))+(((-0.19)*pz))+(((-0.273)*cj3*x871))+(((-1.0)*pz*sj3*x873))+(((-1.0)*cj3*x873*x876))+(((-1.0)*cj3*x873*x874))+(((-1.0)*x874*x877))+(((0.273)*x872*x874))+(((0.273)*x872*x876)))),-1);
if(!x880.valid){
continue;
}
CheckValue<IkReal> x881 = IKatan2WithCheck(IkReal(((((0.05187)*x872))+(((-0.02641)*sj2))+((sj3*x878))+(((-0.05187)*cj3*sj2))+(((0.055208)*x869))+(((-1.0)*x869*x870))+(((-1.0)*x869*x879))+(((-0.074529)*x868))+(((0.149058)*x866*x868))+(((-1.0)*x875*x876))+(((-1.0)*x874*x875))+(((-0.037947)*sj3)))),((-0.019321)+(((-0.055208)*x866))+(((0.149058)*x868*x869))+((x866*x879))+((x866*x870))+(pz*pz)+(((-0.074529)*x867))+(((0.075894)*sj3*x869))+(((-1.0)*x870))),IKFAST_ATAN2_MAGTHRESH);
if(!x881.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x880.value)))+(x881.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x882=IKsin(j1);
IkReal x883=IKcos(j1);
IkReal x884=((0.273)*sj3);
IkReal x885=(cj0*px);
IkReal x886=((0.273)*cj3);
IkReal x887=(py*sj0);
IkReal x888=((1.0)*pz);
IkReal x889=((0.139)*sj2);
IkReal x890=(sj2*x882);
IkReal x891=((1.0)*x883);
IkReal x892=(cj2*x883);
IkReal x893=(cj2*x882);
IkReal x894=((0.38)*x882);
IkReal x895=(sj2*x883);
evalcond[0]=((-0.19)+(((-1.0)*x883*x888))+(((-1.0)*cj2*x886))+((x882*x885))+((x882*x887))+(((-1.0)*sj2*x884))+(((-0.139)*cj2)));
evalcond[1]=((((-1.0)*cj2*x884))+(((-1.0)*x882*x888))+((sj2*x886))+(((-1.0)*x885*x891))+x889+(((-1.0)*x887*x891)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-1.0)*pz*x888))+(((0.075894)*cj3))+((x885*x894))+(((-1.0)*(py*py)))+(((-0.38)*pz*x883))+((x887*x894)));
evalcond[3]=(((x886*x890))+(((-1.0)*x884*x893))+(((-1.0)*x884*x895))+((x882*x889))+(((-1.0)*x888))+(((-0.19)*x883))+(((-0.139)*x892))+(((-1.0)*x886*x892)));
evalcond[4]=(((x886*x895))+((x886*x893))+(((-1.0)*x884*x892))+((x884*x890))+(((0.19)*x882))+((x883*x889))+(((-1.0)*x885))+(((-1.0)*x887))+(((0.139)*x893)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x896=py*py;
IkReal x897=cj0*cj0;
IkReal x898=((0.273)*cj3);
IkReal x899=(py*sj0);
IkReal x900=((0.273)*sj3);
IkReal x901=(pz*sj2);
IkReal x902=((0.139)*cj2);
IkReal x903=(cj0*px);
IkReal x904=(cj2*pz);
IkReal x905=((0.139)*sj2);
IkReal x906=(cj2*x903);
CheckValue<IkReal> x907=IKPowWithIntegerCheck(IKsign(((((-2.0)*x899*x903))+((x896*x897))+(((-1.0)*x897*(px*px)))+(((-1.0)*x896))+(((-1.0)*(pz*pz))))),-1);
if(!x907.valid){
continue;
}
CheckValue<IkReal> x908 = IKatan2WithCheck(IkReal(((((-1.0)*sj2*x900*x903))+(((-1.0)*x902*x903))+(((-0.19)*x903))+((x900*x904))+(((-1.0)*x898*x906))+(((-1.0)*x898*x901))+(((-0.19)*x899))+(((-0.139)*x901))+(((-1.0)*sj2*x899*x900))+(((-1.0)*x899*x902))+(((-1.0)*cj2*x898*x899)))),((((-1.0)*x903*x905))+(((-1.0)*sj2*x898*x903))+(((0.19)*pz))+((x900*x901))+((x900*x906))+((cj2*x899*x900))+(((-1.0)*sj2*x898*x899))+((pz*x902))+((x898*x904))+(((-1.0)*x899*x905))),IKFAST_ATAN2_MAGTHRESH);
if(!x908.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x907.value)))+(x908.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x909=IKsin(j1);
IkReal x910=IKcos(j1);
IkReal x911=((0.273)*sj3);
IkReal x912=(cj0*px);
IkReal x913=((0.273)*cj3);
IkReal x914=(py*sj0);
IkReal x915=((1.0)*pz);
IkReal x916=((0.139)*sj2);
IkReal x917=(sj2*x909);
IkReal x918=((1.0)*x910);
IkReal x919=(cj2*x910);
IkReal x920=(cj2*x909);
IkReal x921=((0.38)*x909);
IkReal x922=(sj2*x910);
evalcond[0]=((-0.19)+((x909*x914))+((x909*x912))+(((-1.0)*x910*x915))+(((-1.0)*sj2*x911))+(((-0.139)*cj2))+(((-1.0)*cj2*x913)));
evalcond[1]=(((sj2*x913))+(((-1.0)*x912*x918))+(((-1.0)*x914*x918))+x916+(((-1.0)*x909*x915))+(((-1.0)*cj2*x911)));
evalcond[2]=((0.05775)+(((-1.0)*(px*px)))+(((-1.0)*pz*x915))+((x914*x921))+(((0.075894)*cj3))+(((-0.38)*pz*x910))+(((-1.0)*(py*py)))+((x912*x921)));
evalcond[3]=((((-1.0)*x913*x919))+((x909*x916))+(((-1.0)*x915))+(((-0.19)*x910))+(((-0.139)*x919))+((x913*x917))+(((-1.0)*x911*x920))+(((-1.0)*x911*x922)));
evalcond[4]=(((x910*x916))+(((0.139)*x920))+((x911*x917))+(((-1.0)*x914))+(((-1.0)*x912))+(((-1.0)*x911*x919))+(((0.19)*x909))+((x913*x922))+((x913*x920)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}

}

}
}
return solutions.GetNumSolutions()>0;
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "69feda14a9ec6d01480eccb137edee22"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
