#define IKFAST_NAMESPACE ik_pr2_rightarm_torso
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2014-10-08 15:53:51.001534
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54;
x0=IKcos(j[1]);
x1=IKcos(j[4]);
x2=IKcos(j[2]);
x3=IKsin(j[4]);
x4=IKsin(j[2]);
x5=IKsin(j[3]);
x6=IKcos(j[3]);
x7=IKsin(j[1]);
x8=IKcos(j[5]);
x9=IKsin(j[5]);
x10=IKsin(j[6]);
x11=IKcos(j[6]);
x12=IKsin(j[7]);
x13=IKcos(j[7]);
x14=((1.0)*x1);
x15=((1.0)*x3);
x16=((0.321)*x1);
x17=((1.0)*x6);
x18=((0.321)*x5);
x19=((1.0)*x8);
x20=((1.0)*x9);
x21=((1.0)*x10);
x22=((0.321)*x6);
x23=((1.0)*x11);
x24=(x2*x7);
x25=((-1.0)*x3);
x26=(x2*x5);
x27=((-1.0)*x10);
x28=(x0*x2);
x29=((-1.0)*x1);
x30=(x0*x4);
x31=((-1.0)*x11);
x32=(x2*x6);
x33=(x5*x7);
x34=(x4*x7);
x35=(x15*x28);
x36=(x14*x32);
x37=(((x30*x5))+(((-1.0)*x17*x7)));
x38=(((x0*x5))+(((-1.0)*x17*x34)));
x39=(((x0*x6))+((x33*x4)));
x40=(x36+(((-1.0)*x15*x4)));
x41=((((-1.0)*x33))+(((-1.0)*x17*x30)));
x42=(x37*x9);
x43=(((x14*x4))+((x15*x32)));
x44=(x39*x8);
x45=((1.0)*x41);
x46=(x40*x9);
x47=(x1*x41);
x48=(((x26*x9))+((x8*(((((-1.0)*x36))+((x3*x4)))))));
x49=((((-1.0)*x14*x38))+((x15*x24)));
x50=(x49*x9);
x51=(((x8*((((x1*x38))+((x24*x25))))))+((x39*x9)));
x52=(((x8*((x47+((x25*x28))))))+x42);
x53=((((-1.0)*x21*x43))+(((-1.0)*x23*x48)));
x54=(((x31*x51))+((x27*((((x24*x29))+((x25*x38)))))));
eerot[0]=(((x10*((x42+((x8*(((((-1.0)*x35))+x47))))))))+((x11*((((x1*x28))+((x3*x41)))))));
eerot[1]=((((-1.0)*x12*((((x21*(((((-1.0)*x15*x41))+(((-1.0)*x14*x28))))))+((x23*x52))))))+((x13*((((x9*((((x29*x41))+x35))))+((x37*x8)))))));
eerot[2]=((((-1.0)*x12*((((x19*x37))+((x20*(((((-1.0)*x14*x41))+x35))))))))+((x13*((((x27*((((x28*x29))+((x25*x41))))))+((x31*x52)))))));
eetrans[0]=((-0.05)+(((0.1)*x0))+((x16*x28))+((x3*(((((-1.0)*x18*x7))+(((-1.0)*x22*x30))))))+(((0.4)*x28)));
eerot[3]=(((x10*x51))+((x11*((((x1*x24))+((x3*x38)))))));
eerot[4]=(((x13*((x44+x50))))+((x12*x54)));
eerot[5]=(((x13*x54))+((x12*(((((-1.0)*x20*x49))+(((-1.0)*x19*x39)))))));
eetrans[1]=((-0.188)+(((0.1)*x7))+((x16*x24))+(((0.4)*x24))+((x3*((((x0*x18))+(((-1.0)*x22*x34)))))));
eerot[6]=(((x10*x48))+(((-1.0)*x11*x43)));
eerot[7]=(((x12*x53))+((x13*((x46+((x26*x8)))))));
eerot[8]=(((x13*x53))+((x12*(((((-1.0)*x20*x40))+(((-1.0)*x19*x26)))))));
eetrans[2]=((0.739675)+(((-1.0)*x2*x22*x3))+(((-1.0)*x16*x4))+(((-0.4)*x4))+j[0]);
}

IKFAST_API int GetNumFreeParameters() { return 2; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {0, 3}; return freeparams; }
IKFAST_API int GetNumJoints() { return 8; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j12,cj12,sj12,htj12,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij12[2], _nj12,_ij29[2], _nj29;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij12[0] = -1; _ij12[1] = -1; _nj12 = 0;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j12=pfree[0]; cj12=cos(pfree[0]); sj12=sin(pfree[0]), htj12=tan(pfree[0]*0.5);
j29=pfree[1]; cj29=cos(pfree[1]); sj29=sin(pfree[1]), htj29=tan(pfree[1]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=((0.05)+px);
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((0.188)+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=((-0.739675)+(((-1.0)*j12))+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x55=((1.0)*px);
IkReal x56=((1.0)*pz);
IkReal x57=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x57))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x56)));
rxp0_2=((((-1.0)*r10*x55))+((py*r00)));
rxp1_0=((((-1.0)*r21*x57))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x56)));
rxp1_2=((((-1.0)*r11*x55))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x57)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x56)));
rxp2_2=((((-1.0)*r12*x55))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x58=((0.2)*px);
IkReal x59=((1.0)*pp);
IkReal x60=((0.509841)+x58+(((-1.0)*x59)));
IkReal x61=((-0.003759)+x58+(((-1.0)*x59)));
IkReal x62=(x59+x58);
IkReal x63=((0.509841)+(((-1.0)*x62)));
IkReal x64=((-0.003759)+(((-1.0)*x62)));
IkReal gconst0=x60;
IkReal gconst1=x61;
IkReal gconst2=x60;
IkReal gconst3=x61;
IkReal gconst4=x63;
IkReal gconst5=x64;
IkReal gconst6=x63;
IkReal gconst7=x64;
IkReal x65=py*py;
IkReal x66=sj29*sj29;
IkReal x67=px*px;
IkReal x68=((1.0)*gconst4);
IkReal x69=(gconst5*gconst7);
IkReal x70=(gconst0*gconst3);
IkReal x71=(gconst1*gconst2);
IkReal x72=((2.0)*gconst5);
IkReal x73=((1.0)*gconst0);
IkReal x74=(gconst1*gconst7);
IkReal x75=(gconst0*gconst6);
IkReal x76=(gconst1*gconst3);
IkReal x77=(gconst4*gconst7);
IkReal x78=((2.0)*gconst0);
IkReal x79=(gconst1*gconst6);
IkReal x80=(gconst0*gconst7);
IkReal x81=((2.0)*gconst4);
IkReal x82=(gconst3*gconst5);
IkReal x83=(gconst2*gconst5);
IkReal x84=(gconst3*gconst4);
IkReal x85=(gconst2*gconst4);
IkReal x86=(gconst4*gconst6);
IkReal x87=(gconst5*gconst6);
IkReal x88=(gconst0*gconst2);
IkReal x89=((1.05513984)*px*py);
IkReal x90=(gconst6*x65);
IkReal x91=((4.0)*px*py);
IkReal x92=((4.0)*x67);
IkReal x93=(gconst2*x65);
IkReal x94=(py*x66);
IkReal x95=((2.0)*x65);
IkReal x96=((1.0)*x65);
IkReal x97=((0.824328)*x66);
IkReal x98=((0.412164)*x66);
IkReal x99=(x65*x77);
IkReal x100=(x65*x87);
IkReal x101=(x65*x83);
IkReal x102=(x65*x84);
IkReal x103=(x65*x80);
IkReal x104=(x65*x79);
IkReal x105=((0.0834355125792)*x94);
IkReal x106=(x65*x71);
IkReal x107=(x65*x70);
IkReal x108=(x66*x83);
IkReal x109=(x65*x66);
IkReal x110=(x69*x96);
IkReal x111=(x68*x90);
IkReal x112=(x87*x98);
IkReal x113=(x85*x91);
IkReal x114=(x74*x91);
IkReal x115=(x82*x91);
IkReal x116=(x75*x91);
IkReal x117=(x84*x91);
IkReal x118=(x80*x91);
IkReal x119=(x83*x91);
IkReal x120=(x79*x91);
IkReal x121=(x83*x98);
IkReal x122=((0.06594624)*x109);
IkReal x123=(x74*x96);
IkReal x124=(x68*x93);
IkReal x125=(x73*x90);
IkReal x126=(x79*x98);
IkReal x127=(x82*x96);
IkReal x128=((0.3297312)*pp*x94);
IkReal x129=((0.06594624)*px*x94);
IkReal x130=(x73*x93);
IkReal x131=(x71*x98);
IkReal x132=(x76*x96);
IkReal x133=(x106+x107);
IkReal x134=(x100+x99);
IkReal x135=(x131+x130+x132);
IkReal x136=(x112+x111+x110);
IkReal x137=(x104+x101+x102+x103);
IkReal x138=(x120+x117+x119+x118);
IkReal x139=(x113+x116+x115+x114);
IkReal x140=(x126+x127+x124+x125+x122+x123+x121);
op[0]=(x134+(((-1.0)*x136)));
op[1]=((((-1.0)*x105))+x128+x129+(((-1.0)*x89)));
op[2]=((((-1.0)*x140))+((x87*x92))+((x81*x90))+(((-1.0)*x72*x90))+(((-1.0)*x77*x95))+x137+((x69*x95))+(((-1.0)*x87*x97))+(((-1.0)*x86*x92))+(((-1.0)*x69*x92))+((x77*x92)));
op[3]=((((-0.3297312)*gconst5*x94))+(((-1.0)*x77*x91))+((x86*x91))+x138+((x69*x91))+(((-1.0)*x87*x91))+(((-1.0)*x139))+(((-0.1648656)*gconst2*x94))+(((-0.3297312)*gconst6*x94))+(((-0.1648656)*gconst1*x94)));
op[4]=((((-1.0)*x82*x92))+((x79*x92))+((x81*x93))+(((-0.13189248)*x109))+(((-1.0)*x72*x93))+((gconst3*x65*x72))+(((-1.0)*x83*x97))+(((-1.0)*gconst7*x65*x78))+x134+x133+((x74*x95))+(((-1.0)*x136))+(((-1.0)*x135))+(((-1.0)*x74*x92))+(((-1.0)*x79*x97))+(((-1.0)*x79*x95))+((x75*x95))+(((-1.0)*x75*x92))+((x83*x92))+((x80*x92))+(((-1.0)*gconst3*x65*x81))+((x84*x92))+(((-1.0)*x85*x92)));
op[5]=(((x71*x91))+(((-0.1648656)*gconst5*x94))+((x70*x91))+x139+(((-1.0)*x138))+(((-1.0)*x76*x91))+(((-0.1648656)*gconst6*x94))+(((-0.3297312)*gconst1*x94))+(((-1.0)*x88*x91))+(((-0.3297312)*gconst2*x94)));
op[6]=((((-1.0)*x140))+((x71*x92))+(((-1.0)*x71*x97))+(((-1.0)*x71*x95))+((x78*x93))+(((-1.0)*x70*x95))+((x70*x92))+x137+((x76*x95))+(((-1.0)*x76*x92))+(((-1.0)*x88*x92)));
op[7]=((((-1.0)*x105))+(((-1.0)*x129))+x128+x89);
op[8]=(x133+(((-1.0)*x135)));
polyroots8(op,zeror,numroots);
IkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];
int numsolutions = 0;
for(int ij27 = 0; ij27 < numroots; ++ij27)
{
IkReal htj27 = zeror[ij27];
tempj27array[0]=((2.0)*(atan(htj27)));
for(int kj27 = 0; kj27 < 1; ++kj27)
{
j27array[numsolutions] = tempj27array[kj27];
if( j27array[numsolutions] > IKPI )
{
    j27array[numsolutions]-=IK2PI;
}
else if( j27array[numsolutions] < -IKPI )
{
    j27array[numsolutions]+=IK2PI;
}
sj27array[numsolutions] = IKsin(j27array[numsolutions]);
cj27array[numsolutions] = IKcos(j27array[numsolutions]);
numsolutions++;
}
}
bool j27valid[8]={true,true,true,true,true,true,true,true};
_nj27 = 8;
for(int ij27 = 0; ij27 < numsolutions; ++ij27)
    {
if( !j27valid[ij27] )
{
    continue;
}
    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];
htj27 = IKtan(j27/2);

_ij27[0] = ij27; _ij27[1] = -1;
for(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)
{
if( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )
{
    j27valid[iij27]=false; _ij27[1] = iij27; break; 
}
}
{
IkReal j28eval[2];
IkReal x141=cj27*cj27;
IkReal x142=py*py;
IkReal x143=px*px;
IkReal x144=pz*pz;
IkReal x145=((100.0)*sj29);
IkReal x146=(py*sj27);
IkReal x147=((4.0)*sj29);
IkReal x148=(cj27*px*sj29);
IkReal x149=(x141*x143);
IkReal x150=(x142*x147);
j28eval[0]=((((-1.0)*x142*x145))+(((20.0)*x148))+(((-1.0)*x144*x145))+(((-1.0)*sj29))+((x141*x142*x145))+(((-1.0)*x145*x149))+(((-200.0)*x146*x148))+(((20.0)*sj29*x146)));
j28eval[1]=IKsign(((((-1.0)*x150))+(((0.8)*sj29*x146))+(((-8.0)*x146*x148))+(((-1.0)*x144*x147))+((x141*x150))+(((-1.0)*x147*x149))+(((-0.04)*sj29))+(((0.8)*x148))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x151=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x151;
evalcond[2]=x151;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x152=((321000.0)*cj30);
IkReal x153=(py*sj27);
IkReal x154=((321000.0)*sj30);
IkReal x155=(cj27*px);
j28eval[0]=((1.02430295950156)+cj30);
j28eval[1]=((IKabs(((-40000.0)+(((-1.0)*pz*x154))+(((400000.0)*x153))+(((400000.0)*x155))+(((-32100.0)*cj30))+((x152*x153))+((x152*x155)))))+(IKabs(((((-1.0)*x154*x155))+(((-1.0)*x153*x154))+(((-1.0)*pz*x152))+(((32100.0)*sj30))+(((-400000.0)*pz))))));
j28eval[2]=IKsign(((263041.0)+(((256800.0)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x156=(pz*sj30);
IkReal x157=(cj27*px);
IkReal x158=(py*sj27);
IkReal x159=((10.0)*cj30);
IkReal x160=((321.0)*cj30);
IkReal x161=((1000.0)*pz);
j28eval[0]=((1.24610591900312)+(((-1.0)*x157*x159))+(((-1.0)*x158*x159))+cj30+(((-10.0)*x156))+(((-12.4610591900312)*x158))+(((-12.4610591900312)*x157)));
j28eval[1]=((IKabs(((((-100.0)*pz))+((x157*x161))+(((128.4)*sj30))+((x158*x161))+(((103.041)*cj30*sj30)))))+(IKabs(((-160.0)+((pz*x161))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))));
j28eval[2]=IKsign(((40.0)+(((-1.0)*x157*x160))+(((-1.0)*x158*x160))+(((-400.0)*x157))+(((-400.0)*x158))+(((32.1)*cj30))+(((-321.0)*x156))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x162=cj27*cj27;
IkReal x163=py*py;
IkReal x164=pz*pz;
IkReal x165=px*px;
IkReal x166=(cj27*px);
IkReal x167=((321.0)*sj30);
IkReal x168=(py*sj27);
IkReal x169=((321.0)*cj30);
IkReal x170=((321.0)*x168);
IkReal x171=((200.0)*x168);
IkReal x172=(x162*x163);
IkReal x173=(x162*x165);
j28eval[0]=((-1.0)+(((-100.0)*x163))+(((-100.0)*x164))+(((-100.0)*x173))+(((20.0)*x168))+(((20.0)*x166))+(((-1.0)*x166*x171))+(((100.0)*x172)));
j28eval[1]=((IKabs(((40.0)+(((-1.0)*x166*x169))+((pz*x167))+(((-400.0)*x166))+(((-400.0)*x168))+(((-1.0)*x168*x169))+(((32.1)*cj30)))))+(IKabs((((pz*x169))+(((400.0)*pz))+((x167*x168))+((x166*x167))+(((-32.1)*sj30))))));
j28eval[2]=IKsign(((-10.0)+(((-2000.0)*x166*x168))+x171+(((-1000.0)*x163))+(((-1000.0)*x164))+(((-1000.0)*x173))+(((200.0)*x166))+(((1000.0)*x172))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x174=py*py;
IkReal x175=cj27*cj27;
IkReal x176=(cj27*px);
IkReal x177=(py*sj27);
IkReal x178=((321.0)*cj30);
IkReal x179=((321.0)*sj30);
IkReal x180=((1000.0)*x175);
CheckValue<IkReal> x181=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*(pz*pz)))+((x174*x180))+(((-2000.0)*x176*x177))+(((-1000.0)*x174))+(((-1.0)*x180*(px*px)))+(((200.0)*x177))+(((200.0)*x176)))),-1);
if(!x181.valid){
continue;
}
CheckValue<IkReal> x182 = IKatan2WithCheck(IkReal((((pz*x178))+((x176*x179))+(((400.0)*pz))+(((-32.1)*sj30))+((x177*x179)))),((40.0)+((pz*x179))+(((-400.0)*x176))+(((-400.0)*x177))+(((-1.0)*x177*x178))+(((-1.0)*x176*x178))+(((32.1)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x182.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x181.value)))+(x182.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x183=IKsin(j28);
IkReal x184=IKcos(j28);
IkReal x185=((0.321)*cj30);
IkReal x186=((0.321)*sj30);
IkReal x187=(cj27*px);
IkReal x188=(py*sj27);
IkReal x189=((1.0)*x188);
IkReal x190=(pz*x183);
IkReal x191=((0.8)*x184);
evalcond[0]=((((0.4)*x183))+((x184*x186))+pz+((x183*x185)));
evalcond[1]=(((pz*x184))+x186+(((-0.1)*x183))+((x183*x187))+((x183*x188)));
evalcond[2]=((0.1)+(((0.4)*x184))+(((-1.0)*x189))+(((-1.0)*x187))+((x184*x185))+(((-1.0)*x183*x186)));
evalcond[3]=((0.4)+(((0.1)*x184))+(((-1.0)*x184*x187))+x190+x185+(((-1.0)*x184*x189)));
evalcond[4]=((-0.066959)+(((0.2)*x187))+(((0.2)*x188))+((x187*x191))+((x188*x191))+(((-1.0)*pp))+(((-0.08)*x184))+(((-0.8)*x190)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x603=((321.0)*cj30);
IkReal x604=(py*sj27);
IkReal x605=(cj27*px);
IkReal x606=((1000.0)*pz);
CheckValue<IkReal> x607=IKPowWithIntegerCheck(IKsign(((40.0)+(((-1.0)*x603*x604))+(((-1.0)*x603*x605))+(((-321.0)*pz*sj30))+(((-400.0)*x604))+(((-400.0)*x605))+(((32.1)*cj30)))),-1);
if(!x607.valid){
continue;
}
CheckValue<IkReal> x608 = IKatan2WithCheck(IkReal((((x605*x606))+(((-100.0)*pz))+((x604*x606))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))),((-160.0)+((pz*x606))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x608.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x607.value)))+(x608.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x609=IKsin(j28);
IkReal x610=IKcos(j28);
IkReal x611=((0.321)*cj30);
IkReal x612=((0.321)*sj30);
IkReal x613=(cj27*px);
IkReal x614=(py*sj27);
IkReal x615=((1.0)*x614);
IkReal x616=(pz*x609);
IkReal x617=((0.8)*x610);
evalcond[0]=((((0.4)*x609))+pz+((x609*x611))+((x610*x612)));
evalcond[1]=(((pz*x610))+x612+(((-0.1)*x609))+((x609*x613))+((x609*x614)));
evalcond[2]=((0.1)+(((-1.0)*x609*x612))+(((0.4)*x610))+(((-1.0)*x613))+(((-1.0)*x615))+((x610*x611)));
evalcond[3]=((0.4)+(((-1.0)*x610*x615))+(((0.1)*x610))+(((-1.0)*x610*x613))+x616+x611);
evalcond[4]=((-0.066959)+(((-0.08)*x610))+(((-0.8)*x616))+(((-1.0)*pp))+((x613*x617))+((x614*x617))+(((0.2)*x613))+(((0.2)*x614)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x618=((321000.0)*cj30);
IkReal x619=(py*sj27);
IkReal x620=(cj27*px);
IkReal x621=((321000.0)*sj30);
CheckValue<IkReal> x622=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj30)))),-1);
if(!x622.valid){
continue;
}
CheckValue<IkReal> x623 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*x620*x621))+(((-400000.0)*pz))+(((-1.0)*pz*x618))+(((-1.0)*x619*x621)))),((-40000.0)+(((-1.0)*pz*x621))+(((-32100.0)*cj30))+((x618*x620))+(((400000.0)*x619))+(((400000.0)*x620))+((x618*x619))),IKFAST_ATAN2_MAGTHRESH);
if(!x623.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x622.value)))+(x623.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x624=IKsin(j28);
IkReal x625=IKcos(j28);
IkReal x626=((0.321)*cj30);
IkReal x627=((0.321)*sj30);
IkReal x628=(cj27*px);
IkReal x629=(py*sj27);
IkReal x630=((1.0)*x629);
IkReal x631=(pz*x624);
IkReal x632=((0.8)*x625);
evalcond[0]=(((x625*x627))+pz+((x624*x626))+(((0.4)*x624)));
evalcond[1]=(((pz*x625))+(((-0.1)*x624))+x627+((x624*x628))+((x624*x629)));
evalcond[2]=((0.1)+((x625*x626))+(((-1.0)*x630))+(((-1.0)*x624*x627))+(((-1.0)*x628))+(((0.4)*x625)));
evalcond[3]=((0.4)+x626+x631+(((-1.0)*x625*x630))+(((0.1)*x625))+(((-1.0)*x625*x628)));
evalcond[4]=((-0.066959)+(((0.2)*x629))+(((0.2)*x628))+((x628*x632))+(((-0.08)*x625))+((x629*x632))+(((-1.0)*pp))+(((-0.8)*x631)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x633=(px*sj27);
IkReal x634=(cj27*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=(x633+(((-1.0)*x634)));
evalcond[2]=(x634+(((-1.0)*x633)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x635=((321000.0)*cj30);
IkReal x636=(py*sj27);
IkReal x637=((321000.0)*sj30);
IkReal x638=(cj27*px);
j28eval[0]=((-1.02430295950156)+(((-1.0)*cj30)));
j28eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj30))));
j28eval[2]=((IKabs(((40000.0)+(((-1.0)*pz*x637))+(((-400000.0)*x638))+(((-400000.0)*x636))+(((-1.0)*x635*x636))+(((-1.0)*x635*x638))+(((32100.0)*cj30)))))+(IKabs((((pz*x635))+(((-1.0)*x637*x638))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-1.0)*x636*x637))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x639=(pz*sj30);
IkReal x640=(cj27*px);
IkReal x641=(py*sj27);
IkReal x642=((10.0)*cj30);
IkReal x643=((1000.0)*pz);
IkReal x644=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+(((12.4610591900312)*x640))+(((12.4610591900312)*x641))+((x640*x642))+(((-1.0)*cj30))+((x641*x642))+(((-10.0)*x639)));
j28eval[1]=((IKabs(((((100.0)*pz))+(((-1.0)*x640*x643))+(((-1.0)*x641*x643))+(((128.4)*sj30))+(((103.041)*cj30*sj30)))))+(IKabs(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x643))))));
j28eval[2]=IKsign(((-40.0)+(((400.0)*x640))+(((400.0)*x641))+((x640*x644))+((x641*x644))+(((-321.0)*x639))+(((-32.1)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x645=cj27*cj27;
IkReal x646=py*py;
IkReal x647=pz*pz;
IkReal x648=px*px;
IkReal x649=(cj27*px);
IkReal x650=((321.0)*sj30);
IkReal x651=(py*sj27);
IkReal x652=((321.0)*cj30);
IkReal x653=((321.0)*x651);
IkReal x654=((200.0)*x651);
IkReal x655=(x645*x646);
IkReal x656=(x645*x648);
j28eval[0]=((-1.0)+(((100.0)*x655))+(((20.0)*x651))+(((20.0)*x649))+(((-100.0)*x656))+(((-100.0)*x646))+(((-100.0)*x647))+(((-1.0)*x649*x654)));
j28eval[1]=((IKabs((((pz*x652))+(((400.0)*pz))+(((32.1)*sj30))+(((-1.0)*x650*x651))+(((-1.0)*x649*x650)))))+(IKabs(((40.0)+(((-1.0)*x651*x652))+(((-400.0)*x649))+(((-1.0)*pz*x650))+(((-1.0)*x649*x652))+(((-400.0)*x651))+(((32.1)*cj30))))));
j28eval[2]=IKsign(((-10.0)+(((-2000.0)*x649*x651))+(((-1000.0)*x646))+(((-1000.0)*x647))+(((-1000.0)*x656))+x654+(((200.0)*x649))+(((1000.0)*x655))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x657=py*py;
IkReal x658=cj27*cj27;
IkReal x659=(cj27*px);
IkReal x660=(py*sj27);
IkReal x661=((321.0)*cj30);
IkReal x662=((321.0)*sj30);
IkReal x663=((1000.0)*x658);
CheckValue<IkReal> x664 = IKatan2WithCheck(IkReal(((((-1.0)*x659*x662))+(((-1.0)*x660*x662))+(((400.0)*pz))+(((32.1)*sj30))+((pz*x661)))),((40.0)+(((-1.0)*x659*x661))+(((-1.0)*x660*x661))+(((-1.0)*pz*x662))+(((-400.0)*x659))+(((32.1)*cj30))+(((-400.0)*x660))),IKFAST_ATAN2_MAGTHRESH);
if(!x664.valid){
continue;
}
CheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign(((-10.0)+(((200.0)*x660))+(((-1000.0)*(pz*pz)))+(((-1.0)*x663*(px*px)))+((x657*x663))+(((-1000.0)*x657))+(((-2000.0)*x659*x660))+(((200.0)*x659)))),-1);
if(!x665.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x664.value)+(((1.5707963267949)*(x665.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x666=IKsin(j28);
IkReal x667=IKcos(j28);
IkReal x668=((0.321)*cj30);
IkReal x669=((0.321)*sj30);
IkReal x670=(py*sj27);
IkReal x671=(cj27*px);
IkReal x672=((1.0)*x670);
IkReal x673=(pz*x666);
IkReal x674=((1.0)*x667);
IkReal x675=((0.8)*x667);
evalcond[0]=(((x666*x668))+(((0.4)*x666))+pz+(((-1.0)*x667*x669)));
evalcond[1]=((0.1)+((x666*x669))+((x667*x668))+(((0.4)*x667))+(((-1.0)*x671))+(((-1.0)*x672)));
evalcond[2]=((0.4)+(((0.1)*x667))+(((-1.0)*x667*x672))+x668+x673+(((-1.0)*x671*x674)));
evalcond[3]=((((0.1)*x666))+(((-1.0)*pz*x674))+(((-1.0)*x666*x672))+(((-1.0)*x666*x671))+x669);
evalcond[4]=((-0.066959)+(((-0.08)*x667))+((x671*x675))+(((0.2)*x671))+(((0.2)*x670))+((x670*x675))+(((-1.0)*pp))+(((-0.8)*x673)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x676=((321.0)*cj30);
IkReal x677=(py*sj27);
IkReal x678=(cj27*px);
IkReal x679=((1000.0)*pz);
CheckValue<IkReal> x680 = IKatan2WithCheck(IkReal(((((-1.0)*x678*x679))+(((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x677*x679))+(((103.041)*cj30*sj30)))),((160.0)+(((-1.0)*pz*x679))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x680.valid){
continue;
}
CheckValue<IkReal> x681=IKPowWithIntegerCheck(IKsign(((-40.0)+(((-321.0)*pz*sj30))+((x676*x678))+((x676*x677))+(((400.0)*x678))+(((400.0)*x677))+(((-32.1)*cj30)))),-1);
if(!x681.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x680.value)+(((1.5707963267949)*(x681.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x682=IKsin(j28);
IkReal x683=IKcos(j28);
IkReal x684=((0.321)*cj30);
IkReal x685=((0.321)*sj30);
IkReal x686=(py*sj27);
IkReal x687=(cj27*px);
IkReal x688=((1.0)*x686);
IkReal x689=(pz*x682);
IkReal x690=((1.0)*x683);
IkReal x691=((0.8)*x683);
evalcond[0]=(((x682*x684))+pz+(((0.4)*x682))+(((-1.0)*x683*x685)));
evalcond[1]=((0.1)+(((-1.0)*x688))+((x682*x685))+((x683*x684))+(((0.4)*x683))+(((-1.0)*x687)));
evalcond[2]=((0.4)+(((-1.0)*x687*x690))+x689+x684+(((-1.0)*x683*x688))+(((0.1)*x683)));
evalcond[3]=((((-1.0)*pz*x690))+x685+(((-1.0)*x682*x688))+(((0.1)*x682))+(((-1.0)*x682*x687)));
evalcond[4]=((-0.066959)+((x687*x691))+((x686*x691))+(((0.2)*x686))+(((0.2)*x687))+(((-0.08)*x683))+(((-1.0)*pp))+(((-0.8)*x689)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x692=(cj27*px);
IkReal x693=((321000.0)*cj30);
IkReal x694=((321000.0)*sj30);
IkReal x695=((321000.0)*py*sj27);
CheckValue<IkReal> x696=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj30)))),-1);
if(!x696.valid){
continue;
}
CheckValue<IkReal> x697 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+((pz*x693))+(((400000.0)*pz))+(((-1.0)*py*sj27*x694))+(((-1.0)*x692*x694)))),((40000.0)+(((-400000.0)*py*sj27))+(((-1.0)*py*sj27*x693))+(((-1.0)*x692*x693))+(((-1.0)*pz*x694))+(((32100.0)*cj30))+(((-400000.0)*x692))),IKFAST_ATAN2_MAGTHRESH);
if(!x697.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x696.value)))+(x697.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x698=IKsin(j28);
IkReal x699=IKcos(j28);
IkReal x700=((0.321)*cj30);
IkReal x701=((0.321)*sj30);
IkReal x702=(py*sj27);
IkReal x703=(cj27*px);
IkReal x704=((1.0)*x702);
IkReal x705=(pz*x698);
IkReal x706=((1.0)*x699);
IkReal x707=((0.8)*x699);
evalcond[0]=((((0.4)*x698))+pz+(((-1.0)*x699*x701))+((x698*x700)));
evalcond[1]=((0.1)+(((-1.0)*x703))+(((0.4)*x699))+(((-1.0)*x704))+((x698*x701))+((x699*x700)));
evalcond[2]=((0.4)+(((-1.0)*x703*x706))+(((0.1)*x699))+(((-1.0)*x699*x704))+x700+x705);
evalcond[3]=((((-1.0)*pz*x706))+(((0.1)*x698))+x701+(((-1.0)*x698*x704))+(((-1.0)*x698*x703)));
evalcond[4]=((-0.066959)+((x702*x707))+((x703*x707))+(((-0.8)*x705))+(((-1.0)*pp))+(((-0.08)*x699))+(((0.2)*x702))+(((0.2)*x703)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28, j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x708=IKPowWithIntegerCheck(sj29,-1);
if(!x708.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x708.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x708.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x708.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));
evalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j28eval[3];
IkReal x709=(py*sj27);
IkReal x710=(cj29*sj30);
IkReal x711=(cj27*px);
IkReal x712=((10.0)*cj30);
IkReal x713=((1000.0)*pz);
IkReal x714=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+(((12.4610591900312)*x709))+(((12.4610591900312)*x711))+((x711*x712))+((x709*x712))+(((-1.0)*cj30))+(((10.0)*pz*x710)));
j28eval[1]=IKsign(((-40.0)+(((400.0)*x709))+(((400.0)*x711))+((x711*x714))+((x709*x714))+(((321.0)*pz*x710))+(((-32.1)*cj30))));
j28eval[2]=((IKabs(((160.0)+(((-1.0)*pz*x713))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))))+(IKabs(((((-128.4)*x710))+(((-1.0)*x711*x713))+(((100.0)*pz))+(((-1.0)*x709*x713))+(((-103.041)*cj30*x710))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
IkReal x715=cj29*cj29;
IkReal x716=cj30*cj30;
IkReal x717=(cj27*px);
IkReal x718=((321000.0)*cj30);
IkReal x719=(py*sj27);
IkReal x720=((321000.0)*cj29*sj30);
IkReal x721=((103041.0)*x716);
j28eval[0]=((1.5527799613746)+(((-1.0)*x715*x716))+x715+x716+(((2.49221183800623)*cj30)));
j28eval[1]=IKsign(((160000.0)+(((256800.0)*cj30))+x721+(((-1.0)*x715*x721))+(((103041.0)*x715))));
j28eval[2]=((IKabs(((((-1.0)*pz*x718))+(((32100.0)*cj29*sj30))+(((-1.0)*x717*x720))+(((-400000.0)*pz))+(((-1.0)*x719*x720)))))+(IKabs(((-40000.0)+(((-32100.0)*cj30))+(((400000.0)*x717))+(((400000.0)*x719))+((x717*x718))+((x718*x719))+(((-1.0)*pz*x720))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[2];
IkReal x722=(cj29*sj30);
IkReal x723=(py*sj27);
IkReal x724=(cj30*pz);
IkReal x725=(cj27*px);
j28eval[0]=((((-10.0)*x722*x725))+(((-10.0)*x722*x723))+(((10.0)*x724))+x722+(((12.4610591900312)*pz)));
j28eval[1]=IKsign(((((321.0)*x724))+(((400.0)*pz))+(((-321.0)*x722*x723))+(((-321.0)*x722*x725))+(((32.1)*x722))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x726=((((0.321)*sj30))+(((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=x726;
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x726;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x727=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x727);
rxp0_1=(px*r20);
rxp1_0=(r21*x727);
rxp1_1=(px*r21);
rxp2_0=(r22*x727);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x728=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x728);
rxp0_1=(px*r20);
rxp1_0=(r21*x728);
rxp1_1=(px*r21);
rxp2_0=(r22*x728);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x729=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x729) < -0.00001)
continue;
IkReal x730=IKabs(IKsqrt(x729));
IkReal x736 = x729;
if(IKabs(x736)==0){
continue;
}
IkReal x731=pow(x736,-0.5);
CheckValue<IkReal> x737=IKPowWithIntegerCheck(x730,-1);
if(!x737.valid){
continue;
}
IkReal x732=x737.value;
IkReal x733=((10.0)*px*x731);
IkReal x734=((10.0)*py*x731);
if((((1.0)+(((-1.0)*(x732*x732))))) < -0.00001)
continue;
IkReal x735=IKsqrt(((1.0)+(((-1.0)*(x732*x732)))));
if( (x732) < -1-IKFAST_SINCOS_THRESH || (x732) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
IkReal gconst24=((((-1.0)*(IKasin(x732))))+(((-1.0)*(x738.value))));
IkReal gconst25=(((x733*x735))+((x732*x734)));
IkReal gconst26=((((-1.0)*x734*x735))+((x732*x733)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x739=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x739.valid){
continue;
}
if( (x739.value) < -1-IKFAST_SINCOS_THRESH || (x739.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x740 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x740.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x739.value))+j27+(x740.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x742=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);
if(!x742.valid){
continue;
}
IkReal x741=x742.value;
cj28array[0]=((((-0.4)*x741))+(((-0.321)*cj30*x741)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x743=IKsin(j28);
IkReal x744=IKcos(j28);
IkReal x745=(gconst25*py);
IkReal x746=(gconst26*px);
IkReal x747=((0.321)*cj30);
IkReal x748=((1.0)*x743);
IkReal x749=((0.8)*x744);
evalcond[0]=(((x743*x747))+(((0.4)*x743)));
evalcond[1]=((((-1.0)*x745*x748))+(((-1.0)*x746*x748))+(((0.1)*x743)));
evalcond[2]=((0.1)+((x744*x747))+(((-1.0)*x745))+(((-1.0)*x746))+(((0.4)*x744)));
evalcond[3]=((-0.32)+((x745*x749))+(((-0.08)*x744))+((x746*x749))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x750=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x757 = x750;
if(IKabs(x757)==0){
continue;
}
IkReal x751=pow(x757,-0.5);
if((x750) < -0.00001)
continue;
IkReal x752=IKabs(IKsqrt(x750));
CheckValue<IkReal> x758=IKPowWithIntegerCheck(x752,-1);
if(!x758.valid){
continue;
}
IkReal x753=x758.value;
IkReal x754=((10.0)*px*x751);
IkReal x755=((10.0)*py*x751);
if((((1.0)+(((-1.0)*(x753*x753))))) < -0.00001)
continue;
IkReal x756=IKsqrt(((1.0)+(((-1.0)*(x753*x753)))));
if( (x753) < -1-IKFAST_SINCOS_THRESH || (x753) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x759 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x759.valid){
continue;
}
IkReal gconst27=((3.14159265358979)+(IKasin(x753))+(((-1.0)*(x759.value))));
IkReal gconst28=((((-1.0)*x754*x756))+((x753*x755)));
IkReal gconst29=(((x755*x756))+((x753*x754)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x760=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x760.valid){
continue;
}
if( (x760.value) < -1-IKFAST_SINCOS_THRESH || (x760.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x761 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x761.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x760.value))))+j27+(x761.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x763=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);
if(!x763.valid){
continue;
}
IkReal x762=x763.value;
cj28array[0]=((((-0.321)*cj30*x762))+(((-0.4)*x762)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x764=IKsin(j28);
IkReal x765=IKcos(j28);
IkReal x766=(gconst28*py);
IkReal x767=((0.321)*cj30);
IkReal x768=((0.8)*x765);
IkReal x769=((1.0)*gconst29*px);
evalcond[0]=(((x764*x767))+(((0.4)*x764)));
evalcond[1]=((((0.1)*x764))+(((-1.0)*x764*x769))+(((-1.0)*x764*x766)));
evalcond[2]=((0.1)+(((-1.0)*x769))+(((-1.0)*x766))+((x765*x767))+(((0.4)*x765)));
evalcond[3]=((-0.32)+(((-0.08)*x765))+(((-0.2568)*cj30))+((gconst29*px*x768))+((x766*x768)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x771=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x771.valid){
continue;
}
IkReal x770=x771.value;
cj28array[0]=(((cj27*px*x770))+(((-0.1)*x770))+((py*sj27*x770)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x772=IKsin(j28);
IkReal x773=IKcos(j28);
IkReal x774=((0.321)*cj30);
IkReal x775=(cj27*px);
IkReal x776=((1.0)*x772);
IkReal x777=(py*sj27*x773);
evalcond[0]=(((x772*x774))+(((0.4)*x772)));
evalcond[1]=((((-1.0)*py*sj27*x776))+(((0.1)*x772))+(((-1.0)*x775*x776)));
evalcond[2]=((0.4)+(((0.1)*x773))+x774+(((-1.0)*x777))+(((-1.0)*x773*x775)));
evalcond[3]=((-0.32)+(((0.8)*x773*x775))+(((0.8)*x777))+(((-0.08)*x773))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x779=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x779.valid){
continue;
}
IkReal x778=x779.value;
cj28array[0]=((((-0.4)*x778))+(((-0.321)*cj30*x778)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x780=IKsin(j28);
IkReal x781=IKcos(j28);
IkReal x782=(py*sj27);
IkReal x783=(cj27*px);
IkReal x784=((0.321)*cj30);
IkReal x785=((0.8)*x781);
IkReal x786=((1.0)*x780);
evalcond[0]=(((x780*x784))+(((0.4)*x780)));
evalcond[1]=((((0.1)*x780))+(((-1.0)*x782*x786))+(((-1.0)*x783*x786)));
evalcond[2]=((0.1)+((x781*x784))+(((-1.0)*x782))+(((-1.0)*x783))+(((0.4)*x781)));
evalcond[3]=((-0.32)+((x782*x785))+((x783*x785))+(((-0.08)*x781))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x787=((0.321)*sj30);
IkReal x788=(cj27*py);
IkReal x789=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*x787))+x789+(((-1.0)*x788)));
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=(x787+x788+(((-1.0)*x789)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x790=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x790);
rxp0_1=(px*r20);
rxp1_0=(r21*x790);
rxp1_1=(px*r21);
rxp2_0=(r22*x790);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x791=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x791);
rxp0_1=(px*r20);
rxp1_0=(r21*x791);
rxp1_1=(px*r21);
rxp2_0=(r22*x791);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x792=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x792) < -0.00001)
continue;
IkReal x793=IKabs(IKsqrt(x792));
IkReal x799 = x792;
if(IKabs(x799)==0){
continue;
}
IkReal x794=pow(x799,-0.5);
CheckValue<IkReal> x800=IKPowWithIntegerCheck(x793,-1);
if(!x800.valid){
continue;
}
IkReal x795=x800.value;
IkReal x796=((10.0)*px*x794);
IkReal x797=((10.0)*py*x794);
if((((1.0)+(((-1.0)*(x795*x795))))) < -0.00001)
continue;
IkReal x798=IKsqrt(((1.0)+(((-1.0)*(x795*x795)))));
if( (x795) < -1-IKFAST_SINCOS_THRESH || (x795) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x801 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x801.valid){
continue;
}
IkReal gconst30=((((-1.0)*(IKasin(x795))))+(((-1.0)*(x801.value))));
IkReal gconst31=(((x796*x798))+((x795*x797)));
IkReal gconst32=((((-1.0)*x797*x798))+((x795*x796)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x802=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x802.valid){
continue;
}
if( (x802.value) < -1-IKFAST_SINCOS_THRESH || (x802.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x803 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x803.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x802.value))+j27+(x803.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x805=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);
if(!x805.valid){
continue;
}
IkReal x804=x805.value;
cj28array[0]=((((-0.4)*x804))+(((-0.321)*cj30*x804)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x806=IKsin(j28);
IkReal x807=IKcos(j28);
IkReal x808=(gconst31*py);
IkReal x809=(gconst32*px);
IkReal x810=((0.321)*cj30);
IkReal x811=((0.8)*x807);
evalcond[0]=(((x806*x810))+(((0.4)*x806)));
evalcond[1]=(((x806*x808))+((x806*x809))+(((-0.1)*x806)));
evalcond[2]=((0.1)+(((-1.0)*x808))+(((-1.0)*x809))+((x807*x810))+(((0.4)*x807)));
evalcond[3]=((-0.32)+((x809*x811))+((x808*x811))+(((-0.08)*x807))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x812=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x819 = x812;
if(IKabs(x819)==0){
continue;
}
IkReal x813=pow(x819,-0.5);
if((x812) < -0.00001)
continue;
IkReal x814=IKabs(IKsqrt(x812));
CheckValue<IkReal> x820=IKPowWithIntegerCheck(x814,-1);
if(!x820.valid){
continue;
}
IkReal x815=x820.value;
IkReal x816=((10.0)*px*x813);
IkReal x817=((10.0)*py*x813);
if((((1.0)+(((-1.0)*(x815*x815))))) < -0.00001)
continue;
IkReal x818=IKsqrt(((1.0)+(((-1.0)*(x815*x815)))));
if( (x815) < -1-IKFAST_SINCOS_THRESH || (x815) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x821 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x821.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(IKasin(x815))+(((-1.0)*(x821.value))));
IkReal gconst34=(((x815*x817))+(((-1.0)*x816*x818)));
IkReal gconst35=(((x815*x816))+((x817*x818)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x822=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x822.valid){
continue;
}
if( (x822.value) < -1-IKFAST_SINCOS_THRESH || (x822.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x823 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x823.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x822.value))))+j27+(x823.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x825=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);
if(!x825.valid){
continue;
}
IkReal x824=x825.value;
cj28array[0]=((((-0.4)*x824))+(((-0.321)*cj30*x824)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x826=IKsin(j28);
IkReal x827=IKcos(j28);
IkReal x828=(gconst34*py);
IkReal x829=(gconst35*px);
IkReal x830=((0.321)*cj30);
IkReal x831=((0.8)*x827);
evalcond[0]=((((0.4)*x826))+((x826*x830)));
evalcond[1]=((((-0.1)*x826))+((x826*x829))+((x826*x828)));
evalcond[2]=((0.1)+((x827*x830))+(((0.4)*x827))+(((-1.0)*x828))+(((-1.0)*x829)));
evalcond[3]=((-0.32)+(((-0.08)*x827))+((x829*x831))+(((-0.2568)*cj30))+((x828*x831)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x833=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x833.valid){
continue;
}
IkReal x832=x833.value;
cj28array[0]=(((cj27*px*x832))+(((-0.1)*x832))+((py*sj27*x832)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x834=IKsin(j28);
IkReal x835=IKcos(j28);
IkReal x836=((0.321)*cj30);
IkReal x837=(py*sj27*x835);
IkReal x838=(cj27*px*x835);
evalcond[0]=((((0.4)*x834))+((x834*x836)));
evalcond[1]=(((cj27*px*x834))+(((-0.1)*x834))+((py*sj27*x834)));
evalcond[2]=((0.4)+(((-1.0)*x837))+(((-1.0)*x838))+(((0.1)*x835))+x836);
evalcond[3]=((-0.32)+(((0.8)*x837))+(((0.8)*x838))+(((-0.08)*x835))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x840=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x840.valid){
continue;
}
IkReal x839=x840.value;
cj28array[0]=((((-0.4)*x839))+(((-0.321)*cj30*x839)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x841=IKsin(j28);
IkReal x842=IKcos(j28);
IkReal x843=(py*sj27);
IkReal x844=(cj27*px);
IkReal x845=((0.321)*cj30);
IkReal x846=((0.8)*x842);
evalcond[0]=((((0.4)*x841))+((x841*x845)));
evalcond[1]=((((-0.1)*x841))+((x841*x844))+((x841*x843)));
evalcond[2]=((0.1)+(((0.4)*x842))+((x842*x845))+(((-1.0)*x844))+(((-1.0)*x843)));
evalcond[3]=((-0.32)+(((-0.08)*x842))+((x843*x846))+(((-0.2568)*cj30))+((x844*x846)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x847=IKcos(j28);
IkReal x848=px*px;
CheckValue<IkReal> x857=IKPowWithIntegerCheck(py,-1);
if(!x857.valid){
continue;
}
IkReal x849=x857.value;
IkReal x850=IKsin(j28);
IkReal x851=(py*sj27);
IkReal x852=(x848*x849);
IkReal x853=((1.0)*x847);
IkReal x854=(sj29*x850);
IkReal x855=(cj29*x850);
IkReal x856=((0.8)*sj27*x847);
evalcond[0]=((0.721)*x850);
evalcond[1]=((0.721)+(((-1.0)*cj27*px*x853))+(((0.1)*x847))+(((-1.0)*x851*x853)));
evalcond[2]=((-0.5768)+(((-0.08)*x847))+((x852*x856))+(((0.8)*x847*x851)));
evalcond[3]=(((sj27*x852*x855))+(((-0.1)*x855))+((x851*x855)));
evalcond[4]=((((0.1)*x854))+(((-1.0)*x851*x854))+(((-1.0)*sj27*x852*x854)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x858=IKcos(j28);
IkReal x859=px*px;
CheckValue<IkReal> x868=IKPowWithIntegerCheck(py,-1);
if(!x868.valid){
continue;
}
IkReal x860=x868.value;
IkReal x861=IKsin(j28);
IkReal x862=(py*sj27);
IkReal x863=(x859*x860);
IkReal x864=((1.0)*x858);
IkReal x865=(sj29*x861);
IkReal x866=(cj29*x861);
IkReal x867=((0.8)*sj27*x858);
evalcond[0]=((0.079)*x861);
evalcond[1]=((0.079)+(((0.1)*x858))+(((-1.0)*cj27*px*x864))+(((-1.0)*x862*x864)));
evalcond[2]=((-0.0632)+(((0.8)*x858*x862))+((x863*x867))+(((-0.08)*x858)));
evalcond[3]=((((-0.1)*x866))+((x862*x866))+((sj27*x863*x866)));
evalcond[4]=((((-1.0)*sj27*x863*x865))+(((0.1)*x865))+(((-1.0)*x862*x865)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x869=cj27*cj27;
IkReal x870=py*py;
IkReal x871=(cj27*px);
IkReal x872=(cj29*sj30);
IkReal x873=(py*sj27);
IkReal x874=((1000.0)*pz);
IkReal x875=((1000.0)*x869);
CheckValue<IkReal> x876=IKPowWithIntegerCheck(IKsign(((((321.0)*cj30*pz))+(((32.1)*x872))+(((400.0)*pz))+(((-321.0)*x872*x873))+(((-321.0)*x871*x872)))),-1);
if(!x876.valid){
continue;
}
CheckValue<IkReal> x877 = IKatan2WithCheck(IkReal(((-150.0)+((x875*(px*px)))+(((-1.0)*x870*x875))+(((-200.0)*x873))+(((-200.0)*x871))+(((-103.041)*(cj30*cj30)))+(((2000.0)*x871*x873))+(((-256.8)*cj30))+(((1000.0)*x870)))),((((-100.0)*pz))+((x871*x874))+(((-103.041)*cj30*x872))+((x873*x874))+(((-128.4)*x872))),IKFAST_ATAN2_MAGTHRESH);
if(!x877.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x876.value)))+(x877.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x878=IKsin(j28);
IkReal x879=IKcos(j28);
IkReal x880=((0.321)*cj30);
IkReal x881=(py*sj27);
IkReal x882=((0.321)*sj30);
IkReal x883=((1.0)*sj29);
IkReal x884=(px*sj27);
IkReal x885=(cj27*px);
IkReal x886=(cj27*py);
IkReal x887=((1.0)*x881);
IkReal x888=(pz*x878);
IkReal x889=(cj29*x878);
IkReal x890=(pz*x879);
IkReal x891=((0.8)*x879);
IkReal x892=(sj29*x878);
evalcond[0]=(((cj29*x879*x882))+((x878*x880))+pz+(((0.4)*x878)));
evalcond[1]=((0.1)+((x879*x880))+(((-1.0)*x882*x889))+(((-1.0)*x885))+(((-1.0)*x887))+(((0.4)*x879)));
evalcond[2]=((0.4)+(((-1.0)*x879*x887))+(((-1.0)*x879*x885))+(((0.1)*x879))+x880+x888);
evalcond[3]=((-0.066959)+((x881*x891))+(((-0.8)*x888))+(((-1.0)*pp))+(((-0.08)*x879))+(((0.2)*x881))+(((0.2)*x885))+((x885*x891)));
evalcond[4]=((((-1.0)*x883*x890))+((cj29*x884))+(((-1.0)*x878*x881*x883))+(((0.1)*x892))+(((-1.0)*cj29*x886))+(((-1.0)*x878*x883*x885)));
evalcond[5]=((((-1.0)*x883*x886))+((x881*x889))+((sj29*x884))+((cj29*x890))+x882+((x885*x889))+(((-0.1)*x889)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x893=cj29*cj29;
IkReal x894=cj30*cj30;
IkReal x895=(cj27*px);
IkReal x896=((321000.0)*cj30);
IkReal x897=(py*sj27);
IkReal x898=((321000.0)*cj29*sj30);
IkReal x899=((103041.0)*x893);
CheckValue<IkReal> x900 = IKatan2WithCheck(IkReal(((((32100.0)*cj29*sj30))+(((-1.0)*x895*x898))+(((-1.0)*pz*x896))+(((-400000.0)*pz))+(((-1.0)*x897*x898)))),((-40000.0)+(((-32100.0)*cj30))+((x896*x897))+((x895*x896))+(((-1.0)*pz*x898))+(((400000.0)*x895))+(((400000.0)*x897))),IKFAST_ATAN2_MAGTHRESH);
if(!x900.valid){
continue;
}
CheckValue<IkReal> x901=IKPowWithIntegerCheck(IKsign(((160000.0)+(((256800.0)*cj30))+(((-1.0)*x894*x899))+x899+(((103041.0)*x894)))),-1);
if(!x901.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x900.value)+(((1.5707963267949)*(x901.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x902=IKsin(j28);
IkReal x903=IKcos(j28);
IkReal x904=((0.321)*cj30);
IkReal x905=(py*sj27);
IkReal x906=((0.321)*sj30);
IkReal x907=((1.0)*sj29);
IkReal x908=(px*sj27);
IkReal x909=(cj27*px);
IkReal x910=(cj27*py);
IkReal x911=((1.0)*x905);
IkReal x912=(pz*x902);
IkReal x913=(cj29*x902);
IkReal x914=(pz*x903);
IkReal x915=((0.8)*x903);
IkReal x916=(sj29*x902);
evalcond[0]=(((x902*x904))+(((0.4)*x902))+pz+((cj29*x903*x906)));
evalcond[1]=((0.1)+(((-1.0)*x906*x913))+((x903*x904))+(((-1.0)*x911))+(((0.4)*x903))+(((-1.0)*x909)));
evalcond[2]=((0.4)+(((-1.0)*x903*x909))+x912+x904+(((0.1)*x903))+(((-1.0)*x903*x911)));
evalcond[3]=((-0.066959)+((x909*x915))+(((0.2)*x905))+(((0.2)*x909))+(((-0.08)*x903))+(((-1.0)*pp))+(((-0.8)*x912))+((x905*x915)));
evalcond[4]=(((cj29*x908))+(((-1.0)*x902*x907*x909))+(((-1.0)*x902*x905*x907))+(((0.1)*x916))+(((-1.0)*x907*x914))+(((-1.0)*cj29*x910)));
evalcond[5]=(((cj29*x914))+((x909*x913))+((sj29*x908))+(((-0.1)*x913))+(((-1.0)*x907*x910))+((x905*x913))+x906);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x917=(py*sj27);
IkReal x918=(cj29*sj30);
IkReal x919=((321.0)*cj30);
IkReal x920=(cj27*px);
IkReal x921=((1000.0)*pz);
CheckValue<IkReal> x922=IKPowWithIntegerCheck(IKsign(((-40.0)+((x917*x919))+((x919*x920))+(((400.0)*x920))+(((321.0)*pz*x918))+(((400.0)*x917))+(((-32.1)*cj30)))),-1);
if(!x922.valid){
continue;
}
CheckValue<IkReal> x923 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((-103.041)*cj30*x918))+(((-128.4)*x918))+(((-1.0)*x920*x921))+(((-1.0)*x917*x921)))),((160.0)+(((-1.0)*pz*x921))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x923.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x922.value)))+(x923.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x924=IKsin(j28);
IkReal x925=IKcos(j28);
IkReal x926=((0.321)*cj30);
IkReal x927=(py*sj27);
IkReal x928=((0.321)*sj30);
IkReal x929=((1.0)*sj29);
IkReal x930=(px*sj27);
IkReal x931=(cj27*px);
IkReal x932=(cj27*py);
IkReal x933=((1.0)*x927);
IkReal x934=(pz*x924);
IkReal x935=(cj29*x924);
IkReal x936=(pz*x925);
IkReal x937=((0.8)*x925);
IkReal x938=(sj29*x924);
evalcond[0]=(((x924*x926))+((cj29*x925*x928))+pz+(((0.4)*x924)));
evalcond[1]=((0.1)+(((-1.0)*x928*x935))+(((-1.0)*x931))+(((0.4)*x925))+((x925*x926))+(((-1.0)*x933)));
evalcond[2]=((0.4)+(((0.1)*x925))+(((-1.0)*x925*x931))+(((-1.0)*x925*x933))+x934+x926);
evalcond[3]=((-0.066959)+(((-0.08)*x925))+((x927*x937))+(((0.2)*x931))+(((0.2)*x927))+(((-0.8)*x934))+(((-1.0)*pp))+((x931*x937)));
evalcond[4]=((((-1.0)*x924*x929*x931))+(((0.1)*x938))+(((-1.0)*x924*x927*x929))+(((-1.0)*x929*x936))+((cj29*x930))+(((-1.0)*cj29*x932)));
evalcond[5]=((((-0.1)*x935))+((x927*x935))+((x931*x935))+(((-1.0)*x929*x932))+((cj29*x936))+((sj29*x930))+x928);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x939=cj27*cj27;
IkReal x940=px*px;
IkReal x941=py*py;
IkReal x942=((1.0)*pz);
IkReal x943=(cj27*px);
IkReal x944=((5.0)*pp);
IkReal x945=(cj29*py);
IkReal x946=((4.0)*cj27);
IkReal x947=(pz*sj29);
IkReal x948=(cj29*sj27);
IkReal x949=(py*sj27*sj29);
IkReal x950=((4.0)*cj29*px);
IkReal x951=(sj29*x939);
IkReal x952=((4.0)*x941);
CheckValue<IkReal> x953=IKPowWithIntegerCheck(IKsign((((x951*x952))+(((-8.0)*x943*x949))+(((0.8)*x949))+(((-4.0)*pz*x947))+(((-1.0)*sj29*x952))+(((-4.0)*x940*x951))+(((0.8)*sj29*x943))+(((-0.04)*sj29)))),-1);
if(!x953.valid){
continue;
}
CheckValue<IkReal> x954 = IKatan2WithCheck(IkReal(((((-0.4)*cj27*x945))+(((-4.0)*px*x945))+((x941*x946*x948))+(((-1.0)*x942*x949))+(((0.4)*px*x948))+(((8.0)*px*x939*x945))+((x944*x947))+(((-1.0)*sj29*x942*x943))+(((0.334795)*x947))+(((-1.0)*x940*x946*x948)))),((((0.5)*pp*sj29))+((sj29*x941))+((x940*x951))+(((0.0334795)*sj29))+((pz*x945*x946))+(((-1.0)*x941*x951))+(((-1.0)*x944*x949))+(((-0.434795)*x949))+(((-1.0)*sj29*x943*x944))+(((2.0)*x943*x949))+(((-4.0)*px*pz*x948))+(((-0.434795)*sj29*x943))),IKFAST_ATAN2_MAGTHRESH);
if(!x954.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x953.value)))+(x954.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[2];
IkReal x955=IKcos(j28);
IkReal x956=IKsin(j28);
IkReal x957=(py*sj27);
IkReal x958=((1.0)*cj27);
IkReal x959=(cj27*px);
IkReal x960=((0.8)*x955);
IkReal x961=(sj29*x956);
evalcond[0]=((-0.066959)+(((-1.0)*pp))+((x957*x960))+(((0.2)*x959))+(((0.2)*x957))+((x959*x960))+(((-0.08)*x955))+(((-0.8)*pz*x956)));
evalcond[1]=(((cj29*px*sj27))+(((-1.0)*pz*sj29*x955))+(((0.1)*x961))+(((-1.0)*x957*x961))+(((-1.0)*cj29*py*x958))+(((-1.0)*px*x958*x961)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=cj28;
j30eval[1]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=sj29;
j30eval[1]=sj28;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x962=(cj27*px);
IkReal x963=((0.8)*cj28);
IkReal x964=(py*sj27);
IkReal x965=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x965;
evalcond[2]=((-0.066959)+((x962*x963))+(((-0.08)*cj28))+(((-1.0)*pp))+((x963*x964))+(((0.2)*x962))+(((0.2)*x964))+(((-0.8)*pz*sj28)));
evalcond[3]=x965;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x966=((3.11526479750779)*cj28);
IkReal x967=(py*sj27);
IkReal x968=((3.11526479750779)*sj28);
IkReal x969=(cj27*px);
if( IKabs(((((-1.0)*pz*x966))+(((-1.0)*x967*x968))+(((-1.0)*x968*x969))+(((0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x968))+(((-0.311526479750779)*cj28))+((x966*x967))+((x966*x969)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x966))+(((-1.0)*x967*x968))+(((-1.0)*x968*x969))+(((0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x968))+(((-0.311526479750779)*cj28))+((x966*x967))+((x966*x969))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-1.0)*pz*x966))+(((-1.0)*x967*x968))+(((-1.0)*x968*x969))+(((0.311526479750779)*sj28))), ((-1.24610591900312)+(((-1.0)*pz*x968))+(((-0.311526479750779)*cj28))+((x966*x967))+((x966*x969))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x970=IKcos(j30);
IkReal x971=IKsin(j30);
IkReal x972=(py*sj27);
IkReal x973=(cj27*px);
IkReal x974=((0.321)*x970);
IkReal x975=((0.321)*x971);
evalcond[0]=((((0.4)*sj28))+((sj28*x974))+pz+((cj28*x975)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x972))+(((0.2)*x973))+(((0.2568)*x970)));
evalcond[2]=(((sj28*x973))+((sj28*x972))+((cj28*pz))+(((-0.1)*sj28))+x975);
CheckValue<IkReal> x976=IKPowWithIntegerCheck(py,-1);
if(!x976.valid){
continue;
}
evalcond[3]=((0.31630125)+(((-1.25)*pp))+(((0.25)*x972))+x974+(((0.25)*sj27*(px*px)*(x976.value))));
evalcond[4]=((0.1)+(((-1.0)*x972))+(((-1.0)*x973))+(((-1.0)*sj28*x975))+(((0.4)*cj28))+((cj28*x974)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x977=(cj27*px);
IkReal x978=((0.8)*cj28);
IkReal x979=(cj27*py);
IkReal x980=(px*sj27);
IkReal x981=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*x979))+x980);
evalcond[2]=((-0.066959)+((x977*x978))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x977))+(((0.2)*x981))+(((-0.8)*pz*sj28))+((x978*x981)));
evalcond[3]=((((-1.0)*x980))+x979);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x982=((3.11526479750779)*cj28);
IkReal x983=(py*sj27);
IkReal x984=((3.11526479750779)*sj28);
IkReal x985=(cj27*px);
if( IKabs((((x983*x984))+(((-0.311526479750779)*sj28))+((pz*x982))+((x984*x985)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x984))+((x982*x985))+((x982*x983)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x983*x984))+(((-0.311526479750779)*sj28))+((pz*x982))+((x984*x985))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x984))+((x982*x985))+((x982*x983))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((((x983*x984))+(((-0.311526479750779)*sj28))+((pz*x982))+((x984*x985))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x984))+((x982*x985))+((x982*x983))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x986=IKcos(j30);
IkReal x987=IKsin(j30);
IkReal x988=(cj27*px);
IkReal x989=((1.0)*sj28);
IkReal x990=((0.25)*sj27);
IkReal x991=(py*sj27);
IkReal x992=((0.321)*x986);
IkReal x993=((0.321)*x987);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x993))+((sj28*x992))+pz);
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x988))+(((0.2568)*x986))+(((0.2)*x991)));
CheckValue<IkReal> x994=IKPowWithIntegerCheck(py,-1);
if(!x994.valid){
continue;
}
evalcond[2]=((0.31630125)+(((-1.25)*pp))+((py*x990))+x992+((x990*(px*px)*(x994.value))));
evalcond[3]=((((-1.0)*x988*x989))+(((0.1)*sj28))+(((-1.0)*x989*x991))+x993+(((-1.0)*cj28*pz)));
evalcond[4]=((0.1)+(((-1.0)*x991))+(((-1.0)*x988))+(((0.4)*cj28))+((cj28*x992))+((sj28*x993)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
evalcond[1]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-1.0)*pz*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x995=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x995)));
evalcond[2]=((0.353041)+(((-1.0)*pp))+(((0.321)*x995)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x996=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x996)));
evalcond[2]=((0.353041)+(((-1.0)*pp))+(((0.321)*x996)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x997=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x997)));
evalcond[1]=((0.353041)+(((-1.0)*pp))+(((0.321)*x997)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x998=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x998)));
evalcond[1]=((0.353041)+(((-1.0)*pp))+(((0.321)*x998)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x999=IKPowWithIntegerCheck(sj29,-1);
if(!x999.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x999.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x999.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x999.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1000=IKcos(j30);
IkReal x1001=IKsin(j30);
IkReal x1002=(px*sj27);
IkReal x1003=((1.0)*cj27*py);
IkReal x1004=((0.321)*x1001);
evalcond[0]=(((cj29*x1004))+pz);
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1000)));
evalcond[2]=((0.353041)+(((-1.0)*pp))+(((0.321)*x1000)));
evalcond[3]=(x1002+(((-1.0)*x1003))+((sj29*x1004)));
evalcond[4]=(x1004+((cj29*pz))+((sj29*x1002))+(((-1.0)*sj29*x1003)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1005=IKPowWithIntegerCheck(cj29,-1);
if(!x1005.valid){
continue;
}
if( IKabs(((-3.11526479750779)*pz*(x1005.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1005.value)))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz*(x1005.value)), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1006=IKcos(j30);
IkReal x1007=IKsin(j30);
IkReal x1008=(px*sj27);
IkReal x1009=((1.0)*cj27*py);
IkReal x1010=((0.321)*x1007);
evalcond[0]=(((cj29*x1010))+pz);
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1006)));
evalcond[2]=((0.353041)+(((-1.0)*pp))+(((0.321)*x1006)));
evalcond[3]=(x1008+(((-1.0)*x1009))+((sj29*x1010)));
evalcond[4]=(x1010+((cj29*pz))+((sj29*x1008))+(((-1.0)*sj29*x1009)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
evalcond[1]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((pz*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1011=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.257388)+(((0.2568)*x1011))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1011))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1012=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.257388)+(((0.2568)*x1012))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1012))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1013=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1013))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1013))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1014=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1014))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1014))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1015=IKPowWithIntegerCheck(sj29,-1);
if(!x1015.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1015.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1015.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1015.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1016=IKcos(j30);
IkReal x1017=IKsin(j30);
IkReal x1018=(px*sj27);
IkReal x1019=((1.0)*cj27*py);
IkReal x1020=((0.321)*x1017);
evalcond[0]=((((-1.0)*cj29*x1020))+pz);
evalcond[1]=((0.257388)+(((0.2568)*x1016))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1016))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1018+(((-1.0)*x1019))+((sj29*x1020)));
evalcond[4]=(x1020+(((-1.0)*sj29*x1019))+((sj29*x1018))+(((-1.0)*cj29*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1021=IKPowWithIntegerCheck(cj29,-1);
if(!x1021.valid){
continue;
}
if( IKabs(((3.11526479750779)*pz*(x1021.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1021.value)))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz*(x1021.value)), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1022=IKcos(j30);
IkReal x1023=IKsin(j30);
IkReal x1024=(px*sj27);
IkReal x1025=((1.0)*cj27*py);
IkReal x1026=((0.321)*x1023);
evalcond[0]=((((-1.0)*cj29*x1026))+pz);
evalcond[1]=((0.257388)+(((0.2568)*x1022))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((-1.66666666666667)*pp))+(((0.321)*x1022)));
evalcond[3]=(x1024+(((-1.0)*x1025))+((sj29*x1026)));
evalcond[4]=(x1026+(((-1.0)*sj29*x1025))+((sj29*x1024))+(((-1.0)*cj29*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1027=(cj27*px);
IkReal x1028=((1.0)*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1027))+(((0.2)*py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*sj29*x1027))+(((0.1)*sj29))+(((-1.0)*cj27*cj29*x1028))+(((-1.0)*sj27*sj29*x1028)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1029=IKcos(j30);
evalcond[0]=((0.4)+pz+(((0.321)*x1029)));
evalcond[1]=((0.32)+(((0.2568)*x1029))+(((0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1030=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1030))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1030)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1031=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1031))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1031)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1032=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1032))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1032)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1033=IKPowWithIntegerCheck(cj29,-1);
if(!x1033.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1033.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1033.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1033.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1034=IKcos(j30);
IkReal x1035=IKsin(j30);
IkReal x1036=((1.0)*py);
IkReal x1037=(cj27*px);
IkReal x1038=(px*sj27);
IkReal x1039=((0.321)*x1035);
evalcond[0]=((0.4)+(((0.321)*x1034))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1034)));
evalcond[2]=(x1038+(((-1.0)*cj27*x1036))+((sj29*x1039)));
evalcond[3]=((0.1)+(((-1.0)*x1037))+(((-1.0)*cj29*x1039))+(((-1.0)*sj27*x1036)));
evalcond[4]=(((cj29*py*sj27))+((cj29*x1037))+(((-1.0)*cj27*sj29*x1036))+x1039+((sj29*x1038))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1040=IKPowWithIntegerCheck(sj29,-1);
if(!x1040.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1040.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1040.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1040.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1041=IKcos(j30);
IkReal x1042=IKsin(j30);
IkReal x1043=((1.0)*py);
IkReal x1044=(cj27*px);
IkReal x1045=(px*sj27);
IkReal x1046=((0.321)*x1042);
evalcond[0]=((0.4)+(((0.321)*x1041))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1041)));
evalcond[2]=(((sj29*x1046))+x1045+(((-1.0)*cj27*x1043)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1043))+(((-1.0)*x1044))+(((-1.0)*cj29*x1046)));
evalcond[4]=(((cj29*py*sj27))+((sj29*x1045))+x1046+((cj29*x1044))+(((-0.1)*cj29))+(((-1.0)*cj27*sj29*x1043)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1047=(py*sj27);
IkReal x1048=(cj27*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1047))+(((0.2)*x1048))+(((0.8)*pz))+(((-1.0)*pp)));
evalcond[2]=(((sj29*x1047))+((sj29*x1048))+((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1049=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1049))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1049)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1050=IKcos(j30);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1050)));
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1050)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1051=IKcos(j30);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1051)));
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1051)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1052=IKcos(j30);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1052)));
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1052)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1053=IKPowWithIntegerCheck(cj29,-1);
if(!x1053.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1053.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1053.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1053.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1054=IKcos(j30);
IkReal x1055=IKsin(j30);
IkReal x1056=((1.0)*py);
IkReal x1057=(px*sj27);
IkReal x1058=((1.0)*cj27*px);
IkReal x1059=((0.321)*x1055);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1054)));
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1054)));
evalcond[2]=((((-1.0)*cj27*x1056))+x1057+((sj29*x1059)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1056))+(((-1.0)*x1058))+((cj29*x1059)));
evalcond[4]=((((-1.0)*cj29*sj27*x1056))+x1059+(((0.1)*cj29))+(((-1.0)*cj29*x1058))+(((-1.0)*cj27*sj29*x1056))+((sj29*x1057)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1060=IKPowWithIntegerCheck(sj29,-1);
if(!x1060.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1060.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1060.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1060.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1061=IKcos(j30);
IkReal x1062=IKsin(j30);
IkReal x1063=((1.0)*py);
IkReal x1064=(px*sj27);
IkReal x1065=((1.0)*cj27*px);
IkReal x1066=((0.321)*x1062);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1061)));
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1061)));
evalcond[2]=((((-1.0)*cj27*x1063))+x1064+((sj29*x1066)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1063))+((cj29*x1066))+(((-1.0)*x1065)));
evalcond[4]=(x1066+(((-1.0)*cj29*sj27*x1063))+(((0.1)*cj29))+(((-1.0)*cj27*sj29*x1063))+(((-1.0)*cj29*x1065))+((sj29*x1064)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1067=(cj27*px);
IkReal x1068=((0.8)*cj28);
IkReal x1069=(py*sj27);
IkReal x1070=((1.0)*sj28);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1068*x1069))+(((0.2)*x1069))+(((0.2)*x1067))+((x1067*x1068))+(((-0.08)*cj28))+(((-1.0)*pp))+(((-0.8)*pz*sj28)));
evalcond[2]=((((0.1)*sj28))+(((-1.0)*x1067*x1070))+(((-1.0)*x1069*x1070))+(((-1.0)*cj28*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1071=IKcos(j30);
IkReal x1072=((1.0)*py);
IkReal x1073=(cj27*px);
IkReal x1074=((0.321)*x1071);
evalcond[0]=((((0.4)*sj28))+pz+((sj28*x1074)));
evalcond[1]=(((px*sj27))+(((-1.0)*cj27*x1072))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((0.2)*x1073))+(((-1.0)*pp))+(((0.2568)*x1071))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1072))+(((0.4)*cj28))+(((-1.0)*x1073))+((cj28*x1074)));
evalcond[4]=((0.4)+x1074+(((-1.0)*cj28*sj27*x1072))+(((0.1)*cj28))+(((-1.0)*cj28*x1073))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1075=(cj27*px);
IkReal x1076=((0.8)*cj28);
IkReal x1077=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1075))+(((0.2)*x1077))+((x1075*x1076))+(((-0.08)*cj28))+(((-1.0)*pp))+((x1076*x1077))+(((-0.8)*pz*sj28)));
evalcond[2]=(((cj28*pz))+(((-0.1)*sj28))+((sj28*x1077))+((sj28*x1075)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1078=IKcos(j30);
IkReal x1079=((1.0)*py);
IkReal x1080=(cj27*px);
IkReal x1081=((0.321)*x1078);
evalcond[0]=((((0.4)*sj28))+((sj28*x1081))+pz);
evalcond[1]=((((-0.321)*(IKsin(j30))))+((px*sj27))+(((-1.0)*cj27*x1079)));
evalcond[2]=((0.253041)+(((0.2)*x1080))+(((-1.0)*pp))+(((0.2568)*x1078))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1079))+(((0.4)*cj28))+(((-1.0)*x1080))+((cj28*x1081)));
evalcond[4]=((0.4)+x1081+(((-1.0)*cj28*x1080))+(((-1.0)*cj28*sj27*x1079))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1087=IKPowWithIntegerCheck(sj29,-1);
if(!x1087.valid){
continue;
}
IkReal x1082=x1087.value;
IkReal x1083=((0.00311526479750779)*x1082);
IkReal x1084=(cj28*cj29);
IkReal x1085=((1000.0)*cj27*py);
IkReal x1086=((1000.0)*px*sj27);
CheckValue<IkReal> x1088=IKPowWithIntegerCheck(sj28,-1);
if(!x1088.valid){
continue;
}
if( IKabs((x1083*((x1085+(((-1.0)*x1086)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1083*(x1088.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1084*x1085))+((x1084*x1086)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1083*((x1085+(((-1.0)*x1086))))))+IKsqr((x1083*(x1088.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1084*x1085))+((x1084*x1086))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((x1083*((x1085+(((-1.0)*x1086))))), (x1083*(x1088.value)*(((((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+(((-1.0)*x1084*x1085))+((x1084*x1086))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1089=IKsin(j30);
IkReal x1090=IKcos(j30);
IkReal x1091=((1.0)*py);
IkReal x1092=(cj29*sj28);
IkReal x1093=(cj27*px);
IkReal x1094=(cj28*cj29);
IkReal x1095=(py*sj27);
IkReal x1096=(px*sj27);
IkReal x1097=((0.321)*x1089);
IkReal x1098=((0.321)*x1090);
evalcond[0]=(x1096+((sj29*x1097))+(((-1.0)*cj27*x1091)));
evalcond[1]=((0.253041)+(((0.2568)*x1090))+(((-1.0)*pp))+(((0.2)*x1095))+(((0.2)*x1093)));
evalcond[2]=((((0.4)*sj28))+((x1094*x1097))+((sj28*x1098))+pz);
evalcond[3]=((0.4)+(((-1.0)*cj28*x1093))+x1098+(((-1.0)*cj28*sj27*x1091))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((0.4)*cj28))+(((-1.0)*x1093))+((cj28*x1098))+(((-1.0)*x1092*x1097))+(((-1.0)*sj27*x1091)));
evalcond[5]=(x1097+((sj29*x1096))+((x1092*x1095))+((x1092*x1093))+((pz*x1094))+(((-0.1)*x1092))+(((-1.0)*cj27*sj29*x1091)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1099=((250.0)*sj28);
IkReal x1100=(py*sj27);
IkReal x1101=(cj27*px);
CheckValue<IkReal> x1102=IKPowWithIntegerCheck(cj28,-1);
if(!x1102.valid){
continue;
}
CheckValue<IkReal> x1103=IKPowWithIntegerCheck(cj29,-1);
if(!x1103.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1102.value)*(x1103.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1099*x1100))+((x1099*x1101)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((-0.778816199376947)*x1100))+(((-0.778816199376947)*x1101))+(((3.89408099688474)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1102.value)*(x1103.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1099*x1100))+((x1099*x1101))))))+IKsqr(((-0.98536214953271)+(((-0.778816199376947)*x1100))+(((-0.778816199376947)*x1101))+(((3.89408099688474)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1102.value)*(x1103.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+(((-1250.0)*pp*sj28))+((x1099*x1100))+((x1099*x1101))))), ((-0.98536214953271)+(((-0.778816199376947)*x1100))+(((-0.778816199376947)*x1101))+(((3.89408099688474)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1104=IKsin(j30);
IkReal x1105=IKcos(j30);
IkReal x1106=((1.0)*py);
IkReal x1107=(cj29*sj28);
IkReal x1108=(cj27*px);
IkReal x1109=(cj28*cj29);
IkReal x1110=(py*sj27);
IkReal x1111=(px*sj27);
IkReal x1112=((0.321)*x1104);
IkReal x1113=((0.321)*x1105);
evalcond[0]=(x1111+(((-1.0)*cj27*x1106))+((sj29*x1112)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1110))+(((0.2)*x1108))+(((0.2568)*x1105)));
evalcond[2]=((((0.4)*sj28))+((x1109*x1112))+((sj28*x1113))+pz);
evalcond[3]=((0.4)+x1113+(((-1.0)*cj28*sj27*x1106))+(((0.1)*cj28))+((pz*sj28))+(((-1.0)*cj28*x1108)));
evalcond[4]=((0.1)+((cj28*x1113))+(((-1.0)*sj27*x1106))+(((0.4)*cj28))+(((-1.0)*x1108))+(((-1.0)*x1107*x1112)));
evalcond[5]=(x1112+(((-1.0)*cj27*sj29*x1106))+((sj29*x1111))+((pz*x1109))+((x1107*x1108))+((x1107*x1110))+(((-0.1)*x1107)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1114=IKPowWithIntegerCheck(sj29,-1);
if(!x1114.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1114.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1114.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1114.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1115=IKsin(j30);
IkReal x1116=IKcos(j30);
IkReal x1117=((1.0)*py);
IkReal x1118=(cj29*sj28);
IkReal x1119=(cj27*px);
IkReal x1120=(cj28*cj29);
IkReal x1121=(py*sj27);
IkReal x1122=(px*sj27);
IkReal x1123=((0.321)*x1115);
IkReal x1124=((0.321)*x1116);
evalcond[0]=(x1122+((sj29*x1123))+(((-1.0)*cj27*x1117)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1121))+(((0.2)*x1119))+(((0.2568)*x1116)));
evalcond[2]=((((0.4)*sj28))+((sj28*x1124))+((x1120*x1123))+pz);
evalcond[3]=((0.4)+(((-1.0)*cj28*x1119))+(((-1.0)*cj28*sj27*x1117))+x1124+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj27*x1117))+(((0.4)*cj28))+(((-1.0)*x1119))+((cj28*x1124))+(((-1.0)*x1118*x1123)));
evalcond[5]=(x1123+(((-1.0)*cj27*sj29*x1117))+((sj29*x1122))+((pz*x1120))+(((-0.1)*x1118))+((x1118*x1121))+((x1118*x1119)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x192=(sj27*sj29);
IkReal x193=(cj27*sj29);
IkReal x194=(cj28*sj29);
IkReal x195=(cj28*cj30);
IkReal x196=((1.0)*sj30);
IkReal x197=((1.0)*cj29);
IkReal x198=(cj29*x196);
IkReal x199=((1.0)*cj30*sj28);
IkReal x200=((((-1.0)*x195*x197))+((sj28*sj30)));
IkReal x201=((((-1.0)*sj27*x197))+((sj28*x193)));
IkReal x202=(((sj28*x192))+((cj27*cj29)));
IkReal x203=((((-1.0)*sj28*x198))+x195);
IkReal x204=(cj27*x203);
IkReal x205=((((-1.0)*cj30*sj28*x197))+(((-1.0)*cj28*x196)));
IkReal x206=((((-1.0)*x199))+(((-1.0)*cj28*x198)));
IkReal x207=(cj27*x205);
IkReal x208=(((sj30*x193))+((sj27*x203)));
IkReal x209=((((-1.0)*sj30*x192))+x204);
IkReal x210=(((cj30*x193))+((sj27*x205)));
IkReal x211=((((-1.0)*cj30*x192))+x207);
new_r00=(((r00*(((((-1.0)*cj30*x192))+x207))))+((r20*x200))+((r10*x210)));
new_r01=(((r11*x210))+((r21*x200))+((r01*x211)));
new_r02=(((r22*x200))+((r12*x210))+((r02*x211)));
new_r10=(((r20*x194))+((r00*x201))+((r10*x202)));
new_r11=(((r11*x202))+((r01*x201))+((r21*x194)));
new_r12=(((r22*x194))+((r12*x202))+((r02*x201)));
new_r20=(((r00*x209))+((r10*x208))+((r20*x206)));
new_r21=(((r11*x208))+((r01*x209))+((r21*x206)));
new_r22=(((r22*x206))+((r02*(((((-1.0)*x192*x196))+x204))))+((r12*x208)));
{
IkReal j32array[2], cj32array[2], sj32array[2];
bool j32valid[2]={false};
_nj32 = 2;
cj32array[0]=new_r22;
if( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j32valid[0] = j32valid[1] = true;
    j32array[0] = IKacos(cj32array[0]);
    sj32array[0] = IKsin(j32array[0]);
    cj32array[1] = cj32array[0];
    j32array[1] = -j32array[0];
    sj32array[1] = -sj32array[0];
}
else if( isnan(cj32array[0]) )
{
    // probably any value will work
    j32valid[0] = true;
    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;
}
for(int ij32 = 0; ij32 < 2; ++ij32)
{
if( !j32valid[ij32] )
{
    continue;
}
_ij32[0] = ij32; _ij32[1] = -1;
for(int iij32 = ij32+1; iij32 < 2; ++iij32)
{
if( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )
{
    j32valid[iij32]=false; _ij32[1] = iij32; break; 
}
}
j32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];

{
IkReal j31eval[2];
IkReal x212=(sj27*sj29);
IkReal x213=(cj27*sj29);
IkReal x214=(cj28*sj29);
IkReal x215=(cj28*cj30);
IkReal x216=((1.0)*sj30);
IkReal x217=((1.0)*cj29);
IkReal x218=(cj29*x216);
IkReal x219=((1.0)*cj30*sj28);
IkReal x220=x200;
IkReal x221=x201;
IkReal x222=x202;
IkReal x223=(x215+(((-1.0)*sj28*x218)));
IkReal x224=(cj27*x223);
IkReal x225=x205;
IkReal x226=((((-1.0)*cj28*x218))+(((-1.0)*x219)));
IkReal x227=(cj27*x225);
IkReal x228=(((sj30*x213))+((sj27*x223)));
IkReal x229=(x224+(((-1.0)*sj30*x212)));
IkReal x230=(((cj30*x213))+((sj27*x225)));
IkReal x231=(x227+(((-1.0)*cj30*x212)));
new_r00=(((r20*x220))+((r10*x230))+((r00*((x227+(((-1.0)*cj30*x212)))))));
new_r01=(((r11*x230))+((r01*x231))+((r21*x220)));
new_r02=(((r02*x231))+((r22*x220))+((r12*x230)));
new_r10=(((r00*x221))+((r10*x222))+((r20*x214)));
new_r11=(((r21*x214))+((r01*x221))+((r11*x222)));
new_r12=(((r12*x222))+((r22*x214))+((r02*x221)));
new_r20=(((r20*x226))+((r00*x229))+((r10*x228)));
new_r21=(((r01*x229))+((r11*x228))+((r21*x226)));
new_r22=(((r12*x228))+((r22*x226))+((r02*((x224+(((-1.0)*x212*x216)))))));
j31eval[0]=sj32;
j31eval[1]=IKsign(sj32);
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )
{
{
IkReal j31eval[1];
IkReal x232=(sj27*sj29);
IkReal x233=(cj27*sj29);
IkReal x234=(cj28*sj29);
IkReal x235=(cj28*cj30);
IkReal x236=((1.0)*sj30);
IkReal x237=((1.0)*cj29);
IkReal x238=(cj29*x236);
IkReal x239=((1.0)*cj30*sj28);
IkReal x240=x200;
IkReal x241=x201;
IkReal x242=x202;
IkReal x243=(x235+(((-1.0)*sj28*x238)));
IkReal x244=(cj27*x243);
IkReal x245=x205;
IkReal x246=((((-1.0)*cj28*x238))+(((-1.0)*x239)));
IkReal x247=(cj27*x245);
IkReal x248=(((sj27*x243))+((sj30*x233)));
IkReal x249=(x244+(((-1.0)*sj30*x232)));
IkReal x250=(((sj27*x245))+((cj30*x233)));
IkReal x251=(x247+(((-1.0)*cj30*x232)));
new_r00=(((r10*x250))+((r00*((x247+(((-1.0)*cj30*x232))))))+((r20*x240)));
new_r01=(((r11*x250))+((r01*x251))+((r21*x240)));
new_r02=(((r22*x240))+((r12*x250))+((r02*x251)));
new_r10=(((r20*x234))+((r00*x241))+((r10*x242)));
new_r11=(((r01*x241))+((r11*x242))+((r21*x234)));
new_r12=(((r02*x241))+((r12*x242))+((r22*x234)));
new_r20=(((r00*x249))+((r10*x248))+((r20*x246)));
new_r21=(((r21*x246))+((r01*x249))+((r11*x248)));
new_r22=(((r22*x246))+((r12*x248))+((r02*((x244+(((-1.0)*x232*x236)))))));
j31eval[0]=sj32;
if( IKabs(j31eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x253 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x253.valid){
continue;
}
IkReal x252=x253.value;
j31array[0]=((-1.0)*x252);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x252)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x254=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x254)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x254))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x254))))+IKsqr(((((-1.0)*new_r01*x254))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x254))), ((((-1.0)*new_r01*x254))+((cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x255=IKsin(j33);
IkReal x256=IKcos(j33);
IkReal x257=((1.0)*sj31);
IkReal x258=((1.0)*x256);
IkReal x259=(sj31*x255);
IkReal x260=((1.0)*x255);
IkReal x261=(cj31*x258);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x255);
evalcond[1]=(((cj31*x255))+((sj31*x256))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x258)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x260))+(((-1.0)*new_r00*x257)));
evalcond[4]=((((-1.0)*new_r01*x257))+((cj31*new_r11))+(((-1.0)*x258)));
evalcond[5]=(x259+new_r00+(((-1.0)*x261)));
evalcond[6]=(x259+new_r11+(((-1.0)*x261)));
evalcond[7]=((((-1.0)*x256*x257))+(((-1.0)*cj31*x260))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x263 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x263.valid){
continue;
}
IkReal x262=x263.value;
j31array[0]=((-1.0)*x262);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x262)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x264=((1.0)*sj31);
if( IKabs(((((-1.0)*new_r00*x264))+((cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x264))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x264))+((cj31*new_r01))))+IKsqr(((((-1.0)*new_r01*x264))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*new_r00*x264))+((cj31*new_r01))), ((((-1.0)*new_r01*x264))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x265=IKsin(j33);
IkReal x266=IKcos(j33);
IkReal x267=((1.0)*sj31);
IkReal x268=((1.0)*x265);
IkReal x269=(sj31*x266);
IkReal x270=((1.0)*x266);
IkReal x271=(cj31*x268);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x266);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x268)));
evalcond[2]=(((sj31*x265))+((cj31*x266))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x267))+(((-1.0)*x268)));
evalcond[4]=((((-1.0)*new_r01*x267))+((cj31*new_r11))+(((-1.0)*x270)));
evalcond[5]=(x269+(((-1.0)*x271))+new_r01);
evalcond[6]=(x269+(((-1.0)*x271))+new_r10);
evalcond[7]=((((-1.0)*cj31*x270))+(((-1.0)*x265*x267))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j31, j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x273=IKPowWithIntegerCheck(sj32,-1);
if(!x273.valid){
continue;
}
IkReal x272=x273.value;
CheckValue<IkReal> x274=IKPowWithIntegerCheck(new_r12,-1);
if(!x274.valid){
continue;
}
if( IKabs((x272*(x274.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x272)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x272*(x274.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))))+IKsqr((new_r02*x272))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2((x272*(x274.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))), (new_r02*x272));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x275=IKcos(j31);
IkReal x276=IKsin(j31);
IkReal x277=((1.0)*sj32);
IkReal x278=(new_r02*x275);
IkReal x279=(new_r12*x276);
IkReal x280=(sj32*x275);
IkReal x281=(sj32*x276);
evalcond[0]=((((-1.0)*x275*x277))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x276*x277)));
evalcond[2]=((((-1.0)*new_r02*x276))+((new_r12*x275)));
evalcond[3]=(x278+x279+(((-1.0)*x277)));
evalcond[4]=(((cj32*new_r20))+((new_r00*x280))+((new_r10*x281)));
evalcond[5]=(((cj32*new_r21))+((new_r11*x281))+((new_r01*x280)));
evalcond[6]=((-1.0)+((sj32*x278))+((sj32*x279))+((cj32*new_r22)));
evalcond[7]=((((-1.0)*new_r22*x277))+((cj32*x279))+((cj32*x278)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[2];
IkReal x282=(sj27*sj29);
IkReal x283=(cj27*sj29);
IkReal x284=(cj28*sj29);
IkReal x285=(cj28*cj30);
IkReal x286=((1.0)*sj30);
IkReal x287=((1.0)*cj29);
IkReal x288=(cj29*x286);
IkReal x289=((1.0)*cj30*sj28);
IkReal x290=x200;
IkReal x291=x201;
IkReal x292=x202;
IkReal x293=(x285+(((-1.0)*sj28*x288)));
IkReal x294=(cj27*x293);
IkReal x295=x205;
IkReal x296=((((-1.0)*cj28*x288))+(((-1.0)*x289)));
IkReal x297=(cj27*x295);
IkReal x298=(((sj30*x283))+((sj27*x293)));
IkReal x299=(x294+(((-1.0)*sj30*x282)));
IkReal x300=(((cj30*x283))+((sj27*x295)));
IkReal x301=((((-1.0)*cj30*x282))+x297);
new_r00=(((r20*x290))+((r00*(((((-1.0)*cj30*x282))+x297))))+((r10*x300)));
new_r01=(((r11*x300))+((r01*x301))+((r21*x290)));
new_r02=(((r02*x301))+((r22*x290))+((r12*x300)));
new_r10=(((r00*x291))+((r10*x292))+((r20*x284)));
new_r11=(((r21*x284))+((r01*x291))+((r11*x292)));
new_r12=(((r12*x292))+((r22*x284))+((r02*x291)));
new_r20=(((r20*x296))+((r00*x299))+((r10*x298)));
new_r21=(((r01*x299))+((r21*x296))+((r11*x298)));
new_r22=(((r12*x298))+((r22*x296))+((r02*((x294+(((-1.0)*x282*x286)))))));
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
IkReal x302=(sj27*sj29);
IkReal x303=(cj27*sj29);
IkReal x304=(cj28*sj29);
IkReal x305=(cj28*cj30);
IkReal x306=((1.0)*sj30);
IkReal x307=((1.0)*cj29);
IkReal x308=(cj29*x306);
IkReal x309=((1.0)*cj30*sj28);
IkReal x310=x200;
IkReal x311=x201;
IkReal x312=x202;
IkReal x313=((((-1.0)*sj28*x308))+x305);
IkReal x314=(cj27*x313);
IkReal x315=x205;
IkReal x316=((((-1.0)*cj28*x308))+(((-1.0)*x309)));
IkReal x317=(cj27*x315);
IkReal x318=(((sj27*x313))+((sj30*x303)));
IkReal x319=(x314+(((-1.0)*sj30*x302)));
IkReal x320=(((cj30*x303))+((sj27*x315)));
IkReal x321=((((-1.0)*cj30*x302))+x317);
new_r00=(((r20*x310))+((r10*x320))+((r00*(((((-1.0)*cj30*x302))+x317)))));
new_r01=(((r11*x320))+((r01*x321))+((r21*x310)));
new_r02=(((r02*x321))+((r12*x320))+((r22*x310)));
new_r10=(((r20*x304))+((r00*x311))+((r10*x312)));
new_r11=(((r11*x312))+((r21*x304))+((r01*x311)));
new_r12=(((r22*x304))+((r02*x311))+((r12*x312)));
new_r20=(((r20*x316))+((r00*x319))+((r10*x318)));
new_r21=(((r11*x318))+((r01*x319))+((r21*x316)));
new_r22=(((r02*(((((-1.0)*x302*x306))+x314))))+((r12*x318))+((r22*x316)));
j33eval[0]=sj32;
j33eval[1]=sj31;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
IkReal x322=(sj27*sj29);
IkReal x323=(cj27*sj29);
IkReal x324=(cj28*sj29);
IkReal x325=(cj28*cj30);
IkReal x326=((1.0)*sj30);
IkReal x327=((1.0)*cj29);
IkReal x328=(cj29*x326);
IkReal x329=((1.0)*cj30*sj28);
IkReal x330=x200;
IkReal x331=x201;
IkReal x332=x202;
IkReal x333=(x325+(((-1.0)*sj28*x328)));
IkReal x334=(cj27*x333);
IkReal x335=x205;
IkReal x336=((((-1.0)*cj28*x328))+(((-1.0)*x329)));
IkReal x337=(cj27*x335);
IkReal x338=(((sj30*x323))+((sj27*x333)));
IkReal x339=((((-1.0)*sj30*x322))+x334);
IkReal x340=(((sj27*x335))+((cj30*x323)));
IkReal x341=(x337+(((-1.0)*cj30*x322)));
new_r00=(((r20*x330))+((r00*((x337+(((-1.0)*cj30*x322))))))+((r10*x340)));
new_r01=(((r01*x341))+((r21*x330))+((r11*x340)));
new_r02=(((r22*x330))+((r02*x341))+((r12*x340)));
new_r10=(((r00*x331))+((r20*x324))+((r10*x332)));
new_r11=(((r01*x331))+((r11*x332))+((r21*x324)));
new_r12=(((r12*x332))+((r02*x331))+((r22*x324)));
new_r20=(((r00*x339))+((r20*x336))+((r10*x338)));
new_r21=(((r01*x339))+((r11*x338))+((r21*x336)));
new_r22=(((r22*x336))+((r02*(((((-1.0)*x322*x326))+x334))))+((r12*x338)));
j33eval[0]=cj32;
j33eval[1]=sj31;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x342=((1.0)*sj31);
IkReal x343=((((-1.0)*new_r02*x342))+((cj31*new_r12)));
IkReal x344=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x345=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x346=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj31))+new_r02);
evalcond[3]=(new_r12+(((-1.0)*x342)));
evalcond[4]=x343;
evalcond[5]=x343;
evalcond[6]=x346;
evalcond[7]=x345;
evalcond[8]=x344;
evalcond[9]=x344;
evalcond[10]=x345;
evalcond[11]=x346;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x347=IKcos(j33);
IkReal x348=IKsin(j33);
IkReal x349=((1.0)*new_r12);
IkReal x350=((1.0)*x348);
IkReal x351=((1.0)*x347);
evalcond[0]=(x347+new_r20);
evalcond[1]=((((-1.0)*x350))+new_r21);
evalcond[2]=(((new_r12*x347))+new_r01);
evalcond[3]=(((new_r12*x348))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x351))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x350))+new_r10);
evalcond[6]=((((-1.0)*x350))+(((-1.0)*new_r00*x349))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x351))+((new_r02*new_r11))+(((-1.0)*new_r01*x349)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x352=(new_r10*sj31);
IkReal x353=(cj31*new_r00);
IkReal x354=(cj31*new_r02);
IkReal x355=(new_r11*sj31);
IkReal x356=(new_r12*sj31);
IkReal x357=(cj31*new_r01);
IkReal x358=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj31+new_r02);
evalcond[3]=(sj31+new_r12);
evalcond[4]=x358;
evalcond[5]=x358;
evalcond[6]=((1.0)+x354+x356);
evalcond[7]=(x355+x357);
evalcond[8]=(x353+x352);
evalcond[9]=((((-1.0)*x353))+(((-1.0)*x352)));
evalcond[10]=((((-1.0)*x357))+(((-1.0)*x355)));
evalcond[11]=((-1.0)+(((-1.0)*x356))+(((-1.0)*x354)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x359=IKcos(j33);
IkReal x360=IKsin(j33);
IkReal x361=((1.0)*new_r02);
IkReal x362=((1.0)*x359);
IkReal x363=((1.0)*x360);
evalcond[0]=(x360+new_r21);
evalcond[1]=((((-1.0)*x362))+new_r20);
evalcond[2]=(new_r11+((new_r02*x359)));
evalcond[3]=(new_r10+((new_r02*x360)));
evalcond[4]=((((-1.0)*new_r12*x362))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x363))+new_r00);
evalcond[6]=((((-1.0)*x363))+((new_r00*new_r12))+(((-1.0)*new_r10*x361)));
evalcond[7]=((((-1.0)*x362))+((new_r01*new_r12))+(((-1.0)*new_r11*x361)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x364=((((-1.0)*cj32))+new_r22);
IkReal x365=((((-1.0)*sj32))+new_r02);
IkReal x366=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x364;
evalcond[2]=x364;
evalcond[3]=x365;
evalcond[4]=new_r12;
evalcond[5]=x365;
evalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x366)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x367=IKcos(j33);
IkReal x368=IKsin(j33);
IkReal x369=((1.0)*new_r02);
IkReal x370=((1.0)*x367);
evalcond[0]=(new_r20+((new_r02*x367)));
evalcond[1]=((((-1.0)*x368))+new_r10);
evalcond[2]=((((-1.0)*x370))+new_r11);
evalcond[3]=(((new_r22*x368))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x368*x369)));
evalcond[5]=((((-1.0)*new_r22*x370))+new_r00);
evalcond[6]=(((new_r01*new_r22))+x368+(((-1.0)*new_r21*x369)));
evalcond[7]=((((-1.0)*new_r20*x369))+((new_r00*new_r22))+(((-1.0)*x370)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x371=((((-1.0)*cj32))+new_r22);
IkReal x372=((1.0)*sj32);
IkReal x373=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x371;
evalcond[2]=x371;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x372))+(((-1.0)*x373)));
evalcond[6]=((((-1.0)*new_r00*x372))+((cj32*new_r20)));
evalcond[7]=(((cj32*new_r21))+(((-1.0)*new_r01*x372)));
evalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x372)));
evalcond[9]=((((-1.0)*new_r22*x372))+(((-1.0)*cj32*x373)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x374=IKsin(j33);
IkReal x375=IKcos(j33);
IkReal x376=((1.0)*new_r22);
IkReal x377=((1.0)*x375);
evalcond[0]=(new_r21+((new_r02*x374)));
evalcond[1]=(new_r20+(((-1.0)*new_r02*x377)));
evalcond[2]=((((-1.0)*x374))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x377))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x374)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x375*x376)));
evalcond[6]=(x374+((new_r02*new_r21))+(((-1.0)*new_r01*x376)));
evalcond[7]=((((-1.0)*new_r00*x376))+(((-1.0)*x377))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x378=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x379=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x378;
evalcond[7]=x378;
evalcond[8]=x379;
evalcond[9]=x379;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x380=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x380)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x380)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x380))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x380))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x380))), (((cj31*new_r00))+(((-1.0)*new_r01*x380))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x381=IKsin(j33);
IkReal x382=IKcos(j33);
IkReal x383=((1.0)*sj31);
IkReal x384=((1.0)*x382);
IkReal x385=(sj31*x381);
IkReal x386=((1.0)*x381);
IkReal x387=(cj31*x384);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x381);
evalcond[1]=(((sj31*x382))+((cj31*x381))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x384)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x383))+(((-1.0)*x386)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x383))+(((-1.0)*x384)));
evalcond[5]=(x385+(((-1.0)*x387))+new_r00);
evalcond[6]=(x385+(((-1.0)*x387))+new_r11);
evalcond[7]=(new_r10+(((-1.0)*cj31*x386))+(((-1.0)*x382*x383)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x388=(cj31*new_r02);
IkReal x389=(new_r12*sj31);
IkReal x390=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x390;
evalcond[7]=x390;
evalcond[8]=(x388+x389);
evalcond[9]=((((-1.0)*x388))+(((-1.0)*x389)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x391=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x391)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x391))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x391))))+IKsqr(((((-1.0)*new_r01*x391))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x391))), ((((-1.0)*new_r01*x391))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x392=IKsin(j33);
IkReal x393=IKcos(j33);
IkReal x394=((1.0)*sj31);
IkReal x395=((1.0)*x392);
IkReal x396=(sj31*x393);
IkReal x397=((1.0)*x393);
IkReal x398=(cj31*x395);
evalcond[0]=(((cj31*new_r00))+x393+((new_r10*sj31)));
evalcond[1]=((((-1.0)*x395))+((cj31*new_r01))+((new_r11*sj31)));
evalcond[2]=(((cj31*x393))+((sj31*x392))+new_r00);
evalcond[3]=((((-1.0)*x395))+((cj31*new_r10))+(((-1.0)*new_r00*x394)));
evalcond[4]=((((-1.0)*new_r01*x394))+(((-1.0)*x397))+((cj31*new_r11)));
evalcond[5]=((((-1.0)*x398))+x396+new_r01);
evalcond[6]=((((-1.0)*x398))+x396+new_r10);
evalcond[7]=((((-1.0)*cj31*x397))+new_r11+(((-1.0)*x392*x394)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x400=IKPowWithIntegerCheck(sj32,-1);
if(!x400.valid){
continue;
}
IkReal x399=x400.value;
CheckValue<IkReal> x401=IKPowWithIntegerCheck(cj32,-1);
if(!x401.valid){
continue;
}
CheckValue<IkReal> x402=IKPowWithIntegerCheck(sj31,-1);
if(!x402.valid){
continue;
}
if( IKabs((x399*(x401.value)*(x402.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x399)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x399*(x401.value)*(x402.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))))+IKsqr(((-1.0)*new_r20*x399))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x399*(x401.value)*(x402.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))), ((-1.0)*new_r20*x399));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x403=IKsin(j33);
IkReal x404=IKcos(j33);
IkReal x405=(cj31*cj32);
IkReal x406=((1.0)*sj31);
IkReal x407=(new_r11*sj31);
IkReal x408=(new_r10*sj31);
IkReal x409=((1.0)*sj32);
IkReal x410=((1.0)*x404);
IkReal x411=((1.0)*x403);
IkReal x412=(sj31*x403);
evalcond[0]=(new_r20+((sj32*x404)));
evalcond[1]=((((-1.0)*x403*x409))+new_r21);
evalcond[2]=(((cj32*x403))+((cj31*new_r01))+x407);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x406))+(((-1.0)*x411)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x410))+(((-1.0)*new_r01*x406)));
evalcond[5]=(((sj31*x404))+new_r01+((x403*x405)));
evalcond[6]=(((cj31*new_r00))+x408+(((-1.0)*cj32*x410)));
evalcond[7]=(x412+(((-1.0)*x405*x410))+new_r00);
evalcond[8]=(((cj32*x412))+(((-1.0)*cj31*x410))+new_r11);
evalcond[9]=((((-1.0)*cj32*x404*x406))+(((-1.0)*cj31*x411))+new_r10);
evalcond[10]=(((cj32*x407))+x403+(((-1.0)*new_r21*x409))+((new_r01*x405)));
evalcond[11]=(((cj32*x408))+(((-1.0)*new_r20*x409))+(((-1.0)*x410))+((new_r00*x405)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x414=IKPowWithIntegerCheck(sj32,-1);
if(!x414.valid){
continue;
}
IkReal x413=x414.value;
CheckValue<IkReal> x415=IKPowWithIntegerCheck(sj31,-1);
if(!x415.valid){
continue;
}
if( IKabs((new_r21*x413)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x413*(x415.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x413))+IKsqr((x413*(x415.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*x413), (x413*(x415.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x416=IKsin(j33);
IkReal x417=IKcos(j33);
IkReal x418=(cj31*cj32);
IkReal x419=((1.0)*sj31);
IkReal x420=(new_r11*sj31);
IkReal x421=(new_r10*sj31);
IkReal x422=((1.0)*sj32);
IkReal x423=((1.0)*x417);
IkReal x424=((1.0)*x416);
IkReal x425=(sj31*x416);
evalcond[0]=(((sj32*x417))+new_r20);
evalcond[1]=((((-1.0)*x416*x422))+new_r21);
evalcond[2]=(((cj32*x416))+((cj31*new_r01))+x420);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x424))+(((-1.0)*new_r00*x419)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x423))+(((-1.0)*new_r01*x419)));
evalcond[5]=(((x416*x418))+((sj31*x417))+new_r01);
evalcond[6]=(((cj31*new_r00))+x421+(((-1.0)*cj32*x423)));
evalcond[7]=(x425+(((-1.0)*x418*x423))+new_r00);
evalcond[8]=((((-1.0)*cj31*x423))+((cj32*x425))+new_r11);
evalcond[9]=((((-1.0)*cj32*x417*x419))+(((-1.0)*cj31*x424))+new_r10);
evalcond[10]=(x416+((cj32*x420))+(((-1.0)*new_r21*x422))+((new_r01*x418)));
evalcond[11]=((((-1.0)*x423))+((cj32*x421))+(((-1.0)*new_r20*x422))+((new_r00*x418)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x426=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x426.valid){
continue;
}
CheckValue<IkReal> x427 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x427.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x426.value)))+(x427.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x428=IKsin(j33);
IkReal x429=IKcos(j33);
IkReal x430=(cj31*cj32);
IkReal x431=((1.0)*sj31);
IkReal x432=(new_r11*sj31);
IkReal x433=(new_r10*sj31);
IkReal x434=((1.0)*sj32);
IkReal x435=((1.0)*x429);
IkReal x436=((1.0)*x428);
IkReal x437=(sj31*x428);
evalcond[0]=(new_r20+((sj32*x429)));
evalcond[1]=(new_r21+(((-1.0)*x428*x434)));
evalcond[2]=(((cj31*new_r01))+x432+((cj32*x428)));
evalcond[3]=((((-1.0)*new_r00*x431))+(((-1.0)*x436))+((cj31*new_r10)));
evalcond[4]=((((-1.0)*x435))+(((-1.0)*new_r01*x431))+((cj31*new_r11)));
evalcond[5]=(((x428*x430))+((sj31*x429))+new_r01);
evalcond[6]=(((cj31*new_r00))+x433+(((-1.0)*cj32*x435)));
evalcond[7]=((((-1.0)*x430*x435))+x437+new_r00);
evalcond[8]=(((cj32*x437))+(((-1.0)*cj31*x435))+new_r11);
evalcond[9]=((((-1.0)*cj32*x429*x431))+(((-1.0)*cj31*x436))+new_r10);
evalcond[10]=(((new_r01*x430))+((cj32*x432))+x428+(((-1.0)*new_r21*x434)));
evalcond[11]=((((-1.0)*x435))+((new_r00*x430))+((cj32*x433))+(((-1.0)*new_r20*x434)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x438=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x438.valid){
continue;
}
CheckValue<IkReal> x439 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x439.valid){
continue;
}
j31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x438.value)))+(x439.value));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x440=IKcos(j31);
IkReal x441=IKsin(j31);
IkReal x442=((1.0)*sj32);
IkReal x443=(new_r02*x440);
IkReal x444=(new_r12*x441);
IkReal x445=(sj32*x440);
IkReal x446=(sj32*x441);
evalcond[0]=(new_r02+(((-1.0)*x440*x442)));
evalcond[1]=(new_r12+(((-1.0)*x441*x442)));
evalcond[2]=(((new_r12*x440))+(((-1.0)*new_r02*x441)));
evalcond[3]=((((-1.0)*x442))+x444+x443);
evalcond[4]=(((new_r00*x445))+((new_r10*x446))+((cj32*new_r20)));
evalcond[5]=(((new_r01*x445))+((new_r11*x446))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((sj32*x444))+((sj32*x443))+((cj32*new_r22)));
evalcond[7]=(((cj32*x443))+((cj32*x444))+(((-1.0)*new_r22*x442)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[2];
IkReal x447=(sj27*sj29);
IkReal x448=(cj27*sj29);
IkReal x449=(cj28*sj29);
IkReal x450=(cj28*cj30);
IkReal x451=((1.0)*sj30);
IkReal x452=((1.0)*cj29);
IkReal x453=(cj29*x451);
IkReal x454=((1.0)*cj30*sj28);
IkReal x455=x200;
IkReal x456=x201;
IkReal x457=x202;
IkReal x458=((((-1.0)*sj28*x453))+x450);
IkReal x459=(cj27*x458);
IkReal x460=x205;
IkReal x461=((((-1.0)*cj28*x453))+(((-1.0)*x454)));
IkReal x462=(cj27*x460);
IkReal x463=(((sj30*x448))+((sj27*x458)));
IkReal x464=(x459+(((-1.0)*sj30*x447)));
IkReal x465=(((sj27*x460))+((cj30*x448)));
IkReal x466=((((-1.0)*cj30*x447))+x462);
new_r00=(((r20*x455))+((r00*(((((-1.0)*cj30*x447))+x462))))+((r10*x465)));
new_r01=(((r11*x465))+((r01*x466))+((r21*x455)));
new_r02=(((r12*x465))+((r02*x466))+((r22*x455)));
new_r10=(((r00*x456))+((r20*x449))+((r10*x457)));
new_r11=(((r21*x449))+((r11*x457))+((r01*x456)));
new_r12=(((r22*x449))+((r12*x457))+((r02*x456)));
new_r20=(((r20*x461))+((r00*x464))+((r10*x463)));
new_r21=(((r11*x463))+((r01*x464))+((r21*x461)));
new_r22=(((r22*x461))+((r12*x463))+((r02*(((((-1.0)*x447*x451))+x459)))));
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
IkReal x467=(sj27*sj29);
IkReal x468=(cj27*sj29);
IkReal x469=(cj28*sj29);
IkReal x470=(cj28*cj30);
IkReal x471=((1.0)*sj30);
IkReal x472=((1.0)*cj29);
IkReal x473=(cj29*x471);
IkReal x474=((1.0)*cj30*sj28);
IkReal x475=x200;
IkReal x476=x201;
IkReal x477=x202;
IkReal x478=((((-1.0)*sj28*x473))+x470);
IkReal x479=(cj27*x478);
IkReal x480=x205;
IkReal x481=((((-1.0)*cj28*x473))+(((-1.0)*x474)));
IkReal x482=(cj27*x480);
IkReal x483=(((sj27*x478))+((sj30*x468)));
IkReal x484=((((-1.0)*sj30*x467))+x479);
IkReal x485=(((sj27*x480))+((cj30*x468)));
IkReal x486=(x482+(((-1.0)*cj30*x467)));
new_r00=(((r20*x475))+((r00*((x482+(((-1.0)*cj30*x467))))))+((r10*x485)));
new_r01=(((r21*x475))+((r11*x485))+((r01*x486)));
new_r02=(((r02*x486))+((r12*x485))+((r22*x475)));
new_r10=(((r10*x477))+((r20*x469))+((r00*x476)));
new_r11=(((r11*x477))+((r21*x469))+((r01*x476)));
new_r12=(((r22*x469))+((r02*x476))+((r12*x477)));
new_r20=(((r20*x481))+((r10*x483))+((r00*x484)));
new_r21=(((r11*x483))+((r21*x481))+((r01*x484)));
new_r22=(((r12*x483))+((r02*(((((-1.0)*x467*x471))+x479))))+((r22*x481)));
j33eval[0]=sj32;
j33eval[1]=sj31;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
IkReal x487=(sj27*sj29);
IkReal x488=(cj27*sj29);
IkReal x489=(cj28*sj29);
IkReal x490=(cj28*cj30);
IkReal x491=((1.0)*sj30);
IkReal x492=((1.0)*cj29);
IkReal x493=(cj29*x491);
IkReal x494=((1.0)*cj30*sj28);
IkReal x495=x200;
IkReal x496=x201;
IkReal x497=x202;
IkReal x498=(x490+(((-1.0)*sj28*x493)));
IkReal x499=(cj27*x498);
IkReal x500=x205;
IkReal x501=((((-1.0)*x494))+(((-1.0)*cj28*x493)));
IkReal x502=(cj27*x500);
IkReal x503=(((sj27*x498))+((sj30*x488)));
IkReal x504=((((-1.0)*sj30*x487))+x499);
IkReal x505=(((sj27*x500))+((cj30*x488)));
IkReal x506=((((-1.0)*cj30*x487))+x502);
new_r00=(((r10*x505))+((r00*(((((-1.0)*cj30*x487))+x502))))+((r20*x495)));
new_r01=(((r01*x506))+((r11*x505))+((r21*x495)));
new_r02=(((r22*x495))+((r12*x505))+((r02*x506)));
new_r10=(((r20*x489))+((r10*x497))+((r00*x496)));
new_r11=(((r11*x497))+((r21*x489))+((r01*x496)));
new_r12=(((r02*x496))+((r12*x497))+((r22*x489)));
new_r20=(((r20*x501))+((r10*x503))+((r00*x504)));
new_r21=(((r21*x501))+((r01*x504))+((r11*x503)));
new_r22=(((r02*((x499+(((-1.0)*x487*x491))))))+((r22*x501))+((r12*x503)));
j33eval[0]=cj32;
j33eval[1]=sj31;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x507=((1.0)*sj31);
IkReal x508=(((cj31*new_r12))+(((-1.0)*new_r02*x507)));
IkReal x509=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x510=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x511=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj31))+new_r02);
evalcond[3]=((((-1.0)*x507))+new_r12);
evalcond[4]=x508;
evalcond[5]=x508;
evalcond[6]=x511;
evalcond[7]=x510;
evalcond[8]=x509;
evalcond[9]=x509;
evalcond[10]=x510;
evalcond[11]=x511;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x512=IKcos(j33);
IkReal x513=IKsin(j33);
IkReal x514=((1.0)*new_r12);
IkReal x515=((1.0)*x513);
IkReal x516=((1.0)*x512);
evalcond[0]=(x512+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x515)));
evalcond[2]=(((new_r12*x512))+new_r01);
evalcond[3]=(((new_r12*x513))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x516))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x515))+new_r10);
evalcond[6]=(((new_r02*new_r10))+(((-1.0)*new_r00*x514))+(((-1.0)*x515)));
evalcond[7]=((((-1.0)*new_r01*x514))+((new_r02*new_r11))+(((-1.0)*x516)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x517=(new_r10*sj31);
IkReal x518=(cj31*new_r00);
IkReal x519=(cj31*new_r02);
IkReal x520=(new_r11*sj31);
IkReal x521=(new_r12*sj31);
IkReal x522=(cj31*new_r01);
IkReal x523=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj31+new_r02);
evalcond[3]=(sj31+new_r12);
evalcond[4]=x523;
evalcond[5]=x523;
evalcond[6]=((1.0)+x521+x519);
evalcond[7]=(x522+x520);
evalcond[8]=(x518+x517);
evalcond[9]=((((-1.0)*x518))+(((-1.0)*x517)));
evalcond[10]=((((-1.0)*x520))+(((-1.0)*x522)));
evalcond[11]=((-1.0)+(((-1.0)*x521))+(((-1.0)*x519)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x524=IKcos(j33);
IkReal x525=IKsin(j33);
IkReal x526=((1.0)*new_r02);
IkReal x527=((1.0)*x524);
IkReal x528=((1.0)*x525);
evalcond[0]=(x525+new_r21);
evalcond[1]=((((-1.0)*x527))+new_r20);
evalcond[2]=(((new_r02*x524))+new_r11);
evalcond[3]=(((new_r02*x525))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x527))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x528))+new_r00);
evalcond[6]=((((-1.0)*x528))+((new_r00*new_r12))+(((-1.0)*new_r10*x526)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*x527))+(((-1.0)*new_r11*x526)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x529=((((-1.0)*cj32))+new_r22);
IkReal x530=((((-1.0)*sj32))+new_r02);
IkReal x531=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x529;
evalcond[2]=x529;
evalcond[3]=x530;
evalcond[4]=new_r12;
evalcond[5]=x530;
evalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x531))+((cj32*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x532=IKcos(j33);
IkReal x533=IKsin(j33);
IkReal x534=((1.0)*new_r02);
IkReal x535=((1.0)*x532);
evalcond[0]=(((new_r02*x532))+new_r20);
evalcond[1]=((((-1.0)*x533))+new_r10);
evalcond[2]=((((-1.0)*x535))+new_r11);
evalcond[3]=(((new_r22*x533))+new_r01);
evalcond[4]=((((-1.0)*x533*x534))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x535))+new_r00);
evalcond[6]=(((new_r01*new_r22))+(((-1.0)*new_r21*x534))+x533);
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*x535))+(((-1.0)*new_r20*x534)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x536=((((-1.0)*cj32))+new_r22);
IkReal x537=((1.0)*sj32);
IkReal x538=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x536;
evalcond[2]=x536;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x538))+(((-1.0)*x537)));
evalcond[6]=((((-1.0)*new_r00*x537))+((cj32*new_r20)));
evalcond[7]=((((-1.0)*new_r01*x537))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x537)));
evalcond[9]=((((-1.0)*new_r22*x537))+(((-1.0)*cj32*x538)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r10))+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r10), ((-1.0)*new_r11));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x539=IKsin(j33);
IkReal x540=IKcos(j33);
IkReal x541=((1.0)*new_r22);
IkReal x542=((1.0)*x540);
evalcond[0]=(((new_r02*x539))+new_r21);
evalcond[1]=(new_r20+(((-1.0)*new_r02*x542)));
evalcond[2]=((((-1.0)*x539))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x542))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x539)));
evalcond[5]=((((-1.0)*x540*x541))+(((-1.0)*new_r00)));
evalcond[6]=((((-1.0)*new_r01*x541))+x539+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*new_r00*x541))+(((-1.0)*x542))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x543=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x544=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x543;
evalcond[7]=x543;
evalcond[8]=x544;
evalcond[9]=x544;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x545=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x545)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x545)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x545))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x545))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x545))), (((cj31*new_r00))+(((-1.0)*new_r01*x545))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x546=IKsin(j33);
IkReal x547=IKcos(j33);
IkReal x548=((1.0)*sj31);
IkReal x549=((1.0)*x547);
IkReal x550=(sj31*x546);
IkReal x551=((1.0)*x546);
IkReal x552=(cj31*x549);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x546);
evalcond[1]=(((sj31*x547))+((cj31*x546))+new_r01);
evalcond[2]=(((cj31*new_r00))+(((-1.0)*x549))+((new_r10*sj31)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x548))+(((-1.0)*x551)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x548))+(((-1.0)*x549)));
evalcond[5]=((((-1.0)*x552))+x550+new_r00);
evalcond[6]=((((-1.0)*x552))+x550+new_r11);
evalcond[7]=((((-1.0)*x547*x548))+new_r10+(((-1.0)*cj31*x551)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x553=(cj31*new_r02);
IkReal x554=(new_r12*sj31);
IkReal x555=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x555;
evalcond[7]=x555;
evalcond[8]=(x553+x554);
evalcond[9]=((((-1.0)*x554))+(((-1.0)*x553)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x556=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x556)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x556)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x556))))+IKsqr(((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x556))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x556))), ((((-1.0)*cj31*new_r00))+(((-1.0)*new_r01*x556))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x557=IKsin(j33);
IkReal x558=IKcos(j33);
IkReal x559=((1.0)*sj31);
IkReal x560=((1.0)*x557);
IkReal x561=(sj31*x558);
IkReal x562=((1.0)*x558);
IkReal x563=(cj31*x560);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x558);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x560)));
evalcond[2]=(((cj31*x558))+((sj31*x557))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x559))+(((-1.0)*x560)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x559))+(((-1.0)*x562)));
evalcond[5]=(x561+new_r01+(((-1.0)*x563)));
evalcond[6]=(x561+new_r10+(((-1.0)*x563)));
evalcond[7]=((((-1.0)*cj31*x562))+new_r11+(((-1.0)*x557*x559)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x565=IKPowWithIntegerCheck(sj32,-1);
if(!x565.valid){
continue;
}
IkReal x564=x565.value;
CheckValue<IkReal> x566=IKPowWithIntegerCheck(cj32,-1);
if(!x566.valid){
continue;
}
CheckValue<IkReal> x567=IKPowWithIntegerCheck(sj31,-1);
if(!x567.valid){
continue;
}
if( IKabs((x564*(x566.value)*(x567.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x564)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x564*(x566.value)*(x567.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))))+IKsqr(((-1.0)*new_r20*x564))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x564*(x566.value)*(x567.value)*(((((-1.0)*new_r11*sj32))+(((-1.0)*cj31*new_r20))))), ((-1.0)*new_r20*x564));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x568=IKsin(j33);
IkReal x569=IKcos(j33);
IkReal x570=(cj31*cj32);
IkReal x571=((1.0)*sj31);
IkReal x572=(new_r11*sj31);
IkReal x573=(new_r10*sj31);
IkReal x574=((1.0)*sj32);
IkReal x575=((1.0)*x569);
IkReal x576=((1.0)*x568);
IkReal x577=(sj31*x568);
evalcond[0]=(((sj32*x569))+new_r20);
evalcond[1]=((((-1.0)*x568*x574))+new_r21);
evalcond[2]=(((cj31*new_r01))+x572+((cj32*x568)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x576))+(((-1.0)*new_r00*x571)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x575))+(((-1.0)*new_r01*x571)));
evalcond[5]=(((sj31*x569))+((x568*x570))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x575))+x573);
evalcond[7]=((((-1.0)*x570*x575))+x577+new_r00);
evalcond[8]=(((cj32*x577))+new_r11+(((-1.0)*cj31*x575)));
evalcond[9]=((((-1.0)*cj32*x569*x571))+new_r10+(((-1.0)*cj31*x576)));
evalcond[10]=(((new_r01*x570))+((cj32*x572))+x568+(((-1.0)*new_r21*x574)));
evalcond[11]=(((new_r00*x570))+((cj32*x573))+(((-1.0)*x575))+(((-1.0)*new_r20*x574)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x579=IKPowWithIntegerCheck(sj32,-1);
if(!x579.valid){
continue;
}
IkReal x578=x579.value;
CheckValue<IkReal> x580=IKPowWithIntegerCheck(sj31,-1);
if(!x580.valid){
continue;
}
if( IKabs((new_r21*x578)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x578*(x580.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r21*x578))+IKsqr((x578*(x580.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((new_r21*x578), (x578*(x580.value)*(((((-1.0)*cj31*cj32*new_r21))+(((-1.0)*new_r01*sj32))))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x581=IKsin(j33);
IkReal x582=IKcos(j33);
IkReal x583=(cj31*cj32);
IkReal x584=((1.0)*sj31);
IkReal x585=(new_r11*sj31);
IkReal x586=(new_r10*sj31);
IkReal x587=((1.0)*sj32);
IkReal x588=((1.0)*x582);
IkReal x589=((1.0)*x581);
IkReal x590=(sj31*x581);
evalcond[0]=(((sj32*x582))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x581*x587)));
evalcond[2]=(((cj32*x581))+((cj31*new_r01))+x585);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x589))+(((-1.0)*new_r00*x584)));
evalcond[4]=((((-1.0)*new_r01*x584))+((cj31*new_r11))+(((-1.0)*x588)));
evalcond[5]=(((x581*x583))+((sj31*x582))+new_r01);
evalcond[6]=(((cj31*new_r00))+x586+(((-1.0)*cj32*x588)));
evalcond[7]=((((-1.0)*x583*x588))+x590+new_r00);
evalcond[8]=((((-1.0)*cj31*x588))+((cj32*x590))+new_r11);
evalcond[9]=((((-1.0)*cj31*x589))+new_r10+(((-1.0)*cj32*x582*x584)));
evalcond[10]=(((cj32*x585))+(((-1.0)*new_r21*x587))+x581+((new_r01*x583)));
evalcond[11]=(((cj32*x586))+(((-1.0)*new_r20*x587))+((new_r00*x583))+(((-1.0)*x588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x591=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x591.valid){
continue;
}
CheckValue<IkReal> x592 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x592.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x591.value)))+(x592.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x593=IKsin(j33);
IkReal x594=IKcos(j33);
IkReal x595=(cj31*cj32);
IkReal x596=((1.0)*sj31);
IkReal x597=(new_r11*sj31);
IkReal x598=(new_r10*sj31);
IkReal x599=((1.0)*sj32);
IkReal x600=((1.0)*x594);
IkReal x601=((1.0)*x593);
IkReal x602=(sj31*x593);
evalcond[0]=(((sj32*x594))+new_r20);
evalcond[1]=((((-1.0)*x593*x599))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x593))+x597);
evalcond[3]=((((-1.0)*new_r00*x596))+((cj31*new_r10))+(((-1.0)*x601)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x596))+(((-1.0)*x600)));
evalcond[5]=(((sj31*x594))+new_r01+((x593*x595)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x600))+x598);
evalcond[7]=(x602+new_r00+(((-1.0)*x595*x600)));
evalcond[8]=((((-1.0)*cj31*x600))+((cj32*x602))+new_r11);
evalcond[9]=((((-1.0)*cj32*x594*x596))+(((-1.0)*cj31*x601))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x599))+((new_r01*x595))+((cj32*x597))+x593);
evalcond[11]=((((-1.0)*new_r20*x599))+((new_r00*x595))+((cj32*x598))+(((-1.0)*x600)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(8);
vinfos[0].jointtype = 17;
vinfos[0].foffset = j12;
vinfos[0].indices[0] = _ij12[0];
vinfos[0].indices[1] = _ij12[1];
vinfos[0].maxsolutions = _nj12;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j27;
vinfos[1].indices[0] = _ij27[0];
vinfos[1].indices[1] = _ij27[1];
vinfos[1].maxsolutions = _nj27;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j28;
vinfos[2].indices[0] = _ij28[0];
vinfos[2].indices[1] = _ij28[1];
vinfos[2].maxsolutions = _nj28;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j29;
vinfos[3].indices[0] = _ij29[0];
vinfos[3].indices[1] = _ij29[1];
vinfos[3].maxsolutions = _nj29;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j30;
vinfos[4].indices[0] = _ij30[0];
vinfos[4].indices[1] = _ij30[1];
vinfos[4].maxsolutions = _nj30;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j31;
vinfos[5].indices[0] = _ij31[0];
vinfos[5].indices[1] = _ij31[1];
vinfos[5].maxsolutions = _nj31;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j32;
vinfos[6].indices[0] = _ij32[0];
vinfos[6].indices[1] = _ij32[1];
vinfos[6].maxsolutions = _nj32;
vinfos[7].jointtype = 1;
vinfos[7].foffset = j33;
vinfos[7].indices[0] = _ij33[0];
vinfos[7].indices[1] = _ij33[1];
vinfos[7].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "4f95c55204252b6edd6332624a20624c"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
