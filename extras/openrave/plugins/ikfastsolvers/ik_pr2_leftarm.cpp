#define IKFAST_NAMESPACE ik_pr2_leftarm
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2014-10-08 16:08:29.580426
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[3]);
x3=IKcos(j[3]);
x4=IKsin(j[1]);
x5=IKsin(j[2]);
x6=IKcos(j[2]);
x7=IKsin(j[0]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=IKcos(j[6]);
x13=IKsin(j[6]);
x14=((1.0)*x10);
x15=((1.0)*x9);
x16=((0.321)*x6);
x17=((1.0)*x7);
x18=((1.0)*x11);
x19=((1.0)*x6);
x20=((0.4)*x1);
x21=(x1*x2);
x22=(x0*x6);
x23=(x2*x4);
x24=(x0*x5);
x25=((-1.0)*x0);
x26=(x3*x4);
x27=((-1.0)*x3);
x28=(x4*x7);
x29=((-1.0)*x2);
x30=(x1*x3);
x31=(x30*x7);
x32=(x1*x5*x8);
x33=((1.0)*x0*x21);
x34=(x17*x21);
x35=(x19*x30);
x36=((((-1.0)*x17*x6))+((x24*x4)));
x37=((((-1.0)*x17*x4*x6))+x24);
x38=(x22+((x28*x5)));
x39=((((-1.0)*x23))+x35);
x40=((1.0)*x37);
x41=((((-1.0)*x17*x5))+(((-1.0)*x0*x19*x4)));
x42=(x36*x9);
x43=(x38*x9);
x44=(x3*x37);
x45=(((x19*x21))+(((1.0)*x26)));
x46=(x36*x8);
x47=(x2*x37);
x48=(x38*x8);
x49=(x3*x41);
x50=((-1.0)*x41);
x51=(((x1*x5*x9))+((x8*(((((-1.0)*x35))+x23)))));
x52=(((x27*x41))+x33);
x53=(x52*x9);
x54=(x43+((x8*(((((-1.0)*x21*x7))+x44)))));
x55=((((-1.0)*x18*x51))+(((-1.0)*x14*x45)));
x56=((((-1.0)*x18*(((((1.0)*x8*(((((-1.0)*x33))+x49))))+(((1.0)*x42))))))+((x14*(((((-1.0)*x25*x30))+(((-1.0)*x29*x41)))))));
eerot[0]=(((x11*((((x2*x41))+((x0*x30))))))+((x10*((((x8*((((x21*x25))+x49))))+x42)))));
eerot[1]=(((x13*x56))+((x12*((x46+x53)))));
eerot[2]=(((x12*x56))+((x13*(((((-1.0)*x46))+(((-1.0)*x53)))))));
eetrans[0]=(((x0*x20))+(((0.1)*x0))+(((0.321)*x0*x30))+((x2*(((((-0.321)*x5*x7))+(((-1.0)*x0*x16*x4)))))));
eerot[3]=(((x11*((x31+x47))))+((x10*((((x8*(((((-1.0)*x34))+x44))))+x43)))));
eerot[4]=((((-1.0)*x13*((((x14*(((((-1.0)*x17*x30))+(((-1.0)*x2*x40))))))+((x18*x54))))))+((x12*((((x9*((((x27*x37))+x34))))+x48)))));
eerot[5]=(((x12*(((((-1.0)*x11*x54))+(((-1.0)*x10*((((x29*x37))+((x1*x27*x7))))))))))+(((-1.0)*x13*((((x15*(((((-1.0)*x3*x40))+x34))))+(((1.0)*x48)))))));
eetrans[1]=((0.188)+(((0.1)*x7))+(((0.321)*x31))+((x2*(((((-1.0)*x16*x28))+(((0.321)*x24))))))+((x20*x7)));
eerot[6]=(((x10*x51))+(((-1.0)*x11*x45)));
eerot[7]=(((x13*x55))+((x12*((x32+((x39*x9)))))));
eerot[8]=(((x12*x55))+((x13*(((((-1.0)*x32))+(((-1.0)*x15*x39)))))));
eetrans[2]=((((-1.0)*x16*x21))+(((-0.4)*x4))+(((-0.321)*x26)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j15,cj15,sj15,htj15,j15mul,j16,cj16,sj16,htj16,j16mul,j18,cj18,sj18,htj18,j18mul,j19,cj19,sj19,htj19,j19mul,j20,cj20,sj20,htj20,j20mul,j21,cj21,sj21,htj21,j21mul,j17,cj17,sj17,htj17,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij15[2], _nj15,_ij16[2], _nj16,_ij18[2], _nj18,_ij19[2], _nj19,_ij20[2], _nj20,_ij21[2], _nj21,_ij17[2], _nj17;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j15=numeric_limits<IkReal>::quiet_NaN(); _ij15[0] = -1; _ij15[1] = -1; _nj15 = -1; j16=numeric_limits<IkReal>::quiet_NaN(); _ij16[0] = -1; _ij16[1] = -1; _nj16 = -1; j18=numeric_limits<IkReal>::quiet_NaN(); _ij18[0] = -1; _ij18[1] = -1; _nj18 = -1; j19=numeric_limits<IkReal>::quiet_NaN(); _ij19[0] = -1; _ij19[1] = -1; _nj19 = -1; j20=numeric_limits<IkReal>::quiet_NaN(); _ij20[0] = -1; _ij20[1] = -1; _nj20 = -1; j21=numeric_limits<IkReal>::quiet_NaN(); _ij21[0] = -1; _ij21[1] = -1; _nj21 = -1;  _ij17[0] = -1; _ij17[1] = -1; _nj17 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j17=pfree[0]; cj17=cos(pfree[0]); sj17=sin(pfree[0]), htj17=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=px;
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((-0.188)+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=pz;
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x57=((1.0)*px);
IkReal x58=((1.0)*pz);
IkReal x59=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x59))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x58)));
rxp0_2=((((-1.0)*r10*x57))+((py*r00)));
rxp1_0=((((-1.0)*r21*x59))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x58)));
rxp1_2=((((-1.0)*r11*x57))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x59)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x58)));
rxp2_2=((((-1.0)*r12*x57))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x60=((0.2)*px);
IkReal x61=((1.0)*pp);
IkReal x62=((0.509841)+x60+(((-1.0)*x61)));
IkReal x63=((-0.003759)+x60+(((-1.0)*x61)));
IkReal x64=(x60+x61);
IkReal x65=((0.509841)+(((-1.0)*x64)));
IkReal x66=((-0.003759)+(((-1.0)*x64)));
IkReal gconst0=x62;
IkReal gconst1=x63;
IkReal gconst2=x62;
IkReal gconst3=x63;
IkReal gconst4=x65;
IkReal gconst5=x66;
IkReal gconst6=x65;
IkReal gconst7=x66;
IkReal x67=py*py;
IkReal x68=sj17*sj17;
IkReal x69=px*px;
IkReal x70=((1.0)*gconst4);
IkReal x71=(gconst5*py);
IkReal x72=((4.0)*px);
IkReal x73=(gconst0*gconst3);
IkReal x74=(gconst1*gconst2);
IkReal x75=((2.0)*gconst5);
IkReal x76=((1.0)*gconst0);
IkReal x77=(gconst1*gconst7);
IkReal x78=(gconst0*gconst6);
IkReal x79=(gconst1*gconst3);
IkReal x80=(gconst4*gconst7);
IkReal x81=(gconst6*py);
IkReal x82=((2.0)*gconst0);
IkReal x83=(gconst0*gconst7);
IkReal x84=((2.0)*gconst4);
IkReal x85=(gconst3*gconst5);
IkReal x86=(gconst2*gconst5);
IkReal x87=(gconst3*gconst4);
IkReal x88=(gconst5*gconst6);
IkReal x89=(gconst2*gconst4);
IkReal x90=(gconst1*gconst6);
IkReal x91=(px*py);
IkReal x92=(gconst1*py);
IkReal x93=(gconst2*py);
IkReal x94=(gconst5*gconst7);
IkReal x95=((1.05513984)*x91);
IkReal x96=(gconst6*x67);
IkReal x97=((0.3297312)*x68);
IkReal x98=((4.0)*x69);
IkReal x99=(gconst2*x67);
IkReal x100=((2.0)*x67);
IkReal x101=((1.0)*x67);
IkReal x102=((0.824328)*x68);
IkReal x103=((0.412164)*x68);
IkReal x104=((0.1648656)*x68);
IkReal x105=(x67*x80);
IkReal x106=(x67*x88);
IkReal x107=(x67*x86);
IkReal x108=(x67*x87);
IkReal x109=(x67*x83);
IkReal x110=(x67*x90);
IkReal x111=((0.0834355125792)*py*x68);
IkReal x112=(x67*x74);
IkReal x113=(x67*x73);
IkReal x114=(x67*x68);
IkReal x115=(x103*x88);
IkReal x116=(x101*x94);
IkReal x117=(x70*x96);
IkReal x118=(py*x72*x89);
IkReal x119=(py*x72*x77);
IkReal x120=(gconst3*x71*x72);
IkReal x121=(py*x72*x78);
IkReal x122=(py*x72*x87);
IkReal x123=(py*x72*x83);
IkReal x124=(gconst2*x71*x72);
IkReal x125=(gconst1*x72*x81);
IkReal x126=(x101*x77);
IkReal x127=(x70*x99);
IkReal x128=(x103*x90);
IkReal x129=((0.06594624)*x114);
IkReal x130=(x76*x96);
IkReal x131=(x103*x86);
IkReal x132=(x101*x85);
IkReal x133=(pp*py*x97);
IkReal x134=((0.06594624)*x68*x91);
IkReal x135=(x76*x99);
IkReal x136=(x101*x79);
IkReal x137=(x103*x74);
IkReal x138=(x113+x112);
IkReal x139=(x105+x106);
IkReal x140=(x117+x116+x115);
IkReal x141=(x135+x137+x136);
IkReal x142=(x110+x108+x109+x107);
IkReal x143=(x124+x125+x122+x123);
IkReal x144=(x120+x121+x119+x118);
IkReal x145=(x131+x130+x132+x126+x127+x128+x129);
op[0]=((((-1.0)*x140))+x139);
op[1]=((((-1.0)*x111))+x134+x133+(((-1.0)*x95)));
op[2]=((((-1.0)*x145))+(((-1.0)*gconst4*gconst6*x98))+(((-1.0)*x94*x98))+(((-1.0)*x102*x88))+x142+((x88*x98))+((gconst7*x67*x75))+(((-1.0)*x100*x80))+(((-1.0)*x75*x96))+((x80*x98))+((x84*x96)));
op[3]=((((-1.0)*x144))+((gconst7*x71*x72))+(((-1.0)*x71*x97))+(((-1.0)*py*x72*x80))+x143+(((-1.0)*gconst6*x71*x72))+((gconst4*x72*x81))+(((-1.0)*x81*x97))+(((-1.0)*x104*x93))+(((-1.0)*x104*x92)));
op[4]=((((-1.0)*x141))+(((-1.0)*x140))+((x87*x98))+(((-1.0)*x102*x90))+(((-1.0)*x102*x86))+((x100*x78))+((x100*x77))+(((-1.0)*x77*x98))+(((-0.13189248)*x114))+((x86*x98))+x139+x138+(((-1.0)*x78*x98))+((gconst3*x67*x75))+((x90*x98))+(((-1.0)*gconst3*x67*x84))+(((-1.0)*x100*x90))+(((-1.0)*x75*x99))+((x83*x98))+((x84*x99))+(((-1.0)*x89*x98))+(((-1.0)*gconst7*x67*x82))+(((-1.0)*x85*x98)));
op[5]=((((-1.0)*py*x72*x79))+(((-1.0)*x143))+((py*x72*x74))+((py*x72*x73))+x144+(((-1.0)*gconst0*x72*x93))+(((-1.0)*x92*x97))+(((-1.0)*x104*x71))+(((-1.0)*x104*x81))+(((-1.0)*x93*x97)));
op[6]=((((-1.0)*x145))+(((-1.0)*gconst0*gconst2*x98))+((x82*x99))+((x100*x79))+((x73*x98))+x142+((x74*x98))+(((-1.0)*x79*x98))+(((-1.0)*x100*x73))+(((-1.0)*x100*x74))+(((-1.0)*x102*x74)));
op[7]=((((-1.0)*x111))+x133+(((-1.0)*x134))+x95);
op[8]=((((-1.0)*x141))+x138);
polyroots8(op,zeror,numroots);
IkReal j15array[8], cj15array[8], sj15array[8], tempj15array[1];
int numsolutions = 0;
for(int ij15 = 0; ij15 < numroots; ++ij15)
{
IkReal htj15 = zeror[ij15];
tempj15array[0]=((2.0)*(atan(htj15)));
for(int kj15 = 0; kj15 < 1; ++kj15)
{
j15array[numsolutions] = tempj15array[kj15];
if( j15array[numsolutions] > IKPI )
{
    j15array[numsolutions]-=IK2PI;
}
else if( j15array[numsolutions] < -IKPI )
{
    j15array[numsolutions]+=IK2PI;
}
sj15array[numsolutions] = IKsin(j15array[numsolutions]);
cj15array[numsolutions] = IKcos(j15array[numsolutions]);
numsolutions++;
}
}
bool j15valid[8]={true,true,true,true,true,true,true,true};
_nj15 = 8;
for(int ij15 = 0; ij15 < numsolutions; ++ij15)
    {
if( !j15valid[ij15] )
{
    continue;
}
    j15 = j15array[ij15]; cj15 = cj15array[ij15]; sj15 = sj15array[ij15];
htj15 = IKtan(j15/2);

_ij15[0] = ij15; _ij15[1] = -1;
for(int iij15 = ij15+1; iij15 < numsolutions; ++iij15)
{
if( j15valid[iij15] && IKabs(cj15array[ij15]-cj15array[iij15]) < IKFAST_SOLUTION_THRESH && IKabs(sj15array[ij15]-sj15array[iij15]) < IKFAST_SOLUTION_THRESH )
{
    j15valid[iij15]=false; _ij15[1] = iij15; break; 
}
}
{
IkReal j16eval[2];
IkReal x146=py*py;
IkReal x147=cj15*cj15;
IkReal x148=px*px;
IkReal x149=pz*pz;
IkReal x150=((4.0)*sj17);
IkReal x151=((20.0)*sj17);
IkReal x152=(py*sj15);
IkReal x153=(cj15*px);
IkReal x154=((100.0)*sj17);
IkReal x155=((0.8)*sj17);
IkReal x156=(x146*x147);
IkReal x157=(x147*x148);
j16eval[0]=((((-1.0)*x154*x157))+(((-200.0)*sj17*x152*x153))+((x151*x152))+((x151*x153))+((x154*x156))+(((-1.0)*sj17))+(((-1.0)*x146*x154))+(((-1.0)*x149*x154)));
j16eval[1]=IKsign((((x153*x155))+((x150*x156))+((x152*x155))+(((-1.0)*x150*x157))+(((-1.0)*x146*x150))+(((-1.0)*x149*x150))+(((-8.0)*sj17*x152*x153))+(((-0.04)*sj17))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x158=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x158;
evalcond[2]=x158;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal j16eval[3];
sj17=0;
cj17=1.0;
j17=0;
IkReal x159=((321000.0)*sj18);
IkReal x160=(py*sj15);
IkReal x161=((321000.0)*cj18);
IkReal x162=(cj15*px);
j16eval[0]=((1.02430295950156)+cj18);
j16eval[1]=IKsign(((263041.0)+(((256800.0)*cj18))));
j16eval[2]=((IKabs(((-40000.0)+((x161*x162))+(((400000.0)*x160))+(((400000.0)*x162))+(((-1.0)*pz*x159))+(((-32100.0)*cj18))+((x160*x161)))))+(IKabs(((((-1.0)*x159*x162))+(((-1.0)*x159*x160))+(((-1.0)*pz*x161))+(((-400000.0)*pz))+(((32100.0)*sj18))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=1.0;
j17=0;
IkReal x163=(cj15*px);
IkReal x164=((1000.0)*pz);
IkReal x165=(py*sj15);
IkReal x166=((10.0)*cj18);
IkReal x167=((321.0)*cj18);
IkReal x168=(pz*sj18);
j16eval[0]=((1.24610591900312)+(((-1.0)*x163*x166))+cj18+(((-1.0)*x165*x166))+(((-10.0)*x168))+(((-12.4610591900312)*x165))+(((-12.4610591900312)*x163)));
j16eval[1]=IKsign(((40.0)+(((-400.0)*x163))+(((-400.0)*x165))+(((-1.0)*x163*x167))+(((32.1)*cj18))+(((-321.0)*x168))+(((-1.0)*x165*x167))));
j16eval[2]=((IKabs(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x164*x165))+(((128.4)*sj18))+((x163*x164)))))+(IKabs(((-160.0)+((pz*x164))+(((-256.8)*cj18))+(((-103.041)*(cj18*cj18)))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=1.0;
j17=0;
IkReal x169=cj15*cj15;
IkReal x170=py*py;
IkReal x171=px*px;
IkReal x172=pz*pz;
IkReal x173=(py*sj15);
IkReal x174=((321.0)*sj18);
IkReal x175=(cj15*px);
IkReal x176=((321.0)*cj18);
IkReal x177=((100.0)*x169);
IkReal x178=((1000.0)*x169);
j16eval[0]=((-1.0)+(((-100.0)*x172))+(((-100.0)*x170))+(((20.0)*x175))+(((20.0)*x173))+(((-1.0)*x171*x177))+((x170*x177))+(((-200.0)*x173*x175)));
j16eval[1]=IKsign(((-10.0)+(((-1000.0)*x170))+(((-1000.0)*x172))+(((-1.0)*x171*x178))+((x170*x178))+(((-2000.0)*x173*x175))+(((200.0)*x173))+(((200.0)*x175))));
j16eval[2]=((IKabs(((40.0)+((pz*x174))+(((-1.0)*x175*x176))+(((-400.0)*x175))+(((-400.0)*x173))+(((32.1)*cj18))+(((-1.0)*x173*x176)))))+(IKabs((((pz*x176))+((x173*x174))+(((400.0)*pz))+((x174*x175))+(((-32.1)*sj18))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x179=py*py;
IkReal x180=cj15*cj15;
IkReal x181=(py*sj15);
IkReal x182=((321.0)*sj18);
IkReal x183=(cj15*px);
IkReal x184=((321.0)*cj18);
IkReal x185=((1000.0)*x180);
CheckValue<IkReal> x186 = IKatan2WithCheck(IkReal((((pz*x184))+(((400.0)*pz))+(((-32.1)*sj18))+((x182*x183))+((x181*x182)))),((40.0)+((pz*x182))+(((-400.0)*x183))+(((-400.0)*x181))+(((32.1)*cj18))+(((-1.0)*x183*x184))+(((-1.0)*x181*x184))),IKFAST_ATAN2_MAGTHRESH);
if(!x186.valid){
continue;
}
CheckValue<IkReal> x187=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*(pz*pz)))+((x179*x185))+(((-1000.0)*x179))+(((200.0)*x181))+(((200.0)*x183))+(((-2000.0)*x181*x183))+(((-1.0)*x185*(px*px))))),-1);
if(!x187.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x186.value)+(((1.5707963267949)*(x187.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x188=IKsin(j16);
IkReal x189=IKcos(j16);
IkReal x190=((0.321)*sj18);
IkReal x191=((0.321)*cj18);
IkReal x192=(py*sj15);
IkReal x193=(cj15*px);
IkReal x194=(pz*x188);
IkReal x195=(x189*x193);
evalcond[0]=((((0.4)*x188))+((x188*x191))+((x189*x190))+pz);
evalcond[1]=(((pz*x189))+((x188*x193))+((x188*x192))+x190+(((-0.1)*x188)));
evalcond[2]=((0.1)+(((0.4)*x189))+(((-1.0)*x188*x190))+(((-1.0)*x192))+(((-1.0)*x193))+((x189*x191)));
evalcond[3]=((0.4)+(((0.1)*x189))+(((-1.0)*x195))+(((-1.0)*x189*x192))+x191+x194);
evalcond[4]=((-0.066959)+(((0.2)*x193))+(((0.2)*x192))+(((0.8)*x189*x192))+(((-1.0)*pp))+(((0.8)*x195))+(((-0.08)*x189))+(((-0.8)*x194)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x661=(cj15*px);
IkReal x662=((1000.0)*pz);
IkReal x663=((321.0)*cj18);
IkReal x664=(py*sj15);
CheckValue<IkReal> x665=IKPowWithIntegerCheck(IKsign(((40.0)+(((-321.0)*pz*sj18))+(((-1.0)*x663*x664))+(((32.1)*cj18))+(((-1.0)*x661*x663))+(((-400.0)*x664))+(((-400.0)*x661)))),-1);
if(!x665.valid){
continue;
}
CheckValue<IkReal> x666 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+(((103.041)*cj18*sj18))+((x662*x664))+((x661*x662))+(((128.4)*sj18)))),((-160.0)+(((-256.8)*cj18))+((pz*x662))+(((-103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x666.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x665.value)))+(x666.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x667=IKsin(j16);
IkReal x668=IKcos(j16);
IkReal x669=((0.321)*sj18);
IkReal x670=((0.321)*cj18);
IkReal x671=(py*sj15);
IkReal x672=(cj15*px);
IkReal x673=(pz*x667);
IkReal x674=(x668*x672);
evalcond[0]=(((x668*x669))+(((0.4)*x667))+((x667*x670))+pz);
evalcond[1]=(((x667*x671))+((x667*x672))+((pz*x668))+x669+(((-0.1)*x667)));
evalcond[2]=((0.1)+(((0.4)*x668))+((x668*x670))+(((-1.0)*x671))+(((-1.0)*x672))+(((-1.0)*x667*x669)));
evalcond[3]=((0.4)+(((0.1)*x668))+x673+x670+(((-1.0)*x674))+(((-1.0)*x668*x671)));
evalcond[4]=((-0.066959)+(((-0.08)*x668))+(((0.8)*x674))+(((0.2)*x671))+(((0.2)*x672))+(((-1.0)*pp))+(((-0.8)*x673))+(((0.8)*x668*x671)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x675=((321000.0)*sj18);
IkReal x676=(py*sj15);
IkReal x677=((321000.0)*cj18);
IkReal x678=(cj15*px);
CheckValue<IkReal> x679=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj18)))),-1);
if(!x679.valid){
continue;
}
CheckValue<IkReal> x680 = IKatan2WithCheck(IkReal(((((-1.0)*x675*x676))+(((-1.0)*x675*x678))+(((-1.0)*pz*x677))+(((-400000.0)*pz))+(((32100.0)*sj18)))),((-40000.0)+((x676*x677))+((x677*x678))+(((-1.0)*pz*x675))+(((-32100.0)*cj18))+(((400000.0)*x676))+(((400000.0)*x678))),IKFAST_ATAN2_MAGTHRESH);
if(!x680.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x679.value)))+(x680.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x681=IKsin(j16);
IkReal x682=IKcos(j16);
IkReal x683=((0.321)*sj18);
IkReal x684=((0.321)*cj18);
IkReal x685=(py*sj15);
IkReal x686=(cj15*px);
IkReal x687=(pz*x681);
IkReal x688=(x682*x686);
evalcond[0]=(((x682*x683))+pz+((x681*x684))+(((0.4)*x681)));
evalcond[1]=((((-0.1)*x681))+((x681*x686))+((x681*x685))+x683+((pz*x682)));
evalcond[2]=((0.1)+(((-1.0)*x681*x683))+((x682*x684))+(((0.4)*x682))+(((-1.0)*x685))+(((-1.0)*x686)));
evalcond[3]=((0.4)+x687+x684+(((0.1)*x682))+(((-1.0)*x688))+(((-1.0)*x682*x685)));
evalcond[4]=((-0.066959)+(((0.2)*x686))+(((0.2)*x685))+(((-0.08)*x682))+(((-1.0)*pp))+(((0.8)*x688))+(((0.8)*x682*x685))+(((-0.8)*x687)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x689=(cj15*py);
IkReal x690=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x690+(((-1.0)*x689)));
evalcond[2]=(x689+(((-1.0)*x690)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[2], cj18array[2], sj18array[2];
bool j18valid[2]={false};
_nj18 = 2;
cj18array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)));
if( cj18array[0] >= -1-IKFAST_SINCOS_THRESH && cj18array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j18valid[0] = j18valid[1] = true;
    j18array[0] = IKacos(cj18array[0]);
    sj18array[0] = IKsin(j18array[0]);
    cj18array[1] = cj18array[0];
    j18array[1] = -j18array[0];
    sj18array[1] = -sj18array[0];
}
else if( isnan(cj18array[0]) )
{
    // probably any value will work
    j18valid[0] = true;
    cj18array[0] = 1; sj18array[0] = 0; j18array[0] = 0;
}
for(int ij18 = 0; ij18 < 2; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 2; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];

{
IkReal j16eval[3];
sj17=0;
cj17=-1.0;
j17=3.14159265358979;
IkReal x691=((321000.0)*pz);
IkReal x692=((321000.0)*py*sj15);
IkReal x693=((321000.0)*cj15*px);
j16eval[0]=((-1.02430295950156)+(((-1.0)*cj18)));
j16eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj18))));
j16eval[2]=((IKabs(((40000.0)+(((-1.0)*sj18*x691))+(((32100.0)*cj18))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))+(((-1.0)*cj18*x692))+(((-1.0)*cj18*x693)))))+(IKabs((((cj18*x691))+(((-1.0)*sj18*x693))+(((-1.0)*sj18*x692))+(((400000.0)*pz))+(((32100.0)*sj18))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=-1.0;
j17=3.14159265358979;
IkReal x694=(cj15*px);
IkReal x695=((1000.0)*pz);
IkReal x696=(py*sj15);
IkReal x697=((10.0)*cj18);
IkReal x698=((321.0)*cj18);
IkReal x699=(pz*sj18);
j16eval[0]=((-1.24610591900312)+(((12.4610591900312)*x696))+(((12.4610591900312)*x694))+((x694*x697))+(((-10.0)*x699))+((x696*x697))+(((-1.0)*cj18)));
j16eval[1]=((IKabs(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*x695*x696))+(((-1.0)*x694*x695))+(((128.4)*sj18)))))+(IKabs(((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x695))+(((103.041)*(cj18*cj18)))))));
j16eval[2]=IKsign(((-40.0)+(((400.0)*x696))+(((400.0)*x694))+((x694*x698))+((x696*x698))+(((-32.1)*cj18))+(((-321.0)*x699))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
sj17=0;
cj17=-1.0;
j17=3.14159265358979;
IkReal x700=cj15*cj15;
IkReal x701=py*py;
IkReal x702=px*px;
IkReal x703=pz*pz;
IkReal x704=(py*sj15);
IkReal x705=((321.0)*cj18);
IkReal x706=(cj15*px);
IkReal x707=((321.0)*sj18);
IkReal x708=(x700*x702);
IkReal x709=(x700*x701);
j16eval[0]=((-1.0)+(((20.0)*x704))+(((20.0)*x706))+(((-100.0)*x703))+(((-100.0)*x708))+(((-100.0)*x701))+(((100.0)*x709))+(((-200.0)*x704*x706)));
j16eval[1]=IKsign(((-10.0)+(((1000.0)*x709))+(((-1000.0)*x708))+(((-1000.0)*x703))+(((-1000.0)*x701))+(((-2000.0)*x704*x706))+(((200.0)*x706))+(((200.0)*x704))));
j16eval[2]=((IKabs(((((-1.0)*x706*x707))+(((32.1)*sj18))+(((400.0)*pz))+(((-1.0)*x704*x707))+((pz*x705)))))+(IKabs(((40.0)+(((-1.0)*pz*x707))+(((-400.0)*x706))+(((-400.0)*x704))+(((32.1)*cj18))+(((-1.0)*x704*x705))+(((-1.0)*x705*x706))))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j16]

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x710=py*py;
IkReal x711=cj15*cj15;
IkReal x712=(py*sj15);
IkReal x713=((321.0)*sj18);
IkReal x714=(cj15*px);
IkReal x715=((321.0)*cj18);
IkReal x716=((1000.0)*x711);
CheckValue<IkReal> x717=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1.0)*x716*(px*px)))+(((-1000.0)*(pz*pz)))+((x710*x716))+(((-1000.0)*x710))+(((-2000.0)*x712*x714))+(((200.0)*x712))+(((200.0)*x714)))),-1);
if(!x717.valid){
continue;
}
CheckValue<IkReal> x718 = IKatan2WithCheck(IkReal(((((32.1)*sj18))+(((400.0)*pz))+(((-1.0)*x712*x713))+(((-1.0)*x713*x714))+((pz*x715)))),((40.0)+(((-1.0)*x714*x715))+(((-1.0)*pz*x713))+(((-400.0)*x714))+(((-400.0)*x712))+(((32.1)*cj18))+(((-1.0)*x712*x715))),IKFAST_ATAN2_MAGTHRESH);
if(!x718.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x717.value)))+(x718.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x719=IKsin(j16);
IkReal x720=IKcos(j16);
IkReal x721=((0.321)*sj18);
IkReal x722=((0.321)*cj18);
IkReal x723=(cj15*px);
IkReal x724=(py*sj15);
IkReal x725=(pz*x719);
IkReal x726=((1.0)*x719);
IkReal x727=((1.0)*x720);
IkReal x728=(x720*x723);
evalcond[0]=((((0.4)*x719))+pz+(((-1.0)*x720*x721))+((x719*x722)));
evalcond[1]=((0.1)+((x720*x722))+(((-1.0)*x723))+(((-1.0)*x724))+((x719*x721))+(((0.4)*x720)));
evalcond[2]=((0.4)+(((-1.0)*x724*x727))+(((-1.0)*x723*x727))+(((0.1)*x720))+x722+x725);
evalcond[3]=((((-1.0)*x724*x726))+(((-1.0)*x723*x726))+(((0.1)*x719))+x721+(((-1.0)*pz*x727)));
evalcond[4]=((-0.066959)+(((0.8)*x728))+(((-0.08)*x720))+(((0.8)*x720*x724))+(((-1.0)*pp))+(((-0.8)*x725))+(((0.2)*x723))+(((0.2)*x724)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x729=(cj15*px);
IkReal x730=((1000.0)*pz);
IkReal x731=((321.0)*cj18);
IkReal x732=(py*sj15);
CheckValue<IkReal> x733=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x729))+((x731*x732))+(((-321.0)*pz*sj18))+(((400.0)*x732))+((x729*x731))+(((-32.1)*cj18)))),-1);
if(!x733.valid){
continue;
}
CheckValue<IkReal> x734 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((103.041)*cj18*sj18))+(((-1.0)*x730*x732))+(((128.4)*sj18))+(((-1.0)*x729*x730)))),((160.0)+(((256.8)*cj18))+(((-1.0)*pz*x730))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x734.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x733.value)))+(x734.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x735=IKsin(j16);
IkReal x736=IKcos(j16);
IkReal x737=((0.321)*sj18);
IkReal x738=((0.321)*cj18);
IkReal x739=(cj15*px);
IkReal x740=(py*sj15);
IkReal x741=(pz*x735);
IkReal x742=((1.0)*x735);
IkReal x743=((1.0)*x736);
IkReal x744=(x736*x739);
evalcond[0]=((((0.4)*x735))+(((-1.0)*x736*x737))+((x735*x738))+pz);
evalcond[1]=((0.1)+(((0.4)*x736))+((x735*x737))+((x736*x738))+(((-1.0)*x739))+(((-1.0)*x740)));
evalcond[2]=((0.4)+(((0.1)*x736))+(((-1.0)*x740*x743))+x738+x741+(((-1.0)*x739*x743)));
evalcond[3]=((((-1.0)*pz*x743))+(((0.1)*x735))+(((-1.0)*x740*x742))+x737+(((-1.0)*x739*x742)));
evalcond[4]=((-0.066959)+(((-0.08)*x736))+(((0.8)*x744))+(((-1.0)*pp))+(((0.8)*x736*x740))+(((0.2)*x740))+(((-0.8)*x741))+(((0.2)*x739)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x745=((321000.0)*pz);
IkReal x746=((321000.0)*py*sj15);
IkReal x747=((321000.0)*cj15*px);
CheckValue<IkReal> x748=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj18)))),-1);
if(!x748.valid){
continue;
}
CheckValue<IkReal> x749 = IKatan2WithCheck(IkReal(((((400000.0)*pz))+(((-1.0)*sj18*x747))+(((-1.0)*sj18*x746))+(((32100.0)*sj18))+((cj18*x745)))),((40000.0)+(((32100.0)*cj18))+(((-1.0)*cj18*x746))+(((-1.0)*cj18*x747))+(((-1.0)*sj18*x745))+(((-400000.0)*cj15*px))+(((-400000.0)*py*sj15))),IKFAST_ATAN2_MAGTHRESH);
if(!x749.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x748.value)))+(x749.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x750=IKsin(j16);
IkReal x751=IKcos(j16);
IkReal x752=((0.321)*sj18);
IkReal x753=((0.321)*cj18);
IkReal x754=(cj15*px);
IkReal x755=(py*sj15);
IkReal x756=(pz*x750);
IkReal x757=((1.0)*x750);
IkReal x758=((1.0)*x751);
IkReal x759=(x751*x754);
evalcond[0]=((((-1.0)*x751*x752))+pz+(((0.4)*x750))+((x750*x753)));
evalcond[1]=((0.1)+((x751*x753))+(((-1.0)*x755))+(((-1.0)*x754))+(((0.4)*x751))+((x750*x752)));
evalcond[2]=((0.4)+(((0.1)*x751))+(((-1.0)*x754*x758))+(((-1.0)*x755*x758))+x756+x753);
evalcond[3]=((((0.1)*x750))+(((-1.0)*x754*x757))+(((-1.0)*x755*x757))+x752+(((-1.0)*pz*x758)));
evalcond[4]=((-0.066959)+(((0.8)*x759))+(((-0.08)*x751))+(((0.2)*x754))+(((0.2)*x755))+(((-1.0)*pp))+(((-0.8)*x756))+(((0.8)*x751*x755)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16, j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x760=IKPowWithIntegerCheck(sj17,-1);
if(!x760.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x760.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x760.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x760.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[2];
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj17*(IKsin(j18)))));
evalcond[1]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*(IKcos(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j16eval[3];
IkReal x761=(cj15*px);
IkReal x762=((1000.0)*pz);
IkReal x763=(py*sj15);
IkReal x764=((10.0)*cj18);
IkReal x765=((321.0)*cj18);
IkReal x766=(cj17*sj18);
IkReal x767=(pz*x766);
j16eval[0]=((-1.24610591900312)+(((12.4610591900312)*x763))+(((12.4610591900312)*x761))+((x761*x764))+((x763*x764))+(((-1.0)*cj18))+(((10.0)*x767)));
j16eval[1]=((IKabs(((((-1.0)*x762*x763))+(((100.0)*pz))+(((-128.4)*x766))+(((-103.041)*cj18*x766))+(((-1.0)*x761*x762)))))+(IKabs(((160.0)+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))+(((-1.0)*pz*x762))))));
j16eval[2]=IKsign(((-40.0)+(((400.0)*x763))+(((400.0)*x761))+((x761*x765))+((x763*x765))+(((-32.1)*cj18))+(((321.0)*x767))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[3];
IkReal x768=cj17*cj17;
IkReal x769=cj18*cj18;
IkReal x770=(cj15*px);
IkReal x771=(py*sj15);
IkReal x772=((321000.0)*cj18);
IkReal x773=((321000.0)*cj17*sj18);
IkReal x774=((103041.0)*x769);
j16eval[0]=((1.5527799613746)+(((2.49221183800623)*cj18))+(((-1.0)*x768*x769))+x768+x769);
j16eval[1]=((IKabs(((-40000.0)+((x771*x772))+((x770*x772))+(((-32100.0)*cj18))+(((-1.0)*pz*x773))+(((400000.0)*x771))+(((400000.0)*x770)))))+(IKabs(((((32100.0)*cj17*sj18))+(((-1.0)*x771*x773))+(((-400000.0)*pz))+(((-1.0)*pz*x772))+(((-1.0)*x770*x773))))));
j16eval[2]=IKsign(((160000.0)+(((-1.0)*x768*x774))+(((256800.0)*cj18))+(((103041.0)*x768))+x774));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  || IKabs(j16eval[2]) < 0.0000010000000000  )
{
{
IkReal j16eval[2];
IkReal x775=(cj17*sj18);
IkReal x776=(py*sj15);
IkReal x777=(cj18*pz);
IkReal x778=(cj15*px);
j16eval[0]=((((-10.0)*x775*x776))+(((-10.0)*x775*x778))+x775+(((10.0)*x777))+(((12.4610591900312)*pz)));
j16eval[1]=IKsign(((((400.0)*pz))+(((32.1)*x775))+(((-321.0)*x775*x778))+(((-321.0)*x775*x776))+(((321.0)*x777))));
if( IKabs(j16eval[0]) < 0.0000010000000000  || IKabs(j16eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x779=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*sj18)));
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j17), 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=x779;
evalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));
evalcond[3]=x779;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
IkReal x780=((-1.0)*py);
pz=0;
j17=1.5707963267949;
sj17=1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x780);
rxp0_1=(px*r20);
rxp1_0=(r21*x780);
rxp1_1=(px*r21);
rxp2_0=(r22*x780);
rxp2_1=(px*r22);
j16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x781=((-1.0)*py);
pz=0;
j17=1.5707963267949;
sj17=1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x781);
rxp0_1=(px*r20);
rxp1_0=(r21*x781);
rxp1_1=(px*r21);
rxp2_0=(r22*x781);
rxp2_1=(px*r22);
j16eval[0]=((1.24610591900312)+cj18);
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x782=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x782) < -0.00001)
continue;
IkReal x783=IKabs(IKsqrt(x782));
IkReal x789 = x782;
if(IKabs(x789)==0){
continue;
}
IkReal x784=pow(x789,-0.5);
CheckValue<IkReal> x790=IKPowWithIntegerCheck(x783,-1);
if(!x790.valid){
continue;
}
IkReal x785=x790.value;
IkReal x786=((10.0)*px*x784);
IkReal x787=((10.0)*py*x784);
if((((1.0)+(((-1.0)*(x785*x785))))) < -0.00001)
continue;
IkReal x788=IKsqrt(((1.0)+(((-1.0)*(x785*x785)))));
if( (x785) < -1-IKFAST_SINCOS_THRESH || (x785) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x791 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x791.valid){
continue;
}
IkReal gconst24=((((-1.0)*(IKasin(x785))))+(((-1.0)*(x791.value))));
IkReal gconst25=(((x786*x788))+((x785*x787)));
IkReal gconst26=(((x785*x786))+(((-1.0)*x787*x788)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x792=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x792.valid){
continue;
}
if( (x792.value) < -1-IKFAST_SINCOS_THRESH || (x792.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x793 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x793.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x792.value))+j15+(x793.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x795=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);
if(!x795.valid){
continue;
}
IkReal x794=x795.value;
cj16array[0]=((((-0.321)*cj18*x794))+(((-0.4)*x794)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x796=IKsin(j16);
IkReal x797=IKcos(j16);
IkReal x798=(gconst26*px);
IkReal x799=(gconst25*py);
IkReal x800=((0.321)*cj18);
IkReal x801=((0.8)*x797);
IkReal x802=((1.0)*x796);
evalcond[0]=((((0.4)*x796))+((x796*x800)));
evalcond[1]=((((-1.0)*x798*x802))+(((-1.0)*x799*x802))+(((0.1)*x796)));
evalcond[2]=((0.1)+((x797*x800))+(((-1.0)*x799))+(((-1.0)*x798))+(((0.4)*x797)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x797))+(((0.2)*x799))+(((0.2)*x798))+((x798*x801))+((x799*x801))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x803=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x810 = x803;
if(IKabs(x810)==0){
continue;
}
IkReal x804=pow(x810,-0.5);
if((x803) < -0.00001)
continue;
IkReal x805=IKabs(IKsqrt(x803));
CheckValue<IkReal> x811=IKPowWithIntegerCheck(x805,-1);
if(!x811.valid){
continue;
}
IkReal x806=x811.value;
IkReal x807=((10.0)*px*x804);
IkReal x808=((10.0)*py*x804);
if((((1.0)+(((-1.0)*(x806*x806))))) < -0.00001)
continue;
IkReal x809=IKsqrt(((1.0)+(((-1.0)*(x806*x806)))));
CheckValue<IkReal> x812 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x812.valid){
continue;
}
if( (x806) < -1-IKFAST_SINCOS_THRESH || (x806) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst27=((3.14159265358979)+(((-1.0)*(x812.value)))+(IKasin(x806)));
IkReal gconst28=((((-1.0)*x807*x809))+((x806*x808)));
IkReal gconst29=(((x806*x807))+((x808*x809)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x813.valid){
continue;
}
if( (x813.value) < -1-IKFAST_SINCOS_THRESH || (x813.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x814 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x814.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x813.value))))+j15+(x814.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x816=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);
if(!x816.valid){
continue;
}
IkReal x815=x816.value;
cj16array[0]=((((-0.321)*cj18*x815))+(((-0.4)*x815)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x817=IKsin(j16);
IkReal x818=IKcos(j16);
IkReal x819=(gconst29*px);
IkReal x820=((0.321)*cj18);
IkReal x821=(gconst28*py);
IkReal x822=((1.0)*x817);
IkReal x823=((0.8)*x818);
evalcond[0]=(((x817*x820))+(((0.4)*x817)));
evalcond[1]=((((-1.0)*x819*x822))+(((-1.0)*x821*x822))+(((0.1)*x817)));
evalcond[2]=((0.1)+(((0.4)*x818))+(((-1.0)*x819))+(((-1.0)*x821))+((x818*x820)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x821*x823))+((x819*x823))+(((0.2)*x819))+(((-1.0)*(py*py)))+(((0.2)*x821))+(((-0.08)*x818)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x825=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);
if(!x825.valid){
continue;
}
IkReal x824=x825.value;
cj16array[0]=((((-0.1)*x824))+((py*sj15*x824))+((cj15*px*x824)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x826=IKsin(j16);
IkReal x827=IKcos(j16);
IkReal x828=(cj15*px);
IkReal x829=((0.321)*cj18);
IkReal x830=(py*sj15);
IkReal x831=((1.0)*x830);
IkReal x832=((0.8)*x827);
evalcond[0]=((((0.4)*x826))+((x826*x829)));
evalcond[1]=((((0.1)*x826))+(((-1.0)*x826*x831))+(((-1.0)*x826*x828)));
evalcond[2]=((0.4)+(((0.1)*x827))+(((-1.0)*x827*x831))+x829+(((-1.0)*x827*x828)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x827))+((x830*x832))+(((0.2)*x830))+((x828*x832))+(((-1.0)*(py*py)))+(((0.2)*x828)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x834=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);
if(!x834.valid){
continue;
}
IkReal x833=x834.value;
cj16array[0]=((((-0.4)*x833))+(((-0.321)*cj18*x833)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x835=IKsin(j16);
IkReal x836=IKcos(j16);
IkReal x837=(py*sj15);
IkReal x838=((0.321)*cj18);
IkReal x839=(cj15*px);
IkReal x840=((1.0)*x835);
IkReal x841=((0.8)*x836);
evalcond[0]=((((0.4)*x835))+((x835*x838)));
evalcond[1]=((((-1.0)*x837*x840))+(((0.1)*x835))+(((-1.0)*x839*x840)));
evalcond[2]=((0.1)+(((0.4)*x836))+((x836*x838))+(((-1.0)*x837))+(((-1.0)*x839)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((-0.08)*x836))+((x839*x841))+((x837*x841))+(((0.2)*x839))+(((0.2)*x837))+(((-1.0)*(py*py))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x842=((0.321)*sj18);
IkReal x843=(cj15*py);
IkReal x844=(px*sj15);
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j17), 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=((((-1.0)*x842))+(((-1.0)*x843))+x844);
evalcond[2]=((0.253041)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2568)*cj18)));
evalcond[3]=((((-1.0)*x844))+x843+x842);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16eval[1];
IkReal x845=((-1.0)*py);
pz=0;
j17=-1.5707963267949;
sj17=-1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x845);
rxp0_1=(px*r20);
rxp1_0=(r21*x845);
rxp1_1=(px*r21);
rxp2_0=(r22*x845);
rxp2_1=(px*r22);
j16eval[0]=((1.0)+(((-10.0)*cj15*px))+(((-10.0)*py*sj15)));
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal j16eval[1];
IkReal x846=((-1.0)*py);
pz=0;
j17=-1.5707963267949;
sj17=-1.0;
cj17=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x846);
rxp0_1=(px*r20);
rxp1_0=(r21*x846);
rxp1_1=(px*r21);
rxp2_0=(r22*x846);
rxp2_1=(px*r22);
j16eval[0]=((1.24610591900312)+cj18);
if( IKabs(j16eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x847=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x847) < -0.00001)
continue;
IkReal x848=IKabs(IKsqrt(x847));
IkReal x854 = x847;
if(IKabs(x854)==0){
continue;
}
IkReal x849=pow(x854,-0.5);
CheckValue<IkReal> x855=IKPowWithIntegerCheck(x848,-1);
if(!x855.valid){
continue;
}
IkReal x850=x855.value;
IkReal x851=((10.0)*px*x849);
IkReal x852=((10.0)*py*x849);
if((((1.0)+(((-1.0)*(x850*x850))))) < -0.00001)
continue;
IkReal x853=IKsqrt(((1.0)+(((-1.0)*(x850*x850)))));
CheckValue<IkReal> x856 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x856.valid){
continue;
}
if( (x850) < -1-IKFAST_SINCOS_THRESH || (x850) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst30=((((-1.0)*(x856.value)))+(((-1.0)*(IKasin(x850)))));
IkReal gconst31=(((x850*x852))+((x851*x853)));
IkReal gconst32=(((x850*x851))+(((-1.0)*x852*x853)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x857=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x857.valid){
continue;
}
if( (x857.value) < -1-IKFAST_SINCOS_THRESH || (x857.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x858 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x858.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x857.value))+j15+(x858.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x860=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);
if(!x860.valid){
continue;
}
IkReal x859=x860.value;
cj16array[0]=((((-0.321)*cj18*x859))+(((-0.4)*x859)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x861=IKsin(j16);
IkReal x862=IKcos(j16);
IkReal x863=(gconst32*px);
IkReal x864=(gconst31*py);
IkReal x865=((0.321)*cj18);
IkReal x866=((0.8)*x862);
evalcond[0]=(((x861*x865))+(((0.4)*x861)));
evalcond[1]=((((-0.1)*x861))+((x861*x863))+((x861*x864)));
evalcond[2]=((0.1)+(((-1.0)*x863))+(((-1.0)*x864))+((x862*x865))+(((0.4)*x862)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x864))+(((0.2)*x863))+((x863*x866))+((x864*x866))+(((-1.0)*(py*py)))+(((-0.08)*x862)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x867=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x874 = x867;
if(IKabs(x874)==0){
continue;
}
IkReal x868=pow(x874,-0.5);
if((x867) < -0.00001)
continue;
IkReal x869=IKabs(IKsqrt(x867));
CheckValue<IkReal> x875=IKPowWithIntegerCheck(x869,-1);
if(!x875.valid){
continue;
}
IkReal x870=x875.value;
IkReal x871=((10.0)*px*x868);
IkReal x872=((10.0)*py*x868);
if((((1.0)+(((-1.0)*(x870*x870))))) < -0.00001)
continue;
IkReal x873=IKsqrt(((1.0)+(((-1.0)*(x870*x870)))));
if( (x870) < -1-IKFAST_SINCOS_THRESH || (x870) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x876 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x876.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(IKasin(x870))+(((-1.0)*(x876.value))));
IkReal gconst34=(((x870*x872))+(((-1.0)*x871*x873)));
IkReal gconst35=(((x872*x873))+((x870*x871)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x877=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x877.valid){
continue;
}
if( (x877.value) < -1-IKFAST_SINCOS_THRESH || (x877.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x878 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x878.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x877.value))))+j15+(x878.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x880=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);
if(!x880.valid){
continue;
}
IkReal x879=x880.value;
cj16array[0]=((((-0.4)*x879))+(((-0.321)*cj18*x879)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x881=IKsin(j16);
IkReal x882=IKcos(j16);
IkReal x883=(gconst34*py);
IkReal x884=(gconst35*px);
IkReal x885=((0.321)*cj18);
IkReal x886=((0.8)*x882);
evalcond[0]=(((x881*x885))+(((0.4)*x881)));
evalcond[1]=(((x881*x884))+((x881*x883))+(((-0.1)*x881)));
evalcond[2]=((0.1)+((x882*x885))+(((-1.0)*x883))+(((-1.0)*x884))+(((0.4)*x882)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x883*x886))+(((0.2)*x883))+(((0.2)*x884))+(((-1.0)*(py*py)))+(((-0.08)*x882))+((x884*x886)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x888=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj18))),-1);
if(!x888.valid){
continue;
}
IkReal x887=x888.value;
cj16array[0]=((((-0.1)*x887))+((py*sj15*x887))+((cj15*px*x887)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x889=IKsin(j16);
IkReal x890=IKcos(j16);
IkReal x891=(cj15*px);
IkReal x892=(py*sj15);
IkReal x893=((0.321)*cj18);
IkReal x894=((1.0)*x890);
IkReal x895=((0.8)*x890);
evalcond[0]=((((0.4)*x889))+((x889*x893)));
evalcond[1]=(((x889*x891))+((x889*x892))+(((-0.1)*x889)));
evalcond[2]=((0.4)+(((-1.0)*x892*x894))+x893+(((0.1)*x890))+(((-1.0)*x891*x894)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+((x892*x895))+(((0.2)*x892))+(((0.2)*x891))+((x891*x895))+(((-1.0)*(py*py)))+(((-0.08)*x890)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
CheckValue<IkReal> x897=IKPowWithIntegerCheck(((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15))),-1);
if(!x897.valid){
continue;
}
IkReal x896=x897.value;
cj16array[0]=((((-0.321)*cj18*x896))+(((-0.4)*x896)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[4];
IkReal x898=IKsin(j16);
IkReal x899=IKcos(j16);
IkReal x900=(py*sj15);
IkReal x901=((0.321)*cj18);
IkReal x902=(cj15*px);
IkReal x903=((0.8)*x899);
evalcond[0]=((((0.4)*x898))+((x898*x901)));
evalcond[1]=((((-0.1)*x898))+((x898*x900))+((x898*x902)));
evalcond[2]=((0.1)+(((0.4)*x899))+((x899*x901))+(((-1.0)*x902))+(((-1.0)*x900)));
evalcond[3]=((-0.066959)+(((-1.0)*(px*px)))+(((0.2)*x902))+(((0.2)*x900))+((x902*x903))+((x900*x903))+(((-1.0)*(py*py)))+(((-0.08)*x899)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j18), 6.28318530717959))))));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[2]=((0.509841)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj15))+(((1.3869625520111)*cj15*px)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x904=IKcos(j16);
IkReal x905=IKsin(j16);
CheckValue<IkReal> x915=IKPowWithIntegerCheck(px,-1);
if(!x915.valid){
continue;
}
IkReal x906=x915.value;
IkReal x907=py*py;
IkReal x908=((1.0)*cj15);
IkReal x909=(cj15*cj17);
IkReal x910=((0.8)*cj15);
IkReal x911=(px*x904);
IkReal x912=(px*x905);
IkReal x913=((0.1)*x905);
IkReal x914=(x905*x906*x907);
evalcond[0]=((0.721)*x905);
evalcond[1]=((0.721)+(((-1.0)*x908*x911))+(((-1.0)*py*sj15*x904))+(((0.1)*x904)));
evalcond[2]=((-0.5768)+((x910*x911))+(((-0.08)*x904))+((x904*x906*x907*x910)));
evalcond[3]=(((x909*x914))+((x909*x912))+(((-1.0)*cj17*x913)));
evalcond[4]=((((-1.0)*sj17*x908*x914))+(((-1.0)*sj17*x908*x912))+((sj17*x913)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(((-3.14159265358979)+(IKfmod(j18, 6.28318530717959)))))+(IKabs(pz)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[2]=((-0.003759)+(((0.2)*cj15*px))+(((0.2)*py*sj15))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j16array[2], cj16array[2], sj16array[2];
bool j16valid[2]={false};
_nj16 = 2;
cj16array[0]=((-1.26582278481013)+(((12.6582278481013)*cj15*px))+(((12.6582278481013)*py*sj15)));
if( cj16array[0] >= -1-IKFAST_SINCOS_THRESH && cj16array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j16valid[0] = j16valid[1] = true;
    j16array[0] = IKacos(cj16array[0]);
    sj16array[0] = IKsin(j16array[0]);
    cj16array[1] = cj16array[0];
    j16array[1] = -j16array[0];
    sj16array[1] = -sj16array[0];
}
else if( isnan(cj16array[0]) )
{
    // probably any value will work
    j16valid[0] = true;
    cj16array[0] = 1; sj16array[0] = 0; j16array[0] = 0;
}
for(int ij16 = 0; ij16 < 2; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 2; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[5];
IkReal x916=IKcos(j16);
IkReal x917=IKsin(j16);
CheckValue<IkReal> x927=IKPowWithIntegerCheck(px,-1);
if(!x927.valid){
continue;
}
IkReal x918=x927.value;
IkReal x919=py*py;
IkReal x920=((1.0)*cj15);
IkReal x921=(cj15*cj17);
IkReal x922=((0.8)*cj15);
IkReal x923=(px*x916);
IkReal x924=(px*x917);
IkReal x925=((0.1)*x917);
IkReal x926=(x917*x918*x919);
evalcond[0]=((0.079)*x917);
evalcond[1]=((0.079)+(((-1.0)*x920*x923))+(((0.1)*x916))+(((-1.0)*py*sj15*x916)));
evalcond[2]=((-0.0632)+((x916*x918*x919*x922))+(((-0.08)*x916))+((x922*x923)));
evalcond[3]=((((-1.0)*cj17*x925))+((x921*x924))+((x921*x926)));
evalcond[4]=((((-1.0)*sj17*x920*x926))+(((-1.0)*sj17*x920*x924))+((sj17*x925)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j16]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x928=cj15*cj15;
IkReal x929=py*py;
IkReal x930=(py*sj15);
IkReal x931=(cj15*px);
IkReal x932=((1000.0)*pz);
IkReal x933=(cj17*sj18);
IkReal x934=((1000.0)*x928);
CheckValue<IkReal> x935 = IKatan2WithCheck(IkReal(((-150.0)+(((-200.0)*x931))+(((-200.0)*x930))+((x934*(px*px)))+(((-256.8)*cj18))+(((2000.0)*x930*x931))+(((1000.0)*x929))+(((-1.0)*x929*x934))+(((-103.041)*(cj18*cj18))))),((((-100.0)*pz))+(((-128.4)*x933))+((x930*x932))+((x931*x932))+(((-103.041)*cj18*x933))),IKFAST_ATAN2_MAGTHRESH);
if(!x935.valid){
continue;
}
CheckValue<IkReal> x936=IKPowWithIntegerCheck(IKsign(((((32.1)*x933))+(((321.0)*cj18*pz))+(((400.0)*pz))+(((-321.0)*x930*x933))+(((-321.0)*x931*x933)))),-1);
if(!x936.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x935.value)+(((1.5707963267949)*(x936.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x937=IKsin(j16);
IkReal x938=IKcos(j16);
IkReal x939=((0.321)*sj18);
IkReal x940=(cj15*px);
IkReal x941=(py*sj15);
IkReal x942=(px*sj15);
IkReal x943=((1.0)*sj17);
IkReal x944=(cj15*py);
IkReal x945=((0.321)*cj18);
IkReal x946=(pz*x938);
IkReal x947=((1.0)*x940);
IkReal x948=((0.321)*x938);
IkReal x949=(sj17*x937);
IkReal x950=(pz*x937);
IkReal x951=((0.8)*x938);
IkReal x952=(cj17*x937);
evalcond[0]=(((x937*x945))+((cj17*x938*x939))+pz+(((0.4)*x937)));
evalcond[1]=((0.1)+(((-1.0)*x947))+((x938*x945))+(((-1.0)*x941))+(((-1.0)*x939*x952))+(((0.4)*x938)));
evalcond[2]=((0.4)+(((0.1)*x938))+(((-1.0)*x938*x947))+(((-1.0)*x938*x941))+x950+x945);
evalcond[3]=((-0.066959)+(((-0.08)*x938))+((x940*x951))+(((-0.8)*x950))+(((0.2)*x940))+(((0.2)*x941))+((x941*x951))+(((-1.0)*pp)));
evalcond[4]=(((cj17*x942))+(((-1.0)*cj17*x944))+(((-1.0)*x943*x946))+(((-1.0)*x937*x940*x943))+(((-1.0)*x937*x941*x943))+(((0.1)*x949)));
evalcond[5]=(((cj17*x946))+((x940*x952))+(((-0.1)*x952))+((x941*x952))+(((-1.0)*x943*x944))+((sj17*x942))+x939);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x953=cj17*cj17;
IkReal x954=cj18*cj18;
IkReal x955=(cj15*px);
IkReal x956=(py*sj15);
IkReal x957=((321000.0)*cj18);
IkReal x958=((321000.0)*cj17*sj18);
IkReal x959=((103041.0)*x954);
CheckValue<IkReal> x960=IKPowWithIntegerCheck(IKsign(((160000.0)+(((256800.0)*cj18))+(((-1.0)*x953*x959))+(((103041.0)*x953))+x959)),-1);
if(!x960.valid){
continue;
}
CheckValue<IkReal> x961 = IKatan2WithCheck(IkReal(((((32100.0)*cj17*sj18))+(((-1.0)*pz*x957))+(((-1.0)*x956*x958))+(((-400000.0)*pz))+(((-1.0)*x955*x958)))),((-40000.0)+((x955*x957))+(((-1.0)*pz*x958))+((x956*x957))+(((-32100.0)*cj18))+(((400000.0)*x956))+(((400000.0)*x955))),IKFAST_ATAN2_MAGTHRESH);
if(!x961.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(((1.5707963267949)*(x960.value)))+(x961.value));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x962=IKsin(j16);
IkReal x963=IKcos(j16);
IkReal x964=((0.321)*sj18);
IkReal x965=(cj15*px);
IkReal x966=(py*sj15);
IkReal x967=(px*sj15);
IkReal x968=((1.0)*sj17);
IkReal x969=(cj15*py);
IkReal x970=((0.321)*cj18);
IkReal x971=(pz*x963);
IkReal x972=((1.0)*x965);
IkReal x973=((0.321)*x963);
IkReal x974=(sj17*x962);
IkReal x975=(pz*x962);
IkReal x976=((0.8)*x963);
IkReal x977=(cj17*x962);
evalcond[0]=(((x962*x970))+pz+((cj17*x963*x964))+(((0.4)*x962)));
evalcond[1]=((0.1)+(((-1.0)*x966))+((x963*x970))+(((-1.0)*x964*x977))+(((0.4)*x963))+(((-1.0)*x972)));
evalcond[2]=((0.4)+(((-1.0)*x963*x972))+(((-1.0)*x963*x966))+(((0.1)*x963))+x970+x975);
evalcond[3]=((-0.066959)+(((-0.8)*x975))+((x965*x976))+(((-1.0)*pp))+((x966*x976))+(((0.2)*x966))+(((0.2)*x965))+(((-0.08)*x963)));
evalcond[4]=((((-1.0)*x962*x965*x968))+(((0.1)*x974))+((cj17*x967))+(((-1.0)*cj17*x969))+(((-1.0)*x962*x966*x968))+(((-1.0)*x968*x971)));
evalcond[5]=((((-0.1)*x977))+((sj17*x967))+((cj17*x971))+((x965*x977))+((x966*x977))+(((-1.0)*x968*x969))+x964);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x978=(cj15*px);
IkReal x979=((1000.0)*pz);
IkReal x980=(cj17*sj18);
IkReal x981=((321.0)*cj18);
IkReal x982=(py*sj15);
CheckValue<IkReal> x983 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((-1.0)*x978*x979))+(((-128.4)*x980))+(((-103.041)*cj18*x980))+(((-1.0)*x979*x982)))),((160.0)+(((-1.0)*pz*x979))+(((256.8)*cj18))+(((103.041)*(cj18*cj18)))),IKFAST_ATAN2_MAGTHRESH);
if(!x983.valid){
continue;
}
CheckValue<IkReal> x984=IKPowWithIntegerCheck(IKsign(((-40.0)+((x981*x982))+(((321.0)*pz*x980))+(((400.0)*x978))+(((-32.1)*cj18))+(((400.0)*x982))+((x978*x981)))),-1);
if(!x984.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x983.value)+(((1.5707963267949)*(x984.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[6];
IkReal x985=IKsin(j16);
IkReal x986=IKcos(j16);
IkReal x987=((0.321)*sj18);
IkReal x988=(cj15*px);
IkReal x989=(py*sj15);
IkReal x990=(px*sj15);
IkReal x991=((1.0)*sj17);
IkReal x992=(cj15*py);
IkReal x993=((0.321)*cj18);
IkReal x994=(pz*x986);
IkReal x995=((1.0)*x988);
IkReal x996=((0.321)*x986);
IkReal x997=(sj17*x985);
IkReal x998=(pz*x985);
IkReal x999=((0.8)*x986);
IkReal x1000=(cj17*x985);
evalcond[0]=((((0.4)*x985))+pz+((x985*x993))+((cj17*x986*x987)));
evalcond[1]=((0.1)+(((0.4)*x986))+(((-1.0)*x1000*x987))+((x986*x993))+(((-1.0)*x989))+(((-1.0)*x995)));
evalcond[2]=((0.4)+(((-1.0)*x986*x989))+(((0.1)*x986))+x993+x998+(((-1.0)*x986*x995)));
evalcond[3]=((-0.066959)+(((-0.8)*x998))+((x989*x999))+((x988*x999))+(((-1.0)*pp))+(((0.2)*x989))+(((0.2)*x988))+(((-0.08)*x986)));
evalcond[4]=((((-1.0)*cj17*x992))+(((-1.0)*x985*x989*x991))+(((-1.0)*x991*x994))+(((0.1)*x997))+((cj17*x990))+(((-1.0)*x985*x988*x991)));
evalcond[5]=((((-1.0)*x991*x992))+((sj17*x990))+((cj17*x994))+x987+((x1000*x988))+((x1000*x989))+(((-0.1)*x1000)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j16array[1], cj16array[1], sj16array[1];
bool j16valid[1]={false};
_nj16 = 1;
IkReal x1001=py*py;
IkReal x1002=cj15*cj15;
IkReal x1003=px*px;
IkReal x1004=((5.0)*pp);
IkReal x1005=(py*sj15);
IkReal x1006=(pz*sj17);
IkReal x1007=(cj17*py);
IkReal x1008=(cj15*px*sj17);
IkReal x1009=((4.0)*x1001);
IkReal x1010=(cj15*cj17*sj15);
IkReal x1011=(sj17*x1002);
IkReal x1012=((4.0)*x1003);
IkReal x1013=((4.0)*x1007);
IkReal x1014=(cj17*px*sj15);
CheckValue<IkReal> x1015 = IKatan2WithCheck(IkReal(((((8.0)*px*x1002*x1007))+(((-1.0)*px*x1013))+(((-1.0)*x1010*x1012))+(((0.4)*x1014))+((x1009*x1010))+(((-1.0)*x1005*x1006))+((x1004*x1006))+(((-1.0)*cj15*px*x1006))+(((-0.4)*cj15*x1007))+(((0.334795)*x1006)))),(((x1003*x1011))+(((-1.0)*sj17*x1004*x1005))+(((0.5)*pp*sj17))+(((-1.0)*x1001*x1011))+(((-1.0)*x1004*x1008))+(((-0.434795)*x1008))+((cj15*pz*x1013))+((sj17*x1001))+(((-4.0)*pz*x1014))+(((-0.434795)*sj17*x1005))+(((0.0334795)*sj17))+(((2.0)*x1005*x1008))),IKFAST_ATAN2_MAGTHRESH);
if(!x1015.valid){
continue;
}
CheckValue<IkReal> x1016=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1011*x1012))+((x1009*x1011))+(((0.8)*sj17*x1005))+(((0.8)*x1008))+(((-1.0)*sj17*x1009))+(((-0.04)*sj17))+(((-4.0)*pz*x1006))+(((-8.0)*x1005*x1008)))),-1);
if(!x1016.valid){
continue;
}
j16array[0]=((-1.5707963267949)+(x1015.value)+(((1.5707963267949)*(x1016.value))));
sj16array[0]=IKsin(j16array[0]);
cj16array[0]=IKcos(j16array[0]);
if( j16array[0] > IKPI )
{
    j16array[0]-=IK2PI;
}
else if( j16array[0] < -IKPI )
{    j16array[0]+=IK2PI;
}
j16valid[0] = true;
for(int ij16 = 0; ij16 < 1; ++ij16)
{
if( !j16valid[ij16] )
{
    continue;
}
_ij16[0] = ij16; _ij16[1] = -1;
for(int iij16 = ij16+1; iij16 < 1; ++iij16)
{
if( j16valid[iij16] && IKabs(cj16array[ij16]-cj16array[iij16]) < IKFAST_SOLUTION_THRESH && IKabs(sj16array[ij16]-sj16array[iij16]) < IKFAST_SOLUTION_THRESH )
{
    j16valid[iij16]=false; _ij16[1] = iij16; break; 
}
}
j16 = j16array[ij16]; cj16 = cj16array[ij16]; sj16 = sj16array[ij16];
{
IkReal evalcond[2];
IkReal x1017=IKcos(j16);
IkReal x1018=IKsin(j16);
IkReal x1019=((1.0)*py);
IkReal x1020=(cj15*px);
IkReal x1021=(py*sj15);
IkReal x1022=(sj17*x1018);
IkReal x1023=((0.8)*x1017);
evalcond[0]=((-0.066959)+(((-0.8)*pz*x1018))+(((-0.08)*x1017))+(((-1.0)*pp))+((x1021*x1023))+((x1020*x1023))+(((0.2)*x1021))+(((0.2)*x1020)));
evalcond[1]=((((-1.0)*pz*sj17*x1017))+(((-1.0)*cj15*cj17*x1019))+(((-1.0)*sj15*x1019*x1022))+((cj17*px*sj15))+(((0.1)*x1022))+(((-1.0)*x1020*x1022)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j18eval[1];
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
j18eval[0]=cj16;
j18eval[1]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal j18eval[2];
j18eval[0]=sj17;
j18eval[1]=sj16;
if( IKabs(j18eval[0]) < 0.0000010000000000  || IKabs(j18eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1024=(py*sj15);
IkReal x1025=((0.8)*cj16);
IkReal x1026=(cj15*px);
IkReal x1027=(((px*sj15))+(((-1.0)*cj15*py)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=x1027;
evalcond[2]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1025*x1026))+(((0.2)*x1024))+(((0.2)*x1026))+((x1024*x1025)));
evalcond[3]=x1027;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1028=((3.11526479750779)*cj16);
IkReal x1029=(py*sj15);
IkReal x1030=((3.11526479750779)*sj16);
IkReal x1031=(cj15*px);
if( IKabs(((((-1.0)*pz*x1028))+(((-1.0)*x1029*x1030))+(((0.311526479750779)*sj16))+(((-1.0)*x1030*x1031)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1028*x1029))+(((-1.0)*pz*x1030))+((x1028*x1031))+(((-0.311526479750779)*cj16)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*pz*x1028))+(((-1.0)*x1029*x1030))+(((0.311526479750779)*sj16))+(((-1.0)*x1030*x1031))))+IKsqr(((-1.24610591900312)+((x1028*x1029))+(((-1.0)*pz*x1030))+((x1028*x1031))+(((-0.311526479750779)*cj16))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*pz*x1028))+(((-1.0)*x1029*x1030))+(((0.311526479750779)*sj16))+(((-1.0)*x1030*x1031))), ((-1.24610591900312)+((x1028*x1029))+(((-1.0)*pz*x1030))+((x1028*x1031))+(((-0.311526479750779)*cj16))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1032=IKcos(j18);
IkReal x1033=IKsin(j18);
IkReal x1034=(py*sj15);
IkReal x1035=(cj15*px);
IkReal x1036=((1.0)*cj16);
IkReal x1037=((0.321)*x1032);
IkReal x1038=((0.321)*x1033);
evalcond[0]=((((0.4)*sj16))+((sj16*x1037))+pz+((cj16*x1038)));
evalcond[1]=((0.253041)+(((0.2568)*x1032))+(((-1.0)*pp))+(((0.2)*x1034))+(((0.2)*x1035)));
evalcond[2]=((((-0.1)*sj16))+x1038+((sj16*x1034))+((sj16*x1035))+((cj16*pz)));
evalcond[3]=((0.4)+x1037+(((-1.0)*x1035*x1036))+(((-1.0)*x1034*x1036))+((pz*sj16))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*sj16*x1038))+(((-1.0)*x1034))+(((-1.0)*x1035))+(((0.4)*cj16))+((cj16*x1037)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1039=(py*sj15);
IkReal x1040=(cj15*py);
IkReal x1041=((0.8)*cj16);
IkReal x1042=(cj15*px);
IkReal x1043=(px*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(x1043+(((-1.0)*x1040)));
evalcond[2]=((-0.066959)+(((0.2)*x1042))+((x1039*x1041))+((x1041*x1042))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+(((0.2)*x1039)));
evalcond[3]=(x1040+(((-1.0)*x1043)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1044=((3.11526479750779)*cj16);
IkReal x1045=((3.11526479750779)*sj16);
IkReal x1046=(py*sj15);
IkReal x1047=(cj15*px);
if( IKabs(((((-0.311526479750779)*sj16))+((pz*x1044))+((x1045*x1046))+((x1045*x1047)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-1.0)*pz*x1045))+(((-0.311526479750779)*cj16))+((x1044*x1047))+((x1044*x1046)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-0.311526479750779)*sj16))+((pz*x1044))+((x1045*x1046))+((x1045*x1047))))+IKsqr(((-1.24610591900312)+(((-1.0)*pz*x1045))+(((-0.311526479750779)*cj16))+((x1044*x1047))+((x1044*x1046))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-0.311526479750779)*sj16))+((pz*x1044))+((x1045*x1046))+((x1045*x1047))), ((-1.24610591900312)+(((-1.0)*pz*x1045))+(((-0.311526479750779)*cj16))+((x1044*x1047))+((x1044*x1046))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1048=IKcos(j18);
IkReal x1049=IKsin(j18);
IkReal x1050=((1.0)*cj16);
IkReal x1051=(py*sj15);
IkReal x1052=(cj15*px);
IkReal x1053=((0.321)*x1048);
IkReal x1054=((1.0)*x1052);
IkReal x1055=((0.321)*x1049);
evalcond[0]=((((0.4)*sj16))+(((-1.0)*cj16*x1055))+pz+((sj16*x1053)));
evalcond[1]=((0.253041)+(((0.2)*x1051))+(((0.2)*x1052))+(((-1.0)*pp))+(((0.2568)*x1048)));
evalcond[2]=((0.4)+x1053+((pz*sj16))+(((-1.0)*x1050*x1052))+(((-1.0)*x1050*x1051))+(((0.1)*cj16)));
evalcond[3]=(x1055+(((-1.0)*sj16*x1051))+(((-1.0)*sj16*x1054))+(((-1.0)*pz*x1050))+(((0.1)*sj16)));
evalcond[4]=((0.1)+(((-1.0)*x1054))+((cj16*x1053))+(((0.4)*cj16))+(((-1.0)*x1051))+((sj16*x1055)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j16))), 6.28318530717959)));
evalcond[1]=((-0.146959)+((py*sj15))+(((-1.0)*pp))+((cj15*px)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+(((-1.0)*pz*sj17))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
sj16=0;
cj16=1.0;
j16=0;
j18eval[0]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
sj16=0;
cj16=1.0;
j16=0;
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1056=IKcos(j18);
IkReal x1057=(py*sj15);
IkReal x1058=(cj15*px);
evalcond[0]=(pz+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.4)+(((-0.8)*x1057))+(((-0.8)*x1058))+(((0.2568)*x1056)));
evalcond[2]=((0.5)+(((0.321)*x1056))+(((-1.0)*x1057))+(((-1.0)*x1058)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((3.11526479750779)*pz), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1059=IKcos(j18);
IkReal x1060=(py*sj15);
IkReal x1061=(cj15*px);
evalcond[0]=((((-0.321)*(IKsin(j18))))+pz);
evalcond[1]=((0.4)+(((0.2568)*x1059))+(((-0.8)*x1061))+(((-0.8)*x1060)));
evalcond[2]=((0.5)+(((0.321)*x1059))+(((-1.0)*x1060))+(((-1.0)*x1061)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1062=((3.11526479750779)*cj15);
IkReal x1063=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*px*x1063))+((py*x1062)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((py*x1063))+((px*x1062)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*px*x1063))+((py*x1062))))+IKsqr(((-1.55763239875389)+((py*x1063))+((px*x1062))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*px*x1063))+((py*x1062))), ((-1.55763239875389)+((py*x1063))+((px*x1062))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1064=IKcos(j18);
IkReal x1065=(py*sj15);
IkReal x1066=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.4)+(((-0.8)*x1065))+(((-0.8)*x1066))+(((0.2568)*x1064)));
evalcond[2]=((0.5)+(((0.321)*x1064))+(((-1.0)*x1065))+(((-1.0)*x1066)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1067=((3.11526479750779)*cj15);
IkReal x1068=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*py*x1067))+((px*x1068)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+((py*x1068))+((px*x1067)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*py*x1067))+((px*x1068))))+IKsqr(((-1.55763239875389)+((py*x1068))+((px*x1067))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*py*x1067))+((px*x1068))), ((-1.55763239875389)+((py*x1068))+((px*x1067))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1069=IKcos(j18);
IkReal x1070=(py*sj15);
IkReal x1071=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
evalcond[1]=((0.4)+(((-0.8)*x1070))+(((-0.8)*x1071))+(((0.2568)*x1069)));
evalcond[2]=((0.5)+(((0.321)*x1069))+(((-1.0)*x1070))+(((-1.0)*x1071)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1072=IKPowWithIntegerCheck(sj17,-1);
if(!x1072.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1072.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1072.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1072.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1073=IKsin(j18);
IkReal x1074=IKcos(j18);
IkReal x1075=(py*sj15);
IkReal x1076=(cj15*px);
IkReal x1077=(px*sj15);
IkReal x1078=((0.321)*x1073);
IkReal x1079=((1.0)*cj15*py);
evalcond[0]=(((cj17*x1078))+pz);
evalcond[1]=(x1077+(((-1.0)*x1079))+((sj17*x1078)));
evalcond[2]=((0.4)+(((-0.8)*x1076))+(((-0.8)*x1075))+(((0.2568)*x1074)));
evalcond[3]=((0.5)+(((0.321)*x1074))+(((-1.0)*x1075))+(((-1.0)*x1076)));
evalcond[4]=(x1078+(((-1.0)*sj17*x1079))+((cj17*pz))+((sj17*x1077)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1080=IKPowWithIntegerCheck(cj17,-1);
if(!x1080.valid){
continue;
}
if( IKabs(((-3.11526479750779)*pz*(x1080.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1080.value)))+IKsqr(((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-3.11526479750779)*pz*(x1080.value)), ((-1.55763239875389)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1081=IKsin(j18);
IkReal x1082=IKcos(j18);
IkReal x1083=(py*sj15);
IkReal x1084=(cj15*px);
IkReal x1085=(px*sj15);
IkReal x1086=((0.321)*x1081);
IkReal x1087=((1.0)*cj15*py);
evalcond[0]=(((cj17*x1086))+pz);
evalcond[1]=(((sj17*x1086))+x1085+(((-1.0)*x1087)));
evalcond[2]=((0.4)+(((-0.8)*x1084))+(((-0.8)*x1083))+(((0.2568)*x1082)));
evalcond[3]=((0.5)+(((-1.0)*x1084))+(((-1.0)*x1083))+(((0.321)*x1082)));
evalcond[4]=(((sj17*x1085))+x1086+(((-1.0)*sj17*x1087))+((cj17*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j16)))), 6.28318530717959)));
evalcond[1]=((0.013041)+(((-0.6)*cj15*px))+(((-0.6)*py*sj15))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+((pz*sj17))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
sj16=0;
cj16=-1.0;
j16=3.14159265358979;
j18eval[0]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
sj16=0;
cj16=-1.0;
j16=3.14159265358979;
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1088=IKcos(j18);
IkReal x1089=(py*sj15);
IkReal x1090=(cj15*px);
evalcond[0]=((((-0.321)*(IKsin(j18))))+pz);
evalcond[1]=((0.3)+x1090+x1089+(((0.321)*x1088)));
evalcond[2]=((0.24)+(((0.8)*x1090))+(((0.8)*x1089))+(((0.2568)*x1088)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-3.11526479750779)*pz), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1091=IKcos(j18);
IkReal x1092=(py*sj15);
IkReal x1093=(cj15*px);
evalcond[0]=(pz+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.3)+x1092+x1093+(((0.321)*x1091)));
evalcond[2]=((0.24)+(((0.2568)*x1091))+(((0.8)*x1093))+(((0.8)*x1092)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1094=((3.11526479750779)*cj15);
IkReal x1095=((3.11526479750779)*sj15);
if( IKabs((((py*x1094))+(((-1.0)*px*x1095)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*py*x1095))+(((-1.0)*px*x1094)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((py*x1094))+(((-1.0)*px*x1095))))+IKsqr(((-0.934579439252336)+(((-1.0)*py*x1095))+(((-1.0)*px*x1094))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((((py*x1094))+(((-1.0)*px*x1095))), ((-0.934579439252336)+(((-1.0)*py*x1095))+(((-1.0)*px*x1094))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1096=IKcos(j18);
IkReal x1097=(py*sj15);
IkReal x1098=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
evalcond[1]=((0.3)+x1097+x1098+(((0.321)*x1096)));
evalcond[2]=((0.24)+(((0.2568)*x1096))+(((0.8)*x1097))+(((0.8)*x1098)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1099=((3.11526479750779)*cj15);
IkReal x1100=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*py*x1099))+((px*x1100)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-1.0)*py*x1100))+(((-1.0)*px*x1099)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*py*x1099))+((px*x1100))))+IKsqr(((-0.934579439252336)+(((-1.0)*py*x1100))+(((-1.0)*px*x1099))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*py*x1099))+((px*x1100))), ((-0.934579439252336)+(((-1.0)*py*x1100))+(((-1.0)*px*x1099))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1101=IKcos(j18);
IkReal x1102=(py*sj15);
IkReal x1103=(cj15*px);
evalcond[0]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
evalcond[1]=((0.3)+x1102+x1103+(((0.321)*x1101)));
evalcond[2]=((0.24)+(((0.8)*x1102))+(((0.8)*x1103))+(((0.2568)*x1101)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1104=IKPowWithIntegerCheck(sj17,-1);
if(!x1104.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1104.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1104.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1104.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1105=IKsin(j18);
IkReal x1106=IKcos(j18);
IkReal x1107=(py*sj15);
IkReal x1108=(cj15*px);
IkReal x1109=(px*sj15);
IkReal x1110=((0.321)*x1105);
IkReal x1111=((1.0)*cj15*py);
evalcond[0]=((((-1.0)*cj17*x1110))+pz);
evalcond[1]=((0.3)+x1107+x1108+(((0.321)*x1106)));
evalcond[2]=(x1109+((sj17*x1110))+(((-1.0)*x1111)));
evalcond[3]=((0.24)+(((0.8)*x1107))+(((0.8)*x1108))+(((0.2568)*x1106)));
evalcond[4]=(x1110+(((-1.0)*sj17*x1111))+((sj17*x1109))+(((-1.0)*cj17*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1112=IKPowWithIntegerCheck(cj17,-1);
if(!x1112.valid){
continue;
}
if( IKabs(((3.11526479750779)*pz*(x1112.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1112.value)))+IKsqr(((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((3.11526479750779)*pz*(x1112.value)), ((-0.934579439252336)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1113=IKsin(j18);
IkReal x1114=IKcos(j18);
IkReal x1115=(py*sj15);
IkReal x1116=(cj15*px);
IkReal x1117=(px*sj15);
IkReal x1118=((0.321)*x1113);
IkReal x1119=((1.0)*cj15*py);
evalcond[0]=((((-1.0)*cj17*x1118))+pz);
evalcond[1]=((0.3)+x1115+x1116+(((0.321)*x1114)));
evalcond[2]=(x1117+((sj17*x1118))+(((-1.0)*x1119)));
evalcond[3]=((0.24)+(((0.8)*x1115))+(((0.8)*x1116))+(((0.2568)*x1114)));
evalcond[4]=(x1118+(((-1.0)*sj17*x1119))+((sj17*x1117))+(((-1.0)*cj17*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1120=((1.0)*py);
IkReal x1121=(cj15*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*py*sj15))+(((-1.0)*pp))+(((0.2)*x1121)));
evalcond[2]=((((-1.0)*cj15*cj17*x1120))+(((-1.0)*sj15*sj17*x1120))+((cj17*px*sj15))+(((-1.0)*sj17*x1121))+(((0.1)*sj17)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1122=((3.11526479750779)*cj15);
IkReal x1123=((3.11526479750779)*sj15);
if( IKabs(((((-1.0)*cj17*px*x1122))+((py*sj17*x1122))+(((0.311526479750779)*cj17))+(((-1.0)*cj17*py*x1123))+(((-1.0)*px*sj17*x1123)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj17*px*x1122))+((py*sj17*x1122))+(((0.311526479750779)*cj17))+(((-1.0)*cj17*py*x1123))+(((-1.0)*px*sj17*x1123))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-1.0)*cj17*px*x1122))+((py*sj17*x1122))+(((0.311526479750779)*cj17))+(((-1.0)*cj17*py*x1123))+(((-1.0)*px*sj17*x1123))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1124=IKsin(j18);
IkReal x1125=IKcos(j18);
IkReal x1126=(py*sj15);
IkReal x1127=(px*sj15);
IkReal x1128=(cj15*px);
IkReal x1129=((0.321)*x1124);
IkReal x1130=((1.0)*cj15*py);
evalcond[0]=((0.4)+pz+(((0.321)*x1125)));
evalcond[1]=(x1127+((sj17*x1129))+(((-1.0)*x1130)));
evalcond[2]=((0.1)+(((-1.0)*cj17*x1129))+(((-1.0)*x1128))+(((-1.0)*x1126)));
evalcond[3]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1126))+(((0.2)*x1128))+(((0.2568)*x1125)));
evalcond[4]=(x1129+(((-0.1)*cj17))+((cj17*x1128))+((cj17*x1126))+(((-1.0)*sj17*x1130))+((sj17*x1127)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1131=(cj15*px);
IkReal x1132=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j16)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((-1.0)*pp))+(((0.2)*x1132))+(((0.2)*x1131)));
evalcond[2]=((((-1.0)*cj15*cj17*py))+(((-0.1)*sj17))+((sj17*x1131))+((sj17*x1132))+((cj17*px*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18eval[1];
sj16=-1.0;
cj16=0;
j16=-1.5707963267949;
j18eval[0]=sj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal j18eval[1];
sj16=-1.0;
cj16=0;
j16=-1.5707963267949;
j18eval[0]=cj17;
if( IKabs(j18eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1133=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1133))+pz);
evalcond[1]=((0.273041)+(((-1.0)*pp))+(((0.2568)*x1133)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*cj15*px))+(((-1.0)*py*sj15)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1134=IKcos(j18);
evalcond[0]=((-0.4)+(((-0.321)*x1134))+pz);
evalcond[1]=((0.273041)+(((-1.0)*pp))+(((0.2568)*x1134)));
evalcond[2]=(((px*sj15))+(((-1.0)*cj15*py))+(((-0.321)*(IKsin(j18)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j17))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*py*sj15))+(((3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1135=IKcos(j18);
IkReal x1136=(cj15*px);
IkReal x1137=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1135))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1137))+(((-1.0)*x1136))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1136))+(((0.2)*x1137))+(((0.2568)*x1135)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j17)))), 6.28318530717959)));
evalcond[1]=(((px*sj15))+(((-1.0)*cj15*py)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*py*sj15))+(((-3.11526479750779)*cj15*px))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[3];
IkReal x1138=IKcos(j18);
IkReal x1139=(cj15*px);
IkReal x1140=(py*sj15);
evalcond[0]=((-0.4)+(((-0.321)*x1138))+pz);
evalcond[1]=((0.1)+(((-1.0)*x1140))+(((-0.321)*(IKsin(j18))))+(((-1.0)*x1139)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1139))+(((0.2568)*x1138))+(((0.2)*x1140)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1141=IKPowWithIntegerCheck(cj17,-1);
if(!x1141.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1141.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1141.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1141.value)*(((-100.0)+(((1000.0)*py*sj15))+(((1000.0)*cj15*px))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1142=IKsin(j18);
IkReal x1143=IKcos(j18);
IkReal x1144=(py*sj15);
IkReal x1145=((1.0)*cj15);
IkReal x1146=(px*sj15);
IkReal x1147=((0.321)*x1142);
evalcond[0]=((-0.4)+pz+(((-0.321)*x1143)));
evalcond[1]=(x1146+((sj17*x1147))+(((-1.0)*py*x1145)));
evalcond[2]=((0.1)+(((-1.0)*px*x1145))+(((-1.0)*x1144))+((cj17*x1147)));
evalcond[3]=((0.253041)+(((0.2)*cj15*px))+(((-1.0)*pp))+(((0.2)*x1144))+(((0.2568)*x1143)));
evalcond[4]=(x1147+(((-1.0)*cj17*x1144))+((sj17*x1146))+(((-1.0)*cj17*px*x1145))+(((0.1)*cj17))+(((-1.0)*py*sj17*x1145)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1148=IKPowWithIntegerCheck(sj17,-1);
if(!x1148.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1148.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1148.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1148.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1149=IKsin(j18);
IkReal x1150=IKcos(j18);
IkReal x1151=(py*sj15);
IkReal x1152=((1.0)*cj15);
IkReal x1153=(px*sj15);
IkReal x1154=((0.321)*x1149);
evalcond[0]=((-0.4)+(((-0.321)*x1150))+pz);
evalcond[1]=(x1153+(((-1.0)*py*x1152))+((sj17*x1154)));
evalcond[2]=((0.1)+(((-1.0)*px*x1152))+(((-1.0)*x1151))+((cj17*x1154)));
evalcond[3]=((0.253041)+(((0.2)*x1151))+(((0.2568)*x1150))+(((0.2)*cj15*px))+(((-1.0)*pp)));
evalcond[4]=((((-1.0)*cj17*px*x1152))+x1154+(((-1.0)*py*sj17*x1152))+(((-1.0)*cj17*x1151))+((sj17*x1153))+(((0.1)*cj17)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1155=((1.0)*sj16);
IkReal x1156=(cj15*px);
IkReal x1157=(py*sj15);
IkReal x1158=((0.8)*cj16);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.2)*x1156))+(((0.2)*x1157))+(((-1.0)*pp))+(((-0.8)*pz*sj16))+(((-0.08)*cj16))+((x1156*x1158))+((x1157*x1158)));
evalcond[2]=((((-1.0)*x1155*x1156))+(((-1.0)*x1155*x1157))+(((-1.0)*cj16*pz))+(((0.1)*sj16)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((-3.11526479750779)*px*sj15))+(((3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1159=IKcos(j18);
IkReal x1160=(py*sj15);
IkReal x1161=((1.0)*cj16);
IkReal x1162=((1.0)*cj15);
IkReal x1163=(cj15*px);
IkReal x1164=((0.321)*x1159);
evalcond[0]=(((sj16*x1164))+(((0.4)*sj16))+pz);
evalcond[1]=(((px*sj15))+(((-1.0)*py*x1162))+(((0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1159))+(((-1.0)*pp))+(((0.2)*x1160))+(((0.2)*x1163)));
evalcond[3]=((0.1)+((cj16*x1164))+(((0.4)*cj16))+(((-1.0)*px*x1162))+(((-1.0)*x1160)));
evalcond[4]=((0.4)+x1164+((pz*sj16))+(((-1.0)*x1160*x1161))+(((-1.0)*x1161*x1163))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1165=(cj15*px);
IkReal x1166=((0.8)*cj16);
IkReal x1167=(py*sj15);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j17)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1165*x1166))+((x1166*x1167))+(((-1.0)*pp))+(((0.2)*x1167))+(((0.2)*x1165))+(((-0.8)*pz*sj16))+(((-0.08)*cj16)));
evalcond[2]=((((-0.1)*sj16))+((sj16*x1167))+((sj16*x1165))+((cj16*pz)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
if( IKabs(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((((3.11526479750779)*px*sj15))+(((-3.11526479750779)*cj15*py))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[5];
IkReal x1168=IKcos(j18);
IkReal x1169=(py*sj15);
IkReal x1170=((1.0)*cj16);
IkReal x1171=((1.0)*cj15);
IkReal x1172=(cj15*px);
IkReal x1173=((0.321)*x1168);
evalcond[0]=(((sj16*x1173))+(((0.4)*sj16))+pz);
evalcond[1]=(((px*sj15))+(((-1.0)*py*x1171))+(((-0.321)*(IKsin(j18)))));
evalcond[2]=((0.253041)+(((0.2568)*x1168))+(((0.2)*x1172))+(((-1.0)*pp))+(((0.2)*x1169)));
evalcond[3]=((0.1)+((cj16*x1173))+(((0.4)*cj16))+(((-1.0)*px*x1171))+(((-1.0)*x1169)));
evalcond[4]=((0.4)+x1173+((pz*sj16))+(((-1.0)*x1170*x1172))+(((-1.0)*x1169*x1170))+(((0.1)*cj16)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j18]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1179=IKPowWithIntegerCheck(sj17,-1);
if(!x1179.valid){
continue;
}
IkReal x1174=x1179.value;
IkReal x1175=((0.00311526479750779)*x1174);
IkReal x1176=(px*sj15);
IkReal x1177=(cj15*py);
IkReal x1178=((1000.0)*cj16*cj17);
CheckValue<IkReal> x1180=IKPowWithIntegerCheck(sj16,-1);
if(!x1180.valid){
continue;
}
if( IKabs((x1175*(((((-1000.0)*x1176))+(((1000.0)*x1177)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1175*(x1180.value)*(((((-1000.0)*pz*sj17))+(((-400.0)*sj16*sj17))+((x1176*x1178))+(((-1.0)*x1177*x1178)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1175*(((((-1000.0)*x1176))+(((1000.0)*x1177))))))+IKsqr((x1175*(x1180.value)*(((((-1000.0)*pz*sj17))+(((-400.0)*sj16*sj17))+((x1176*x1178))+(((-1.0)*x1177*x1178))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2((x1175*(((((-1000.0)*x1176))+(((1000.0)*x1177))))), (x1175*(x1180.value)*(((((-1000.0)*pz*sj17))+(((-400.0)*sj16*sj17))+((x1176*x1178))+(((-1.0)*x1177*x1178))))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1181=IKcos(j18);
IkReal x1182=IKsin(j18);
IkReal x1183=(cj17*sj16);
IkReal x1184=(cj16*cj17);
IkReal x1185=(cj15*px);
IkReal x1186=((1.0)*cj16);
IkReal x1187=(py*sj15);
IkReal x1188=(px*sj15);
IkReal x1189=((0.321)*x1182);
IkReal x1190=((0.321)*x1181);
IkReal x1191=((1.0)*cj15*py);
evalcond[0]=(x1188+(((-1.0)*x1191))+((sj17*x1189)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1185))+(((0.2)*x1187))+(((0.2568)*x1181)));
evalcond[2]=(((x1184*x1189))+(((0.4)*sj16))+((sj16*x1190))+pz);
evalcond[3]=((0.4)+x1190+(((-1.0)*x1186*x1187))+((pz*sj16))+(((-1.0)*x1185*x1186))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x1190))+(((0.4)*cj16))+(((-1.0)*x1183*x1189))+(((-1.0)*x1185))+(((-1.0)*x1187)));
evalcond[5]=(x1189+((x1183*x1187))+((x1183*x1185))+((pz*x1184))+(((-0.1)*x1183))+(((-1.0)*sj17*x1191))+((sj17*x1188)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
IkReal x1192=((250.0)*sj16);
IkReal x1193=(py*sj15);
IkReal x1194=(cj15*px);
CheckValue<IkReal> x1195=IKPowWithIntegerCheck(cj16,-1);
if(!x1195.valid){
continue;
}
CheckValue<IkReal> x1196=IKPowWithIntegerCheck(cj17,-1);
if(!x1196.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1195.value)*(x1196.value)*(((((-1000.0)*pz))+((x1192*x1194))+((x1192*x1193))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1193))+(((-0.778816199376947)*x1194)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1195.value)*(x1196.value)*(((((-1000.0)*pz))+((x1192*x1194))+((x1192*x1193))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1193))+(((-0.778816199376947)*x1194))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1195.value)*(x1196.value)*(((((-1000.0)*pz))+((x1192*x1194))+((x1192*x1193))+(((-1250.0)*pp*sj16))+(((-83.69875)*sj16))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1193))+(((-0.778816199376947)*x1194))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1197=IKcos(j18);
IkReal x1198=IKsin(j18);
IkReal x1199=(cj17*sj16);
IkReal x1200=(cj16*cj17);
IkReal x1201=(cj15*px);
IkReal x1202=((1.0)*cj16);
IkReal x1203=(py*sj15);
IkReal x1204=(px*sj15);
IkReal x1205=((0.321)*x1198);
IkReal x1206=((0.321)*x1197);
IkReal x1207=((1.0)*cj15*py);
evalcond[0]=(x1204+((sj17*x1205))+(((-1.0)*x1207)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2568)*x1197))+(((0.2)*x1201))+(((0.2)*x1203)));
evalcond[2]=(((sj16*x1206))+(((0.4)*sj16))+((x1200*x1205))+pz);
evalcond[3]=((0.4)+x1206+((pz*sj16))+(((-1.0)*x1202*x1203))+(((-1.0)*x1201*x1202))+(((0.1)*cj16)));
evalcond[4]=((0.1)+(((-1.0)*x1199*x1205))+(((0.4)*cj16))+(((-1.0)*x1203))+(((-1.0)*x1201))+((cj16*x1206)));
evalcond[5]=(x1205+((sj17*x1204))+(((-0.1)*x1199))+((x1199*x1201))+((x1199*x1203))+(((-1.0)*sj17*x1207))+((pz*x1200)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j18array[1], cj18array[1], sj18array[1];
bool j18valid[1]={false};
_nj18 = 1;
CheckValue<IkReal> x1208=IKPowWithIntegerCheck(sj17,-1);
if(!x1208.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1208.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1208.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j18array[0]=IKatan2(((0.00311526479750779)*(x1208.value)*(((((-1000.0)*px*sj15))+(((1000.0)*cj15*py))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*cj15*px))+(((-0.778816199376947)*py*sj15))));
sj18array[0]=IKsin(j18array[0]);
cj18array[0]=IKcos(j18array[0]);
if( j18array[0] > IKPI )
{
    j18array[0]-=IK2PI;
}
else if( j18array[0] < -IKPI )
{    j18array[0]+=IK2PI;
}
j18valid[0] = true;
for(int ij18 = 0; ij18 < 1; ++ij18)
{
if( !j18valid[ij18] )
{
    continue;
}
_ij18[0] = ij18; _ij18[1] = -1;
for(int iij18 = ij18+1; iij18 < 1; ++iij18)
{
if( j18valid[iij18] && IKabs(cj18array[ij18]-cj18array[iij18]) < IKFAST_SOLUTION_THRESH && IKabs(sj18array[ij18]-sj18array[iij18]) < IKFAST_SOLUTION_THRESH )
{
    j18valid[iij18]=false; _ij18[1] = iij18; break; 
}
}
j18 = j18array[ij18]; cj18 = cj18array[ij18]; sj18 = sj18array[ij18];
{
IkReal evalcond[6];
IkReal x1209=IKcos(j18);
IkReal x1210=IKsin(j18);
IkReal x1211=(cj17*sj16);
IkReal x1212=(cj16*cj17);
IkReal x1213=(cj15*px);
IkReal x1214=((1.0)*cj16);
IkReal x1215=(py*sj15);
IkReal x1216=(px*sj15);
IkReal x1217=((0.321)*x1210);
IkReal x1218=((0.321)*x1209);
IkReal x1219=((1.0)*cj15*py);
evalcond[0]=(x1216+((sj17*x1217))+(((-1.0)*x1219)));
evalcond[1]=((0.253041)+(((0.2)*x1215))+(((0.2)*x1213))+(((-1.0)*pp))+(((0.2568)*x1209)));
evalcond[2]=(((x1212*x1217))+(((0.4)*sj16))+pz+((sj16*x1218)));
evalcond[3]=((0.4)+x1218+(((-1.0)*x1214*x1215))+((pz*sj16))+(((-1.0)*x1213*x1214))+(((0.1)*cj16)));
evalcond[4]=((0.1)+((cj16*x1218))+(((0.4)*cj16))+(((-1.0)*x1211*x1217))+(((-1.0)*x1213))+(((-1.0)*x1215)));
evalcond[5]=(x1217+(((-0.1)*x1211))+((sj17*x1216))+(((-1.0)*sj17*x1219))+((x1211*x1215))+((x1211*x1213))+((pz*x1212)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x196=((1.0)*cj17);
IkReal x197=(cj18*sj16);
IkReal x198=(cj16*sj17);
IkReal x199=(sj16*sj18);
IkReal x200=(sj16*sj17);
IkReal x201=(cj16*cj18);
IkReal x202=(sj17*sj18);
IkReal x203=(cj16*sj18);
IkReal x204=(cj18*sj15*sj17);
IkReal x205=(x199+(((-1.0)*x196*x201)));
IkReal x206=(((sj15*x200))+((cj15*cj17)));
IkReal x207=(((cj15*x200))+(((-1.0)*sj15*x196)));
IkReal x208=((((-1.0)*x196*x199))+x201);
IkReal x209=(cj15*x208);
IkReal x210=((((-1.0)*x196*x197))+(((-1.0)*x203)));
IkReal x211=((((-1.0)*x197))+(((-1.0)*x196*x203)));
IkReal x212=(cj15*x210);
IkReal x213=(((cj15*x202))+((sj15*x208)));
IkReal x214=((((-1.0)*sj15*x202))+x209);
IkReal x215=(((cj15*cj18*sj17))+((sj15*x210)));
IkReal x216=(x212+(((-1.0)*x204)));
new_r00=(((r20*x205))+((r00*x216))+((r10*x215)));
new_r01=(((r11*x215))+((r21*x205))+((r01*x216)));
new_r02=(((r22*x205))+((r02*((x212+(((-1.0)*x204))))))+((r12*x215)));
new_r10=(((r20*x198))+((r00*x207))+((r10*x206)));
new_r11=(((r11*x206))+((r01*x207))+((r21*x198)));
new_r12=(((r22*x198))+((r12*x206))+((r02*x207)));
new_r20=(((r00*(((((-1.0)*sj15*x202))+x209))))+((r10*x213))+((r20*x211)));
new_r21=(((r21*x211))+((r11*x213))+((r01*x214)));
new_r22=(((r12*x213))+((r02*x214))+((r22*x211)));
{
IkReal j20array[2], cj20array[2], sj20array[2];
bool j20valid[2]={false};
_nj20 = 2;
cj20array[0]=new_r22;
if( cj20array[0] >= -1-IKFAST_SINCOS_THRESH && cj20array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j20valid[0] = j20valid[1] = true;
    j20array[0] = IKacos(cj20array[0]);
    sj20array[0] = IKsin(j20array[0]);
    cj20array[1] = cj20array[0];
    j20array[1] = -j20array[0];
    sj20array[1] = -sj20array[0];
}
else if( isnan(cj20array[0]) )
{
    // probably any value will work
    j20valid[0] = true;
    cj20array[0] = 1; sj20array[0] = 0; j20array[0] = 0;
}
for(int ij20 = 0; ij20 < 2; ++ij20)
{
if( !j20valid[ij20] )
{
    continue;
}
_ij20[0] = ij20; _ij20[1] = -1;
for(int iij20 = ij20+1; iij20 < 2; ++iij20)
{
if( j20valid[iij20] && IKabs(cj20array[ij20]-cj20array[iij20]) < IKFAST_SOLUTION_THRESH && IKabs(sj20array[ij20]-sj20array[iij20]) < IKFAST_SOLUTION_THRESH )
{
    j20valid[iij20]=false; _ij20[1] = iij20; break; 
}
}
j20 = j20array[ij20]; cj20 = cj20array[ij20]; sj20 = sj20array[ij20];

{
IkReal j19eval[2];
IkReal x217=((1.0)*cj17);
IkReal x218=(cj18*sj16);
IkReal x219=(cj16*sj17);
IkReal x220=(sj16*sj18);
IkReal x221=(sj16*sj17);
IkReal x222=(cj16*cj18);
IkReal x223=(sj17*sj18);
IkReal x224=(cj16*sj18);
IkReal x225=(cj18*sj15*sj17);
IkReal x226=(x220+(((-1.0)*x217*x222)));
IkReal x227=x206;
IkReal x228=x207;
IkReal x229=(x222+(((-1.0)*x217*x220)));
IkReal x230=(cj15*x229);
IkReal x231=x210;
IkReal x232=x211;
IkReal x233=(cj15*x231);
IkReal x234=(((cj15*x223))+((sj15*x229)));
IkReal x235=(x230+(((-1.0)*sj15*x223)));
IkReal x236=(((cj15*cj18*sj17))+((sj15*x231)));
IkReal x237=(x233+(((-1.0)*x225)));
new_r00=(((r20*x226))+((r10*x236))+((r00*x237)));
new_r01=(((r11*x236))+((r01*x237))+((r21*x226)));
new_r02=(((r02*((x233+(((-1.0)*x225))))))+((r22*x226))+((r12*x236)));
new_r10=(((r00*x228))+((r10*x227))+((r20*x219)));
new_r11=(((r21*x219))+((r01*x228))+((r11*x227)));
new_r12=(((r12*x227))+((r22*x219))+((r02*x228)));
new_r20=(((r10*x234))+((r00*((x230+(((-1.0)*sj15*x223))))))+((r20*x232)));
new_r21=(((r11*x234))+((r01*x235))+((r21*x232)));
new_r22=(((r02*x235))+((r12*x234))+((r22*x232)));
j19eval[0]=sj20;
j19eval[1]=IKsign(sj20);
if( IKabs(j19eval[0]) < 0.0000010000000000  || IKabs(j19eval[1]) < 0.0000010000000000  )
{
{
IkReal j19eval[1];
IkReal x238=((1.0)*cj17);
IkReal x239=(cj18*sj16);
IkReal x240=(cj16*sj17);
IkReal x241=(sj16*sj18);
IkReal x242=(sj16*sj17);
IkReal x243=(cj16*cj18);
IkReal x244=(sj17*sj18);
IkReal x245=(cj16*sj18);
IkReal x246=(cj18*sj15*sj17);
IkReal x247=(x241+(((-1.0)*x238*x243)));
IkReal x248=x206;
IkReal x249=x207;
IkReal x250=(x243+(((-1.0)*x238*x241)));
IkReal x251=(cj15*x250);
IkReal x252=x210;
IkReal x253=x211;
IkReal x254=(cj15*x252);
IkReal x255=(((cj15*x244))+((sj15*x250)));
IkReal x256=(x251+(((-1.0)*sj15*x244)));
IkReal x257=(((cj15*cj18*sj17))+((sj15*x252)));
IkReal x258=((((-1.0)*x246))+x254);
new_r00=(((r00*x258))+((r10*x257))+((r20*x247)));
new_r01=(((r11*x257))+((r01*x258))+((r21*x247)));
new_r02=(((r22*x247))+((r12*x257))+((r02*(((((-1.0)*x246))+x254)))));
new_r10=(((r00*x249))+((r10*x248))+((r20*x240)));
new_r11=(((r21*x240))+((r01*x249))+((r11*x248)));
new_r12=(((r02*x249))+((r22*x240))+((r12*x248)));
new_r20=(((r20*x253))+((r10*x255))+((r00*((x251+(((-1.0)*sj15*x244)))))));
new_r21=(((r21*x253))+((r11*x255))+((r01*x256)));
new_r22=(((r12*x255))+((r22*x253))+((r02*x256)));
j19eval[0]=sj20;
if( IKabs(j19eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x260 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x260.valid){
continue;
}
IkReal x259=x260.value;
j19array[0]=((-1.0)*x259);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x259)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x261=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x261))+(((-1.0)*cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x261))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x261))+(((-1.0)*cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x261))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x261))+(((-1.0)*cj19*new_r01))), ((((-1.0)*new_r01*x261))+((cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x262=IKsin(j21);
IkReal x263=IKcos(j21);
IkReal x264=((1.0)*sj19);
IkReal x265=((1.0)*x263);
IkReal x266=(sj19*x262);
IkReal x267=((1.0)*x262);
IkReal x268=(cj19*x265);
evalcond[0]=(x262+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((cj19*x262))+((sj19*x263))+new_r01);
evalcond[2]=((((-1.0)*x265))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*new_r00*x264))+((cj19*new_r10))+(((-1.0)*x267)));
evalcond[4]=((((-1.0)*new_r01*x264))+((cj19*new_r11))+(((-1.0)*x265)));
evalcond[5]=(x266+new_r00+(((-1.0)*x268)));
evalcond[6]=(x266+new_r11+(((-1.0)*x268)));
evalcond[7]=((((-1.0)*x263*x264))+new_r10+(((-1.0)*cj19*x267)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j19array[2], cj19array[2], sj19array[2];
bool j19valid[2]={false};
_nj19 = 2;
CheckValue<IkReal> x270 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x270.valid){
continue;
}
IkReal x269=x270.value;
j19array[0]=((-1.0)*x269);
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
j19array[1]=((3.14159265358979)+(((-1.0)*x269)));
sj19array[1]=IKsin(j19array[1]);
cj19array[1]=IKcos(j19array[1]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
if( j19array[1] > IKPI )
{
    j19array[1]-=IK2PI;
}
else if( j19array[1] < -IKPI )
{    j19array[1]+=IK2PI;
}
j19valid[1] = true;
for(int ij19 = 0; ij19 < 2; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 2; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[1];
evalcond[0]=((((-1.0)*new_r02*(IKsin(j19))))+((new_r12*(IKcos(j19)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x271=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x271))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x271))+(((-1.0)*cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x271))+((cj19*new_r01))))+IKsqr(((((-1.0)*new_r01*x271))+(((-1.0)*cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x271))+((cj19*new_r01))), ((((-1.0)*new_r01*x271))+(((-1.0)*cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x272=IKsin(j21);
IkReal x273=IKcos(j21);
IkReal x274=((1.0)*cj19);
IkReal x275=((1.0)*sj19);
IkReal x276=((1.0)*x272);
IkReal x277=(sj19*x273);
IkReal x278=(sj19*x272);
IkReal x279=(x272*x274);
evalcond[0]=(x273+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x276))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(x278+((cj19*x273))+new_r00);
evalcond[3]=((((-1.0)*new_r00*x275))+(((-1.0)*x276))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x275))+(((-1.0)*x273))+((cj19*new_r11)));
evalcond[5]=(x277+(((-1.0)*x279))+new_r01);
evalcond[6]=(x277+(((-1.0)*x279))+new_r10);
evalcond[7]=((((-1.0)*x272*x275))+(((-1.0)*x273*x274))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j19, j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x281=IKPowWithIntegerCheck(sj20,-1);
if(!x281.valid){
continue;
}
IkReal x280=x281.value;
CheckValue<IkReal> x282=IKPowWithIntegerCheck(new_r12,-1);
if(!x282.valid){
continue;
}
if( IKabs((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x280)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))))+IKsqr((new_r02*x280))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j19array[0]=IKatan2((x280*(x282.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj20*cj20)))))), (new_r02*x280));
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x283=IKcos(j19);
IkReal x284=IKsin(j19);
IkReal x285=((1.0)*sj20);
IkReal x286=(new_r02*x283);
IkReal x287=(new_r12*x284);
IkReal x288=(sj20*x283);
IkReal x289=(sj20*x284);
evalcond[0]=(new_r02+(((-1.0)*x283*x285)));
evalcond[1]=((((-1.0)*x284*x285))+new_r12);
evalcond[2]=(((new_r12*x283))+(((-1.0)*new_r02*x284)));
evalcond[3]=(x287+x286+(((-1.0)*x285)));
evalcond[4]=(((cj20*new_r20))+((new_r00*x288))+((new_r10*x289)));
evalcond[5]=(((cj20*new_r21))+((new_r11*x289))+((new_r01*x288)));
evalcond[6]=((-1.0)+((sj20*x286))+((sj20*x287))+((cj20*new_r22)));
evalcond[7]=(((cj20*x287))+((cj20*x286))+(((-1.0)*new_r22*x285)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21eval[2];
IkReal x290=((1.0)*cj17);
IkReal x291=(cj18*sj16);
IkReal x292=(cj16*sj17);
IkReal x293=(sj16*sj18);
IkReal x294=(sj16*sj17);
IkReal x295=(cj16*cj18);
IkReal x296=(sj17*sj18);
IkReal x297=(cj16*sj18);
IkReal x298=(cj18*sj15*sj17);
IkReal x299=((((-1.0)*x290*x295))+x293);
IkReal x300=x206;
IkReal x301=x207;
IkReal x302=((((-1.0)*x290*x293))+x295);
IkReal x303=(cj15*x302);
IkReal x304=x210;
IkReal x305=x211;
IkReal x306=(cj15*x304);
IkReal x307=(((sj15*x302))+((cj15*x296)));
IkReal x308=((((-1.0)*sj15*x296))+x303);
IkReal x309=(((cj15*cj18*sj17))+((sj15*x304)));
IkReal x310=((((-1.0)*x298))+x306);
new_r00=(((r20*x299))+((r00*x310))+((r10*x309)));
new_r01=(((r11*x309))+((r01*x310))+((r21*x299)));
new_r02=(((r02*(((((-1.0)*x298))+x306))))+((r22*x299))+((r12*x309)));
new_r10=(((r20*x292))+((r10*x300))+((r00*x301)));
new_r11=(((r11*x300))+((r01*x301))+((r21*x292)));
new_r12=(((r02*x301))+((r22*x292))+((r12*x300)));
new_r20=(((r00*(((((-1.0)*sj15*x296))+x303))))+((r20*x305))+((r10*x307)));
new_r21=(((r11*x307))+((r21*x305))+((r01*x308)));
new_r22=(((r22*x305))+((r02*x308))+((r12*x307)));
j21eval[0]=sj20;
j21eval[1]=IKsign(sj20);
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[2];
IkReal x311=((1.0)*cj17);
IkReal x312=(cj18*sj16);
IkReal x313=(cj16*sj17);
IkReal x314=(sj16*sj18);
IkReal x315=(sj16*sj17);
IkReal x316=(cj16*cj18);
IkReal x317=(sj17*sj18);
IkReal x318=(cj16*sj18);
IkReal x319=(cj18*sj15*sj17);
IkReal x320=(x314+(((-1.0)*x311*x316)));
IkReal x321=x206;
IkReal x322=x207;
IkReal x323=(x316+(((-1.0)*x311*x314)));
IkReal x324=(cj15*x323);
IkReal x325=x210;
IkReal x326=x211;
IkReal x327=(cj15*x325);
IkReal x328=(((cj15*x317))+((sj15*x323)));
IkReal x329=(x324+(((-1.0)*sj15*x317)));
IkReal x330=(((cj15*cj18*sj17))+((sj15*x325)));
IkReal x331=(x327+(((-1.0)*x319)));
new_r00=(((r00*x331))+((r20*x320))+((r10*x330)));
new_r01=(((r01*x331))+((r11*x330))+((r21*x320)));
new_r02=(((r12*x330))+((r02*((x327+(((-1.0)*x319))))))+((r22*x320)));
new_r10=(((r00*x322))+((r20*x313))+((r10*x321)));
new_r11=(((r11*x321))+((r01*x322))+((r21*x313)));
new_r12=(((r02*x322))+((r12*x321))+((r22*x313)));
new_r20=(((r20*x326))+((r00*((x324+(((-1.0)*sj15*x317))))))+((r10*x328)));
new_r21=(((r21*x326))+((r11*x328))+((r01*x329)));
new_r22=(((r02*x329))+((r12*x328))+((r22*x326)));
j21eval[0]=sj19;
j21eval[1]=sj20;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[3];
IkReal x332=((1.0)*cj17);
IkReal x333=(cj18*sj16);
IkReal x334=(cj16*sj17);
IkReal x335=(sj16*sj18);
IkReal x336=(sj16*sj17);
IkReal x337=(cj16*cj18);
IkReal x338=(sj17*sj18);
IkReal x339=(cj16*sj18);
IkReal x340=(cj18*sj15*sj17);
IkReal x341=(x335+(((-1.0)*x332*x337)));
IkReal x342=x206;
IkReal x343=x207;
IkReal x344=(x337+(((-1.0)*x332*x335)));
IkReal x345=(cj15*x344);
IkReal x346=x210;
IkReal x347=x211;
IkReal x348=(cj15*x346);
IkReal x349=(((sj15*x344))+((cj15*x338)));
IkReal x350=(x345+(((-1.0)*sj15*x338)));
IkReal x351=(((cj15*cj18*sj17))+((sj15*x346)));
IkReal x352=(x348+(((-1.0)*x340)));
new_r00=(((r00*x352))+((r10*x351))+((r20*x341)));
new_r01=(((r21*x341))+((r01*x352))+((r11*x351)));
new_r02=(((r12*x351))+((r22*x341))+((r02*((x348+(((-1.0)*x340)))))));
new_r10=(((r00*x343))+((r20*x334))+((r10*x342)));
new_r11=(((r01*x343))+((r21*x334))+((r11*x342)));
new_r12=(((r22*x334))+((r02*x343))+((r12*x342)));
new_r20=(((r00*((x345+(((-1.0)*sj15*x338))))))+((r20*x347))+((r10*x349)));
new_r21=(((r21*x347))+((r01*x350))+((r11*x349)));
new_r22=(((r22*x347))+((r12*x349))+((r02*x350)));
j21eval[0]=cj19;
j21eval[1]=cj20;
j21eval[2]=sj20;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x353=((((-1.0)*cj20))+new_r22);
IkReal x354=((((-1.0)*sj20))+new_r12);
IkReal x355=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x353;
evalcond[2]=x353;
evalcond[3]=new_r02;
evalcond[4]=x354;
evalcond[5]=x354;
evalcond[6]=(((new_r10*sj20))+((cj20*new_r20)));
evalcond[7]=(((new_r11*sj20))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj20))+((cj20*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x355))+((cj20*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x356 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x356.valid){
continue;
}
CheckValue<IkReal> x357=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x357.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x356.value)+(((1.5707963267949)*(x357.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x358=IKsin(j21);
IkReal x359=IKcos(j21);
IkReal x360=((1.0)*new_r12);
IkReal x361=((1.0)*x359);
IkReal x362=((1.0)*x358);
evalcond[0]=(new_r20+((new_r12*x359)));
evalcond[1]=(((new_r22*x358))+new_r11);
evalcond[2]=((((-1.0)*x358*x360))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x361))+new_r10);
evalcond[4]=((((-1.0)*x362))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x361))+(((-1.0)*new_r01)));
evalcond[6]=(x358+((new_r11*new_r22))+(((-1.0)*new_r21*x360)));
evalcond[7]=((((-1.0)*new_r20*x360))+(((-1.0)*x361))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x363=((((-1.0)*cj20))+new_r22);
IkReal x364=((1.0)*new_r12);
IkReal x365=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x363;
evalcond[2]=x363;
evalcond[3]=new_r02;
evalcond[4]=(sj20+new_r12);
evalcond[5]=((((-1.0)*x365))+(((-1.0)*x364)));
evalcond[6]=((((-1.0)*new_r10*x365))+((cj20*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x365))+((cj20*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*sj20*x364))+((cj20*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x365))+(((-1.0)*cj20*x364)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r00, new_r01);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x366=IKsin(j21);
IkReal x367=IKcos(j21);
IkReal x368=((1.0)*new_r10);
IkReal x369=((1.0)*new_r11);
IkReal x370=((1.0)*x367);
evalcond[0]=(new_r21+((new_r12*x366)));
evalcond[1]=((((-1.0)*x366))+new_r00);
evalcond[2]=((((-1.0)*x370))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x370))+new_r20);
evalcond[4]=(((new_r22*x366))+(((-1.0)*x369)));
evalcond[5]=((((-1.0)*x368))+(((-1.0)*new_r22*x370)));
evalcond[6]=((((-1.0)*new_r22*x369))+x366+((new_r12*new_r21)));
evalcond[7]=((((-1.0)*x370))+(((-1.0)*new_r22*x368))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x371=((1.0)*sj19);
IkReal x372=(((cj19*new_r12))+(((-1.0)*new_r02*x371)));
IkReal x373=(((new_r10*sj19))+((cj19*new_r00)));
IkReal x374=(((cj19*new_r01))+((new_r11*sj19)));
IkReal x375=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj19))+new_r02);
evalcond[3]=((((-1.0)*x371))+new_r12);
evalcond[4]=x372;
evalcond[5]=x372;
evalcond[6]=x375;
evalcond[7]=x374;
evalcond[8]=x373;
evalcond[9]=x373;
evalcond[10]=x374;
evalcond[11]=x375;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x376=IKcos(j21);
IkReal x377=IKsin(j21);
IkReal x378=((1.0)*new_r12);
IkReal x379=((1.0)*x377);
IkReal x380=((1.0)*x376);
evalcond[0]=(x376+new_r20);
evalcond[1]=((((-1.0)*x379))+new_r21);
evalcond[2]=(((new_r12*x376))+new_r01);
evalcond[3]=(((new_r12*x377))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x380))+new_r11);
evalcond[5]=(new_r10+(((-1.0)*new_r02*x379)));
evalcond[6]=((((-1.0)*new_r00*x378))+(((-1.0)*x379))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x380))+((new_r02*new_r11))+(((-1.0)*new_r01*x378)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x381=(new_r12*sj19);
IkReal x382=((1.0)*sj19);
IkReal x383=(cj19*new_r00);
IkReal x384=((1.0)*cj19);
IkReal x385=((((-1.0)*new_r02*x382))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj19+new_r02);
evalcond[3]=(sj19+new_r12);
evalcond[4]=x385;
evalcond[5]=x385;
evalcond[6]=((1.0)+x381+((cj19*new_r02)));
evalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));
evalcond[8]=(x383+((new_r10*sj19)));
evalcond[9]=((((-1.0)*new_r10*x382))+(((-1.0)*x383)));
evalcond[10]=((((-1.0)*new_r11*x382))+(((-1.0)*new_r01*x384)));
evalcond[11]=((-1.0)+(((-1.0)*new_r02*x384))+(((-1.0)*x381)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x386=IKcos(j21);
IkReal x387=IKsin(j21);
IkReal x388=((1.0)*new_r02);
IkReal x389=((1.0)*x386);
IkReal x390=((1.0)*x387);
evalcond[0]=(x387+new_r21);
evalcond[1]=((((-1.0)*x389))+new_r20);
evalcond[2]=(((new_r02*x386))+new_r11);
evalcond[3]=(((new_r02*x387))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x389))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x390))+new_r00);
evalcond[6]=((((-1.0)*new_r10*x388))+(((-1.0)*x390))+((new_r00*new_r12)));
evalcond[7]=((((-1.0)*new_r11*x388))+((new_r01*new_r12))+(((-1.0)*x389)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x391=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x392=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x391;
evalcond[7]=x391;
evalcond[8]=x392;
evalcond[9]=x392;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x393=((1.0)*sj19);
if( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x393)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x393))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x393))))+IKsqr(((((-1.0)*new_r01*x393))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x393))), ((((-1.0)*new_r01*x393))+((cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x394=IKsin(j21);
IkReal x395=IKcos(j21);
IkReal x396=((1.0)*sj19);
IkReal x397=((1.0)*x395);
IkReal x398=(sj19*x394);
IkReal x399=((1.0)*x394);
IkReal x400=(cj19*x397);
evalcond[0]=(x394+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x395))+((cj19*x394))+new_r01);
evalcond[2]=((((-1.0)*x397))+((new_r10*sj19))+((cj19*new_r00)));
evalcond[3]=((((-1.0)*x399))+((cj19*new_r10))+(((-1.0)*new_r00*x396)));
evalcond[4]=((((-1.0)*new_r01*x396))+(((-1.0)*x397))+((cj19*new_r11)));
evalcond[5]=(x398+new_r00+(((-1.0)*x400)));
evalcond[6]=(x398+new_r11+(((-1.0)*x400)));
evalcond[7]=((((-1.0)*cj19*x399))+(((-1.0)*x395*x396))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x401=(new_r12*sj19);
IkReal x402=((1.0)*new_r02);
IkReal x403=((((-1.0)*sj19*x402))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x403;
evalcond[7]=x403;
evalcond[8]=(x401+((cj19*new_r02)));
evalcond[9]=((((-1.0)*cj19*x402))+(((-1.0)*x401)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x404=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x404))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x404)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x404))+((cj19*new_r01))))+IKsqr(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x404))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x404))+((cj19*new_r01))), ((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x404))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x405=IKsin(j21);
IkReal x406=IKcos(j21);
IkReal x407=((1.0)*cj19);
IkReal x408=((1.0)*sj19);
IkReal x409=((1.0)*x405);
IkReal x410=(sj19*x406);
IkReal x411=(sj19*x405);
IkReal x412=(x405*x407);
evalcond[0]=(x406+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=(((cj19*new_r01))+((new_r11*sj19))+(((-1.0)*x409)));
evalcond[2]=(x411+new_r00+((cj19*x406)));
evalcond[3]=((((-1.0)*new_r00*x408))+((cj19*new_r10))+(((-1.0)*x409)));
evalcond[4]=(((cj19*new_r11))+(((-1.0)*new_r01*x408))+(((-1.0)*x406)));
evalcond[5]=(x410+new_r01+(((-1.0)*x412)));
evalcond[6]=(x410+new_r10+(((-1.0)*x412)));
evalcond[7]=((((-1.0)*x406*x407))+new_r11+(((-1.0)*x405*x408)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x413=((((-1.0)*cj20))+new_r22);
IkReal x414=((((-1.0)*sj20))+new_r02);
IkReal x415=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x413;
evalcond[2]=x413;
evalcond[3]=x414;
evalcond[4]=new_r12;
evalcond[5]=x414;
evalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[9]=(((cj20*new_r02))+(((-1.0)*new_r22*x415)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x416=IKcos(j21);
IkReal x417=IKsin(j21);
IkReal x418=((1.0)*new_r02);
IkReal x419=((1.0)*x416);
evalcond[0]=(new_r20+((new_r02*x416)));
evalcond[1]=(new_r10+(((-1.0)*x417)));
evalcond[2]=(new_r11+(((-1.0)*x419)));
evalcond[3]=(((new_r22*x417))+new_r01);
evalcond[4]=((((-1.0)*x417*x418))+new_r21);
evalcond[5]=(new_r00+(((-1.0)*new_r22*x419)));
evalcond[6]=(((new_r01*new_r22))+x417+(((-1.0)*new_r21*x418)));
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x418))+(((-1.0)*x419)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x420=((((-1.0)*cj20))+new_r22);
IkReal x421=((1.0)*sj20);
IkReal x422=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x420;
evalcond[2]=x420;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x421))+(((-1.0)*new_r02)));
evalcond[6]=((((-1.0)*new_r00*x421))+((cj20*new_r20)));
evalcond[7]=(((cj20*new_r21))+(((-1.0)*new_r01*x421)));
evalcond[8]=((-1.0)+(((-1.0)*new_r02*x421))+((cj20*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x421))+(((-1.0)*new_r02*x422)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x423 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x423.valid){
continue;
}
CheckValue<IkReal> x424=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x424.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x423.value)+(((1.5707963267949)*(x424.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x425=IKsin(j21);
IkReal x426=IKcos(j21);
IkReal x427=((1.0)*new_r22);
IkReal x428=((1.0)*x426);
evalcond[0]=(new_r21+((new_r02*x425)));
evalcond[1]=((((-1.0)*new_r02*x428))+new_r20);
evalcond[2]=((((-1.0)*x425))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x428))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x425))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x426*x427))+(((-1.0)*new_r00)));
evalcond[6]=(x425+((new_r02*new_r21))+(((-1.0)*new_r01*x427)));
evalcond[7]=((((-1.0)*new_r00*x427))+(((-1.0)*x428))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x430=IKPowWithIntegerCheck(sj20,-1);
if(!x430.valid){
continue;
}
IkReal x429=x430.value;
CheckValue<IkReal> x431=IKPowWithIntegerCheck(cj19,-1);
if(!x431.valid){
continue;
}
CheckValue<IkReal> x432=IKPowWithIntegerCheck(cj20,-1);
if(!x432.valid){
continue;
}
if( IKabs((x429*(x431.value)*(x432.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x429)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x429*(x431.value)*(x432.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))))+IKsqr(((-1.0)*new_r20*x429))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x429*(x431.value)*(x432.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))), ((-1.0)*new_r20*x429));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x433=IKsin(j21);
IkReal x434=IKcos(j21);
IkReal x435=(cj20*sj19);
IkReal x436=(cj19*new_r01);
IkReal x437=((1.0)*sj20);
IkReal x438=(cj19*new_r00);
IkReal x439=((1.0)*sj19);
IkReal x440=((1.0)*x434);
IkReal x441=(cj20*x433);
IkReal x442=((1.0)*x433);
IkReal x443=(cj19*x440);
evalcond[0]=(((sj20*x434))+new_r20);
evalcond[1]=((((-1.0)*x433*x437))+new_r21);
evalcond[2]=(x436+x441+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x439))+(((-1.0)*x442))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x440))+(((-1.0)*new_r01*x439))+((cj19*new_r11)));
evalcond[5]=(((cj19*x441))+((sj19*x434))+new_r01);
evalcond[6]=((((-1.0)*cj20*x440))+x438+((new_r10*sj19)));
evalcond[7]=(((sj19*x433))+(((-1.0)*cj20*x443))+new_r00);
evalcond[8]=((((-1.0)*x443))+((x433*x435))+new_r11);
evalcond[9]=((((-1.0)*x435*x440))+(((-1.0)*cj19*x442))+new_r10);
evalcond[10]=(((new_r11*x435))+x433+((cj20*x436))+(((-1.0)*new_r21*x437)));
evalcond[11]=((((-1.0)*x440))+((new_r10*x435))+(((-1.0)*new_r20*x437))+((cj20*x438)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x445=IKPowWithIntegerCheck(sj20,-1);
if(!x445.valid){
continue;
}
IkReal x444=x445.value;
CheckValue<IkReal> x446=IKPowWithIntegerCheck(sj19,-1);
if(!x446.valid){
continue;
}
if( IKabs((x444*(x446.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x444)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x444*(x446.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x444))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x444*(x446.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x444));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x447=IKsin(j21);
IkReal x448=IKcos(j21);
IkReal x449=(cj20*sj19);
IkReal x450=(cj19*new_r01);
IkReal x451=((1.0)*sj20);
IkReal x452=(cj19*new_r00);
IkReal x453=((1.0)*sj19);
IkReal x454=((1.0)*x448);
IkReal x455=(cj20*x447);
IkReal x456=((1.0)*x447);
IkReal x457=(cj19*x454);
evalcond[0]=(((sj20*x448))+new_r20);
evalcond[1]=((((-1.0)*x447*x451))+new_r21);
evalcond[2]=(x455+x450+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x453))+(((-1.0)*x456))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x453))+(((-1.0)*x454))+((cj19*new_r11)));
evalcond[5]=(((sj19*x448))+((cj19*x455))+new_r01);
evalcond[6]=(x452+((new_r10*sj19))+(((-1.0)*cj20*x454)));
evalcond[7]=(((sj19*x447))+new_r00+(((-1.0)*cj20*x457)));
evalcond[8]=(((x447*x449))+(((-1.0)*x457))+new_r11);
evalcond[9]=((((-1.0)*cj19*x456))+new_r10+(((-1.0)*x449*x454)));
evalcond[10]=((((-1.0)*new_r21*x451))+((cj20*x450))+((new_r11*x449))+x447);
evalcond[11]=((((-1.0)*new_r20*x451))+((cj20*x452))+(((-1.0)*x454))+((new_r10*x449)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x458=IKPowWithIntegerCheck(IKsign(sj20),-1);
if(!x458.valid){
continue;
}
CheckValue<IkReal> x459 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x459.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x458.value)))+(x459.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x460=IKsin(j21);
IkReal x461=IKcos(j21);
IkReal x462=(cj20*sj19);
IkReal x463=(cj19*new_r01);
IkReal x464=((1.0)*sj20);
IkReal x465=(cj19*new_r00);
IkReal x466=((1.0)*sj19);
IkReal x467=((1.0)*x461);
IkReal x468=(cj20*x460);
IkReal x469=((1.0)*x460);
IkReal x470=(cj19*x467);
evalcond[0]=(new_r20+((sj20*x461)));
evalcond[1]=((((-1.0)*x460*x464))+new_r21);
evalcond[2]=(x468+x463+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x469))+(((-1.0)*new_r00*x466))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x466))+(((-1.0)*x467))+((cj19*new_r11)));
evalcond[5]=(((cj19*x468))+((sj19*x461))+new_r01);
evalcond[6]=(x465+((new_r10*sj19))+(((-1.0)*cj20*x467)));
evalcond[7]=(((sj19*x460))+new_r00+(((-1.0)*cj20*x470)));
evalcond[8]=((((-1.0)*x470))+((x460*x462))+new_r11);
evalcond[9]=((((-1.0)*x462*x467))+(((-1.0)*cj19*x469))+new_r10);
evalcond[10]=((((-1.0)*new_r21*x464))+((new_r11*x462))+((cj20*x463))+x460);
evalcond[11]=(((new_r10*x462))+((cj20*x465))+(((-1.0)*new_r20*x464))+(((-1.0)*x467)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j19array[1], cj19array[1], sj19array[1];
bool j19valid[1]={false};
_nj19 = 1;
CheckValue<IkReal> x471=IKPowWithIntegerCheck(IKsign(sj20),-1);
if(!x471.valid){
continue;
}
CheckValue<IkReal> x472 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x472.valid){
continue;
}
j19array[0]=((-1.5707963267949)+(((1.5707963267949)*(x471.value)))+(x472.value));
sj19array[0]=IKsin(j19array[0]);
cj19array[0]=IKcos(j19array[0]);
if( j19array[0] > IKPI )
{
    j19array[0]-=IK2PI;
}
else if( j19array[0] < -IKPI )
{    j19array[0]+=IK2PI;
}
j19valid[0] = true;
for(int ij19 = 0; ij19 < 1; ++ij19)
{
if( !j19valid[ij19] )
{
    continue;
}
_ij19[0] = ij19; _ij19[1] = -1;
for(int iij19 = ij19+1; iij19 < 1; ++iij19)
{
if( j19valid[iij19] && IKabs(cj19array[ij19]-cj19array[iij19]) < IKFAST_SOLUTION_THRESH && IKabs(sj19array[ij19]-sj19array[iij19]) < IKFAST_SOLUTION_THRESH )
{
    j19valid[iij19]=false; _ij19[1] = iij19; break; 
}
}
j19 = j19array[ij19]; cj19 = cj19array[ij19]; sj19 = sj19array[ij19];
{
IkReal evalcond[8];
IkReal x473=IKcos(j19);
IkReal x474=IKsin(j19);
IkReal x475=((1.0)*sj20);
IkReal x476=(new_r02*x473);
IkReal x477=(new_r12*x474);
IkReal x478=(sj20*x473);
IkReal x479=(sj20*x474);
evalcond[0]=((((-1.0)*x473*x475))+new_r02);
evalcond[1]=(new_r12+(((-1.0)*x474*x475)));
evalcond[2]=(((new_r12*x473))+(((-1.0)*new_r02*x474)));
evalcond[3]=((((-1.0)*x475))+x476+x477);
evalcond[4]=(((new_r10*x479))+((new_r00*x478))+((cj20*new_r20)));
evalcond[5]=(((new_r01*x478))+((new_r11*x479))+((cj20*new_r21)));
evalcond[6]=((-1.0)+((cj20*new_r22))+((sj20*x476))+((sj20*x477)));
evalcond[7]=(((cj20*x477))+((cj20*x476))+(((-1.0)*new_r22*x475)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j21eval[2];
IkReal x480=((1.0)*cj17);
IkReal x481=(cj18*sj16);
IkReal x482=(cj16*sj17);
IkReal x483=(sj16*sj18);
IkReal x484=(sj16*sj17);
IkReal x485=(cj16*cj18);
IkReal x486=(sj17*sj18);
IkReal x487=(cj16*sj18);
IkReal x488=(cj18*sj15*sj17);
IkReal x489=(x483+(((-1.0)*x480*x485)));
IkReal x490=x206;
IkReal x491=x207;
IkReal x492=(x485+(((-1.0)*x480*x483)));
IkReal x493=(cj15*x492);
IkReal x494=x210;
IkReal x495=x211;
IkReal x496=(cj15*x494);
IkReal x497=(((cj15*x486))+((sj15*x492)));
IkReal x498=((((-1.0)*sj15*x486))+x493);
IkReal x499=(((cj15*cj18*sj17))+((sj15*x494)));
IkReal x500=((((-1.0)*x488))+x496);
new_r00=(((r20*x489))+((r00*x500))+((r10*x499)));
new_r01=(((r11*x499))+((r01*x500))+((r21*x489)));
new_r02=(((r12*x499))+((r22*x489))+((r02*(((((-1.0)*x488))+x496)))));
new_r10=(((r20*x482))+((r10*x490))+((r00*x491)));
new_r11=(((r11*x490))+((r21*x482))+((r01*x491)));
new_r12=(((r02*x491))+((r12*x490))+((r22*x482)));
new_r20=(((r00*(((((-1.0)*sj15*x486))+x493))))+((r10*x497))+((r20*x495)));
new_r21=(((r11*x497))+((r21*x495))+((r01*x498)));
new_r22=(((r02*x498))+((r22*x495))+((r12*x497)));
j21eval[0]=sj20;
j21eval[1]=IKsign(sj20);
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[2];
IkReal x501=((1.0)*cj17);
IkReal x502=(cj18*sj16);
IkReal x503=(cj16*sj17);
IkReal x504=(sj16*sj18);
IkReal x505=(sj16*sj17);
IkReal x506=(cj16*cj18);
IkReal x507=(sj17*sj18);
IkReal x508=(cj16*sj18);
IkReal x509=(cj18*sj15*sj17);
IkReal x510=((((-1.0)*x501*x506))+x504);
IkReal x511=x206;
IkReal x512=x207;
IkReal x513=((((-1.0)*x501*x504))+x506);
IkReal x514=(cj15*x513);
IkReal x515=x210;
IkReal x516=x211;
IkReal x517=(cj15*x515);
IkReal x518=(((cj15*x507))+((sj15*x513)));
IkReal x519=((((-1.0)*sj15*x507))+x514);
IkReal x520=(((cj15*cj18*sj17))+((sj15*x515)));
IkReal x521=(x517+(((-1.0)*x509)));
new_r00=(((r20*x510))+((r10*x520))+((r00*x521)));
new_r01=(((r11*x520))+((r21*x510))+((r01*x521)));
new_r02=(((r12*x520))+((r22*x510))+((r02*((x517+(((-1.0)*x509)))))));
new_r10=(((r20*x503))+((r10*x511))+((r00*x512)));
new_r11=(((r01*x512))+((r11*x511))+((r21*x503)));
new_r12=(((r22*x503))+((r02*x512))+((r12*x511)));
new_r20=(((r00*(((((-1.0)*sj15*x507))+x514))))+((r20*x516))+((r10*x518)));
new_r21=(((r01*x519))+((r11*x518))+((r21*x516)));
new_r22=(((r02*x519))+((r22*x516))+((r12*x518)));
j21eval[0]=sj19;
j21eval[1]=sj20;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  )
{
{
IkReal j21eval[3];
IkReal x522=((1.0)*cj17);
IkReal x523=(cj18*sj16);
IkReal x524=(cj16*sj17);
IkReal x525=(sj16*sj18);
IkReal x526=(sj16*sj17);
IkReal x527=(cj16*cj18);
IkReal x528=(sj17*sj18);
IkReal x529=(cj16*sj18);
IkReal x530=(cj18*sj15*sj17);
IkReal x531=(x525+(((-1.0)*x522*x527)));
IkReal x532=x206;
IkReal x533=x207;
IkReal x534=(x527+(((-1.0)*x522*x525)));
IkReal x535=(cj15*x534);
IkReal x536=x210;
IkReal x537=x211;
IkReal x538=(cj15*x536);
IkReal x539=(((sj15*x534))+((cj15*x528)));
IkReal x540=(x535+(((-1.0)*sj15*x528)));
IkReal x541=(((cj15*cj18*sj17))+((sj15*x536)));
IkReal x542=((((-1.0)*x530))+x538);
new_r00=(((r20*x531))+((r10*x541))+((r00*x542)));
new_r01=(((r11*x541))+((r21*x531))+((r01*x542)));
new_r02=(((r02*(((((-1.0)*x530))+x538))))+((r12*x541))+((r22*x531)));
new_r10=(((r20*x524))+((r10*x532))+((r00*x533)));
new_r11=(((r21*x524))+((r11*x532))+((r01*x533)));
new_r12=(((r02*x533))+((r12*x532))+((r22*x524)));
new_r20=(((r20*x537))+((r10*x539))+((r00*((x535+(((-1.0)*sj15*x528)))))));
new_r21=(((r11*x539))+((r21*x537))+((r01*x540)));
new_r22=(((r02*x540))+((r12*x539))+((r22*x537)));
j21eval[0]=cj19;
j21eval[1]=cj20;
j21eval[2]=sj20;
if( IKabs(j21eval[0]) < 0.0000010000000000  || IKabs(j21eval[1]) < 0.0000010000000000  || IKabs(j21eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x543=((((-1.0)*cj20))+new_r22);
IkReal x544=((((-1.0)*sj20))+new_r12);
IkReal x545=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x543;
evalcond[2]=x543;
evalcond[3]=new_r02;
evalcond[4]=x544;
evalcond[5]=x544;
evalcond[6]=(((new_r10*sj20))+((cj20*new_r20)));
evalcond[7]=(((new_r11*sj20))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj20))+((cj20*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x545))+((cj20*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x546 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x546.valid){
continue;
}
CheckValue<IkReal> x547=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x547.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x546.value)+(((1.5707963267949)*(x547.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x548=IKsin(j21);
IkReal x549=IKcos(j21);
IkReal x550=((1.0)*new_r12);
IkReal x551=((1.0)*x549);
IkReal x552=((1.0)*x548);
evalcond[0]=(((new_r12*x549))+new_r20);
evalcond[1]=(((new_r22*x548))+new_r11);
evalcond[2]=((((-1.0)*x548*x550))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x551))+new_r10);
evalcond[4]=((((-1.0)*x552))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x551))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x550))+x548+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*x551))+(((-1.0)*new_r20*x550))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x553=((((-1.0)*cj20))+new_r22);
IkReal x554=((1.0)*new_r12);
IkReal x555=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j19)))), 6.28318530717959)));
evalcond[1]=x553;
evalcond[2]=x553;
evalcond[3]=new_r02;
evalcond[4]=(sj20+new_r12);
evalcond[5]=((((-1.0)*x554))+(((-1.0)*x555)));
evalcond[6]=((((-1.0)*new_r10*x555))+((cj20*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x555))+((cj20*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*sj20*x554))+((cj20*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x555))+(((-1.0)*cj20*x554)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r00, new_r01);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x556=IKsin(j21);
IkReal x557=IKcos(j21);
IkReal x558=((1.0)*new_r10);
IkReal x559=((1.0)*new_r11);
IkReal x560=((1.0)*x557);
evalcond[0]=(((new_r12*x556))+new_r21);
evalcond[1]=((((-1.0)*x556))+new_r00);
evalcond[2]=(new_r01+(((-1.0)*x560)));
evalcond[3]=((((-1.0)*new_r12*x560))+new_r20);
evalcond[4]=((((-1.0)*x559))+((new_r22*x556)));
evalcond[5]=((((-1.0)*x558))+(((-1.0)*new_r22*x560)));
evalcond[6]=((((-1.0)*new_r22*x559))+((new_r12*new_r21))+x556);
evalcond[7]=((((-1.0)*new_r22*x558))+((new_r12*new_r20))+(((-1.0)*x560)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x561=((1.0)*sj19);
IkReal x562=((((-1.0)*new_r02*x561))+((cj19*new_r12)));
IkReal x563=(((new_r10*sj19))+((cj19*new_r00)));
IkReal x564=(((cj19*new_r01))+((new_r11*sj19)));
IkReal x565=((-1.0)+((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj19))+new_r02);
evalcond[3]=(new_r12+(((-1.0)*x561)));
evalcond[4]=x562;
evalcond[5]=x562;
evalcond[6]=x565;
evalcond[7]=x564;
evalcond[8]=x563;
evalcond[9]=x563;
evalcond[10]=x564;
evalcond[11]=x565;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x566=IKcos(j21);
IkReal x567=IKsin(j21);
IkReal x568=((1.0)*new_r12);
IkReal x569=((1.0)*x567);
IkReal x570=((1.0)*x566);
evalcond[0]=(x566+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x569)));
evalcond[2]=(new_r01+((new_r12*x566)));
evalcond[3]=(new_r00+((new_r12*x567)));
evalcond[4]=((((-1.0)*new_r02*x570))+new_r11);
evalcond[5]=((((-1.0)*new_r02*x569))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x568))+((new_r02*new_r10))+(((-1.0)*x569)));
evalcond[7]=((((-1.0)*x570))+((new_r02*new_r11))+(((-1.0)*new_r01*x568)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x571=(new_r12*sj19);
IkReal x572=((1.0)*sj19);
IkReal x573=(cj19*new_r00);
IkReal x574=((1.0)*cj19);
IkReal x575=((((-1.0)*new_r02*x572))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j20)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj19+new_r02);
evalcond[3]=(sj19+new_r12);
evalcond[4]=x575;
evalcond[5]=x575;
evalcond[6]=((1.0)+x571+((cj19*new_r02)));
evalcond[7]=(((cj19*new_r01))+((new_r11*sj19)));
evalcond[8]=(x573+((new_r10*sj19)));
evalcond[9]=((((-1.0)*new_r10*x572))+(((-1.0)*x573)));
evalcond[10]=((((-1.0)*new_r11*x572))+(((-1.0)*new_r01*x574)));
evalcond[11]=((-1.0)+(((-1.0)*new_r02*x574))+(((-1.0)*x571)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x576=IKcos(j21);
IkReal x577=IKsin(j21);
IkReal x578=((1.0)*new_r02);
IkReal x579=((1.0)*x576);
IkReal x580=((1.0)*x577);
evalcond[0]=(x577+new_r21);
evalcond[1]=((((-1.0)*x579))+new_r20);
evalcond[2]=(new_r11+((new_r02*x576)));
evalcond[3]=(new_r10+((new_r02*x577)));
evalcond[4]=((((-1.0)*new_r12*x579))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x580))+new_r00);
evalcond[6]=((((-1.0)*new_r10*x578))+((new_r00*new_r12))+(((-1.0)*x580)));
evalcond[7]=((((-1.0)*new_r11*x578))+((new_r01*new_r12))+(((-1.0)*x579)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x581=((((-1.0)*new_r02*sj19))+((cj19*new_r12)));
IkReal x582=(((cj19*new_r02))+((new_r12*sj19)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j20))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x581;
evalcond[7]=x581;
evalcond[8]=x582;
evalcond[9]=x582;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x583=((1.0)*sj19);
if( IKabs(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x583)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x583))+((cj19*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x583))))+IKsqr(((((-1.0)*new_r01*x583))+((cj19*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*cj19*new_r01))+(((-1.0)*new_r00*x583))), ((((-1.0)*new_r01*x583))+((cj19*new_r00))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x584=IKsin(j21);
IkReal x585=IKcos(j21);
IkReal x586=((1.0)*sj19);
IkReal x587=((1.0)*x585);
IkReal x588=(sj19*x584);
IkReal x589=((1.0)*x584);
IkReal x590=(cj19*x587);
evalcond[0]=(x584+((cj19*new_r01))+((new_r11*sj19)));
evalcond[1]=(((sj19*x585))+((cj19*x584))+new_r01);
evalcond[2]=(((new_r10*sj19))+((cj19*new_r00))+(((-1.0)*x587)));
evalcond[3]=(((cj19*new_r10))+(((-1.0)*x589))+(((-1.0)*new_r00*x586)));
evalcond[4]=((((-1.0)*new_r01*x586))+((cj19*new_r11))+(((-1.0)*x587)));
evalcond[5]=((((-1.0)*x590))+x588+new_r00);
evalcond[6]=((((-1.0)*x590))+x588+new_r11);
evalcond[7]=((((-1.0)*x585*x586))+(((-1.0)*cj19*x589))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x591=(new_r12*sj19);
IkReal x592=((1.0)*new_r02);
IkReal x593=((((-1.0)*sj19*x592))+((cj19*new_r12)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j20)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x593;
evalcond[7]=x593;
evalcond[8]=(x591+((cj19*new_r02)));
evalcond[9]=((((-1.0)*cj19*x592))+(((-1.0)*x591)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
IkReal x594=((1.0)*sj19);
if( IKabs(((((-1.0)*new_r00*x594))+((cj19*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x594)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x594))+((cj19*new_r01))))+IKsqr(((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x594))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(((((-1.0)*new_r00*x594))+((cj19*new_r01))), ((((-1.0)*cj19*new_r00))+(((-1.0)*new_r01*x594))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x595=IKsin(j21);
IkReal x596=IKcos(j21);
IkReal x597=((1.0)*cj19);
IkReal x598=((1.0)*sj19);
IkReal x599=((1.0)*x595);
IkReal x600=(sj19*x596);
IkReal x601=(sj19*x595);
IkReal x602=(x595*x597);
evalcond[0]=(x596+((new_r10*sj19))+((cj19*new_r00)));
evalcond[1]=((((-1.0)*x599))+((cj19*new_r01))+((new_r11*sj19)));
evalcond[2]=(((cj19*x596))+x601+new_r00);
evalcond[3]=((((-1.0)*new_r00*x598))+(((-1.0)*x599))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x598))+(((-1.0)*x596))+((cj19*new_r11)));
evalcond[5]=(x600+(((-1.0)*x602))+new_r01);
evalcond[6]=(x600+(((-1.0)*x602))+new_r10);
evalcond[7]=((((-1.0)*x596*x597))+(((-1.0)*x595*x598))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x603=((((-1.0)*cj20))+new_r22);
IkReal x604=((((-1.0)*sj20))+new_r02);
IkReal x605=((1.0)*sj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j19))), 6.28318530717959)));
evalcond[1]=x603;
evalcond[2]=x603;
evalcond[3]=x604;
evalcond[4]=new_r12;
evalcond[5]=x604;
evalcond[6]=(((new_r00*sj20))+((cj20*new_r20)));
evalcond[7]=(((new_r01*sj20))+((cj20*new_r21)));
evalcond[8]=((-1.0)+((cj20*new_r22))+((new_r02*sj20)));
evalcond[9]=((((-1.0)*new_r22*x605))+((cj20*new_r02)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2(new_r10, new_r11);
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x606=IKcos(j21);
IkReal x607=IKsin(j21);
IkReal x608=((1.0)*new_r02);
IkReal x609=((1.0)*x606);
evalcond[0]=(((new_r02*x606))+new_r20);
evalcond[1]=((((-1.0)*x607))+new_r10);
evalcond[2]=((((-1.0)*x609))+new_r11);
evalcond[3]=(((new_r22*x607))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x607*x608)));
evalcond[5]=((((-1.0)*new_r22*x609))+new_r00);
evalcond[6]=(((new_r01*new_r22))+x607+(((-1.0)*new_r21*x608)));
evalcond[7]=((((-1.0)*new_r20*x608))+((new_r00*new_r22))+(((-1.0)*x609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x610=((((-1.0)*cj20))+new_r22);
IkReal x611=((1.0)*sj20);
IkReal x612=((1.0)*cj20);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j19)))), 6.28318530717959)));
evalcond[1]=x610;
evalcond[2]=x610;
evalcond[3]=(sj20+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x611))+(((-1.0)*new_r02)));
evalcond[6]=((((-1.0)*new_r00*x611))+((cj20*new_r20)));
evalcond[7]=(((cj20*new_r21))+(((-1.0)*new_r01*x611)));
evalcond[8]=((-1.0)+(((-1.0)*new_r02*x611))+((cj20*new_r22)));
evalcond[9]=((((-1.0)*new_r02*x612))+(((-1.0)*new_r22*x611)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x613 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x613.valid){
continue;
}
CheckValue<IkReal> x614=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x614.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(x613.value)+(((1.5707963267949)*(x614.value))));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[8];
IkReal x615=IKsin(j21);
IkReal x616=IKcos(j21);
IkReal x617=((1.0)*new_r22);
IkReal x618=((1.0)*x616);
evalcond[0]=(((new_r02*x615))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x618))+new_r20);
evalcond[2]=((((-1.0)*x615))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*x618))+(((-1.0)*new_r11)));
evalcond[4]=((((-1.0)*new_r01))+((new_r22*x615)));
evalcond[5]=((((-1.0)*new_r00))+(((-1.0)*x616*x617)));
evalcond[6]=(x615+((new_r02*new_r21))+(((-1.0)*new_r01*x617)));
evalcond[7]=((((-1.0)*x618))+(((-1.0)*new_r00*x617))+((new_r02*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j21]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x620=IKPowWithIntegerCheck(sj20,-1);
if(!x620.valid){
continue;
}
IkReal x619=x620.value;
CheckValue<IkReal> x621=IKPowWithIntegerCheck(cj19,-1);
if(!x621.valid){
continue;
}
CheckValue<IkReal> x622=IKPowWithIntegerCheck(cj20,-1);
if(!x622.valid){
continue;
}
if( IKabs((x619*(x621.value)*(x622.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x619)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x619*(x621.value)*(x622.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))))+IKsqr(((-1.0)*new_r20*x619))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x619*(x621.value)*(x622.value)*(((((-1.0)*new_r01*sj20))+((new_r20*sj19))))), ((-1.0)*new_r20*x619));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x623=IKsin(j21);
IkReal x624=IKcos(j21);
IkReal x625=(cj20*sj19);
IkReal x626=(cj19*new_r01);
IkReal x627=((1.0)*sj20);
IkReal x628=(cj19*new_r00);
IkReal x629=((1.0)*sj19);
IkReal x630=((1.0)*x624);
IkReal x631=(cj20*x623);
IkReal x632=((1.0)*x623);
IkReal x633=(cj19*x630);
evalcond[0]=(new_r20+((sj20*x624)));
evalcond[1]=((((-1.0)*x623*x627))+new_r21);
evalcond[2]=(x626+x631+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x629))+(((-1.0)*x632))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*new_r01*x629))+(((-1.0)*x630))+((cj19*new_r11)));
evalcond[5]=(((cj19*x631))+((sj19*x624))+new_r01);
evalcond[6]=((((-1.0)*cj20*x630))+x628+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x633))+((sj19*x623))+new_r00);
evalcond[8]=((((-1.0)*x633))+new_r11+((x623*x625)));
evalcond[9]=((((-1.0)*x625*x630))+new_r10+(((-1.0)*cj19*x632)));
evalcond[10]=(((cj20*x626))+(((-1.0)*new_r21*x627))+((new_r11*x625))+x623);
evalcond[11]=(((cj20*x628))+(((-1.0)*x630))+((new_r10*x625))+(((-1.0)*new_r20*x627)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x635=IKPowWithIntegerCheck(sj20,-1);
if(!x635.valid){
continue;
}
IkReal x634=x635.value;
CheckValue<IkReal> x636=IKPowWithIntegerCheck(sj19,-1);
if(!x636.valid){
continue;
}
if( IKabs((x634*(x636.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x634)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x634*(x636.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))))+IKsqr(((-1.0)*new_r20*x634))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j21array[0]=IKatan2((x634*(x636.value)*(((((-1.0)*new_r00*sj20))+(((-1.0)*cj19*cj20*new_r20))))), ((-1.0)*new_r20*x634));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x637=IKsin(j21);
IkReal x638=IKcos(j21);
IkReal x639=(cj20*sj19);
IkReal x640=(cj19*new_r01);
IkReal x641=((1.0)*sj20);
IkReal x642=(cj19*new_r00);
IkReal x643=((1.0)*sj19);
IkReal x644=((1.0)*x638);
IkReal x645=(cj20*x637);
IkReal x646=((1.0)*x637);
IkReal x647=(cj19*x644);
evalcond[0]=(new_r20+((sj20*x638)));
evalcond[1]=((((-1.0)*x637*x641))+new_r21);
evalcond[2]=(x645+x640+((new_r11*sj19)));
evalcond[3]=((((-1.0)*x646))+(((-1.0)*new_r00*x643))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x644))+(((-1.0)*new_r01*x643))+((cj19*new_r11)));
evalcond[5]=(((cj19*x645))+((sj19*x638))+new_r01);
evalcond[6]=((((-1.0)*cj20*x644))+x642+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x647))+((sj19*x637))+new_r00);
evalcond[8]=((((-1.0)*x647))+new_r11+((x637*x639)));
evalcond[9]=((((-1.0)*x639*x644))+(((-1.0)*cj19*x646))+new_r10);
evalcond[10]=(((cj20*x640))+(((-1.0)*new_r21*x641))+((new_r11*x639))+x637);
evalcond[11]=(((cj20*x642))+(((-1.0)*x644))+((new_r10*x639))+(((-1.0)*new_r20*x641)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j21array[1], cj21array[1], sj21array[1];
bool j21valid[1]={false};
_nj21 = 1;
CheckValue<IkReal> x648=IKPowWithIntegerCheck(IKsign(sj20),-1);
if(!x648.valid){
continue;
}
CheckValue<IkReal> x649 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x649.valid){
continue;
}
j21array[0]=((-1.5707963267949)+(((1.5707963267949)*(x648.value)))+(x649.value));
sj21array[0]=IKsin(j21array[0]);
cj21array[0]=IKcos(j21array[0]);
if( j21array[0] > IKPI )
{
    j21array[0]-=IK2PI;
}
else if( j21array[0] < -IKPI )
{    j21array[0]+=IK2PI;
}
j21valid[0] = true;
for(int ij21 = 0; ij21 < 1; ++ij21)
{
if( !j21valid[ij21] )
{
    continue;
}
_ij21[0] = ij21; _ij21[1] = -1;
for(int iij21 = ij21+1; iij21 < 1; ++iij21)
{
if( j21valid[iij21] && IKabs(cj21array[ij21]-cj21array[iij21]) < IKFAST_SOLUTION_THRESH && IKabs(sj21array[ij21]-sj21array[iij21]) < IKFAST_SOLUTION_THRESH )
{
    j21valid[iij21]=false; _ij21[1] = iij21; break; 
}
}
j21 = j21array[ij21]; cj21 = cj21array[ij21]; sj21 = sj21array[ij21];
{
IkReal evalcond[12];
IkReal x650=IKsin(j21);
IkReal x651=IKcos(j21);
IkReal x652=(cj20*sj19);
IkReal x653=(cj19*new_r01);
IkReal x654=((1.0)*sj20);
IkReal x655=(cj19*new_r00);
IkReal x656=((1.0)*sj19);
IkReal x657=((1.0)*x651);
IkReal x658=(cj20*x650);
IkReal x659=((1.0)*x650);
IkReal x660=(cj19*x657);
evalcond[0]=(((sj20*x651))+new_r20);
evalcond[1]=((((-1.0)*x650*x654))+new_r21);
evalcond[2]=(x653+x658+((new_r11*sj19)));
evalcond[3]=((((-1.0)*new_r00*x656))+(((-1.0)*x659))+((cj19*new_r10)));
evalcond[4]=((((-1.0)*x657))+(((-1.0)*new_r01*x656))+((cj19*new_r11)));
evalcond[5]=(((cj19*x658))+new_r01+((sj19*x651)));
evalcond[6]=((((-1.0)*cj20*x657))+x655+((new_r10*sj19)));
evalcond[7]=((((-1.0)*cj20*x660))+new_r00+((sj19*x650)));
evalcond[8]=((((-1.0)*x660))+new_r11+((x650*x652)));
evalcond[9]=((((-1.0)*cj19*x659))+new_r10+(((-1.0)*x652*x657)));
evalcond[10]=(((cj20*x653))+x650+((new_r11*x652))+(((-1.0)*new_r21*x654)));
evalcond[11]=(((cj20*x655))+(((-1.0)*x657))+(((-1.0)*new_r20*x654))+((new_r10*x652)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j15;
vinfos[0].indices[0] = _ij15[0];
vinfos[0].indices[1] = _ij15[1];
vinfos[0].maxsolutions = _nj15;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j16;
vinfos[1].indices[0] = _ij16[0];
vinfos[1].indices[1] = _ij16[1];
vinfos[1].maxsolutions = _nj16;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j17;
vinfos[2].indices[0] = _ij17[0];
vinfos[2].indices[1] = _ij17[1];
vinfos[2].maxsolutions = _nj17;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j18;
vinfos[3].indices[0] = _ij18[0];
vinfos[3].indices[1] = _ij18[1];
vinfos[3].maxsolutions = _nj18;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j19;
vinfos[4].indices[0] = _ij19[0];
vinfos[4].indices[1] = _ij19[1];
vinfos[4].maxsolutions = _nj19;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j20;
vinfos[5].indices[0] = _ij20[0];
vinfos[5].indices[1] = _ij20[1];
vinfos[5].maxsolutions = _nj20;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j21;
vinfos[6].indices[0] = _ij21[0];
vinfos[6].indices[1] = _ij21[1];
vinfos[6].maxsolutions = _nj21;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "9ff4f1d77a61494bbd09f843fedb0314"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
