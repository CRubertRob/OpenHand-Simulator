#define IKFAST_NAMESPACE ik_pr2_rightarm
#include "plugindefs.h"

/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000048 generated on 2014-10-08 16:07:45.210201
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000048);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)2e-6)
#endif

// used to check input to atan2 for degenerate cases
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)2e-6)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.000005)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56;
x0=IKcos(j[0]);
x1=IKcos(j[1]);
x2=IKsin(j[3]);
x3=IKcos(j[3]);
x4=IKsin(j[1]);
x5=IKsin(j[2]);
x6=IKcos(j[2]);
x7=IKsin(j[0]);
x8=IKcos(j[4]);
x9=IKsin(j[4]);
x10=IKsin(j[5]);
x11=IKcos(j[5]);
x12=IKcos(j[6]);
x13=IKsin(j[6]);
x14=((1.0)*x10);
x15=((1.0)*x9);
x16=((0.321)*x6);
x17=((1.0)*x7);
x18=((1.0)*x11);
x19=((1.0)*x6);
x20=((0.4)*x1);
x21=(x1*x2);
x22=(x0*x6);
x23=(x2*x4);
x24=(x0*x5);
x25=((-1.0)*x0);
x26=(x3*x4);
x27=((-1.0)*x3);
x28=(x4*x7);
x29=((-1.0)*x2);
x30=(x1*x3);
x31=(x30*x7);
x32=(x1*x5*x8);
x33=((1.0)*x0*x21);
x34=(x17*x21);
x35=(x19*x30);
x36=((((-1.0)*x17*x6))+((x24*x4)));
x37=((((-1.0)*x17*x4*x6))+x24);
x38=(x22+((x28*x5)));
x39=((((-1.0)*x23))+x35);
x40=((1.0)*x37);
x41=((((-1.0)*x17*x5))+(((-1.0)*x0*x19*x4)));
x42=(x36*x9);
x43=(x38*x9);
x44=(x3*x37);
x45=(((x19*x21))+(((1.0)*x26)));
x46=(x36*x8);
x47=(x2*x37);
x48=(x38*x8);
x49=(x3*x41);
x50=((-1.0)*x41);
x51=(((x1*x5*x9))+((x8*(((((-1.0)*x35))+x23)))));
x52=(((x27*x41))+x33);
x53=(x52*x9);
x54=(x43+((x8*(((((-1.0)*x21*x7))+x44)))));
x55=((((-1.0)*x18*x51))+(((-1.0)*x14*x45)));
x56=((((-1.0)*x18*(((((1.0)*x8*(((((-1.0)*x33))+x49))))+(((1.0)*x42))))))+((x14*(((((-1.0)*x25*x30))+(((-1.0)*x29*x41)))))));
eerot[0]=(((x11*((((x2*x41))+((x0*x30))))))+((x10*((((x8*((((x21*x25))+x49))))+x42)))));
eerot[1]=(((x13*x56))+((x12*((x46+x53)))));
eerot[2]=(((x12*x56))+((x13*(((((-1.0)*x46))+(((-1.0)*x53)))))));
eetrans[0]=(((x0*x20))+(((0.1)*x0))+(((0.321)*x0*x30))+((x2*(((((-0.321)*x5*x7))+(((-1.0)*x0*x16*x4)))))));
eerot[3]=(((x11*((x31+x47))))+((x10*((((x8*(((((-1.0)*x34))+x44))))+x43)))));
eerot[4]=((((-1.0)*x13*((((x14*(((((-1.0)*x17*x30))+(((-1.0)*x2*x40))))))+((x18*x54))))))+((x12*((((x9*((((x27*x37))+x34))))+x48)))));
eerot[5]=(((x12*(((((-1.0)*x11*x54))+(((-1.0)*x10*((((x29*x37))+((x1*x27*x7))))))))))+(((-1.0)*x13*((((x15*(((((-1.0)*x3*x40))+x34))))+(((1.0)*x48)))))));
eetrans[1]=((-0.188)+(((0.1)*x7))+(((0.321)*x31))+((x2*(((((-1.0)*x16*x28))+(((0.321)*x24))))))+((x20*x7)));
eerot[6]=(((x10*x51))+(((-1.0)*x11*x45)));
eerot[7]=(((x13*x55))+((x12*((x32+((x39*x9)))))));
eerot[8]=(((x12*x55))+((x13*(((((-1.0)*x32))+(((-1.0)*x15*x39)))))));
eetrans[2]=((((-1.0)*x16*x21))+(((-0.4)*x4))+(((-0.321)*x26)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j27,cj27,sj27,htj27,j27mul,j28,cj28,sj28,htj28,j28mul,j30,cj30,sj30,htj30,j30mul,j31,cj31,sj31,htj31,j31mul,j32,cj32,sj32,htj32,j32mul,j33,cj33,sj33,htj33,j33mul,j29,cj29,sj29,htj29,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij27[2], _nj27,_ij28[2], _nj28,_ij30[2], _nj30,_ij31[2], _nj31,_ij32[2], _nj32,_ij33[2], _nj33,_ij29[2], _nj29;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j27=numeric_limits<IkReal>::quiet_NaN(); _ij27[0] = -1; _ij27[1] = -1; _nj27 = -1; j28=numeric_limits<IkReal>::quiet_NaN(); _ij28[0] = -1; _ij28[1] = -1; _nj28 = -1; j30=numeric_limits<IkReal>::quiet_NaN(); _ij30[0] = -1; _ij30[1] = -1; _nj30 = -1; j31=numeric_limits<IkReal>::quiet_NaN(); _ij31[0] = -1; _ij31[1] = -1; _nj31 = -1; j32=numeric_limits<IkReal>::quiet_NaN(); _ij32[0] = -1; _ij32[1] = -1; _nj32 = -1; j33=numeric_limits<IkReal>::quiet_NaN(); _ij33[0] = -1; _ij33[1] = -1; _nj33 = -1;  _ij29[0] = -1; _ij29[1] = -1; _nj29 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j29=pfree[0]; cj29=cos(pfree[0]); sj29=sin(pfree[0]), htj29=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r02);
new_r01=r01;
new_r02=r00;
new_px=px;
new_r10=((-1.0)*r12);
new_r11=r11;
new_r12=r10;
new_py=((0.188)+py);
new_r20=((-1.0)*r22);
new_r21=r21;
new_r22=r20;
new_pz=pz;
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x57=((1.0)*px);
IkReal x58=((1.0)*pz);
IkReal x59=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x59))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x58)));
rxp0_2=((((-1.0)*r10*x57))+((py*r00)));
rxp1_0=((((-1.0)*r21*x59))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x58)));
rxp1_2=((((-1.0)*r11*x57))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x59)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x58)));
rxp2_2=((((-1.0)*r12*x57))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x60=((0.2)*px);
IkReal x61=((1.0)*pp);
IkReal x62=((0.509841)+x60+(((-1.0)*x61)));
IkReal x63=((-0.003759)+x60+(((-1.0)*x61)));
IkReal x64=(x60+x61);
IkReal x65=((0.509841)+(((-1.0)*x64)));
IkReal x66=((-0.003759)+(((-1.0)*x64)));
IkReal gconst0=x62;
IkReal gconst1=x63;
IkReal gconst2=x62;
IkReal gconst3=x63;
IkReal gconst4=x65;
IkReal gconst5=x66;
IkReal gconst6=x65;
IkReal gconst7=x66;
IkReal x67=py*py;
IkReal x68=sj29*sj29;
IkReal x69=px*px;
IkReal x70=((1.0)*gconst4);
IkReal x71=(gconst5*gconst7);
IkReal x72=(gconst0*gconst3);
IkReal x73=(gconst1*gconst2);
IkReal x74=((2.0)*gconst5);
IkReal x75=((1.0)*gconst0);
IkReal x76=(gconst1*gconst7);
IkReal x77=(gconst0*gconst6);
IkReal x78=(gconst1*gconst3);
IkReal x79=(gconst4*gconst7);
IkReal x80=((2.0)*gconst0);
IkReal x81=(gconst1*gconst6);
IkReal x82=(gconst0*gconst7);
IkReal x83=((2.0)*gconst4);
IkReal x84=(gconst3*gconst5);
IkReal x85=(gconst2*gconst5);
IkReal x86=(gconst3*gconst4);
IkReal x87=(gconst2*gconst4);
IkReal x88=(gconst4*gconst6);
IkReal x89=(gconst5*gconst6);
IkReal x90=(gconst0*gconst2);
IkReal x91=((1.05513984)*px*py);
IkReal x92=(gconst6*x67);
IkReal x93=((4.0)*px*py);
IkReal x94=((4.0)*x69);
IkReal x95=(gconst2*x67);
IkReal x96=(py*x68);
IkReal x97=((2.0)*x67);
IkReal x98=((1.0)*x67);
IkReal x99=((0.824328)*x68);
IkReal x100=((0.412164)*x68);
IkReal x101=(x67*x79);
IkReal x102=(x67*x89);
IkReal x103=(x67*x85);
IkReal x104=(x67*x86);
IkReal x105=(x67*x82);
IkReal x106=(x67*x81);
IkReal x107=((0.0834355125792)*x96);
IkReal x108=(x67*x73);
IkReal x109=(x67*x72);
IkReal x110=(x68*x85);
IkReal x111=(x67*x68);
IkReal x112=(x71*x98);
IkReal x113=(x70*x92);
IkReal x114=(x100*x89);
IkReal x115=(x87*x93);
IkReal x116=(x76*x93);
IkReal x117=(x84*x93);
IkReal x118=(x77*x93);
IkReal x119=(x86*x93);
IkReal x120=(x82*x93);
IkReal x121=(x85*x93);
IkReal x122=(x81*x93);
IkReal x123=(x100*x85);
IkReal x124=((0.06594624)*x111);
IkReal x125=(x76*x98);
IkReal x126=(x70*x95);
IkReal x127=(x75*x92);
IkReal x128=(x100*x81);
IkReal x129=(x84*x98);
IkReal x130=((0.3297312)*pp*x96);
IkReal x131=((0.06594624)*px*x96);
IkReal x132=(x75*x95);
IkReal x133=(x100*x73);
IkReal x134=(x78*x98);
IkReal x135=(x108+x109);
IkReal x136=(x101+x102);
IkReal x137=(x134+x133+x132);
IkReal x138=(x113+x112+x114);
IkReal x139=(x104+x105+x106+x103);
IkReal x140=(x122+x120+x121+x119);
IkReal x141=(x117+x116+x115+x118);
IkReal x142=(x126+x127+x124+x125+x123+x128+x129);
op[0]=(x136+(((-1.0)*x138)));
op[1]=((((-1.0)*x107))+x131+x130+(((-1.0)*x91)));
op[2]=((((-1.0)*x142))+((x71*x97))+(((-1.0)*x71*x94))+((x79*x94))+((x89*x94))+x139+(((-1.0)*x74*x92))+(((-1.0)*x79*x97))+((x83*x92))+(((-1.0)*x88*x94))+(((-1.0)*x89*x99)));
op[3]=((((-1.0)*x141))+((x71*x93))+(((-0.3297312)*gconst5*x96))+x140+(((-1.0)*x79*x93))+((x88*x93))+(((-0.1648656)*gconst2*x96))+(((-0.3297312)*gconst6*x96))+(((-0.1648656)*gconst1*x96))+(((-1.0)*x89*x93)));
op[4]=(((x82*x94))+((x81*x94))+(((-1.0)*x77*x94))+(((-0.13189248)*x111))+((x86*x94))+((x85*x94))+x135+x136+((gconst3*x67*x74))+(((-1.0)*x87*x94))+(((-1.0)*x137))+(((-1.0)*x138))+(((-1.0)*x74*x95))+((x76*x97))+(((-1.0)*x76*x94))+(((-1.0)*x84*x94))+(((-1.0)*gconst3*x67*x83))+((x83*x95))+(((-1.0)*x81*x97))+(((-1.0)*x81*x99))+((x77*x97))+(((-1.0)*gconst7*x67*x80))+(((-1.0)*x85*x99)));
op[5]=((((-1.0)*x140))+(((-0.1648656)*gconst5*x96))+(((-1.0)*x90*x93))+((x72*x93))+((x73*x93))+x141+(((-1.0)*x78*x93))+(((-0.1648656)*gconst6*x96))+(((-0.3297312)*gconst1*x96))+(((-0.3297312)*gconst2*x96)));
op[6]=((((-1.0)*x142))+(((-1.0)*x73*x99))+(((-1.0)*x73*x97))+(((-1.0)*x72*x97))+(((-1.0)*x90*x94))+((x78*x97))+((x72*x94))+((x73*x94))+x139+(((-1.0)*x78*x94))+((x80*x95)));
op[7]=((((-1.0)*x107))+x130+(((-1.0)*x131))+x91);
op[8]=(x135+(((-1.0)*x137)));
polyroots8(op,zeror,numroots);
IkReal j27array[8], cj27array[8], sj27array[8], tempj27array[1];
int numsolutions = 0;
for(int ij27 = 0; ij27 < numroots; ++ij27)
{
IkReal htj27 = zeror[ij27];
tempj27array[0]=((2.0)*(atan(htj27)));
for(int kj27 = 0; kj27 < 1; ++kj27)
{
j27array[numsolutions] = tempj27array[kj27];
if( j27array[numsolutions] > IKPI )
{
    j27array[numsolutions]-=IK2PI;
}
else if( j27array[numsolutions] < -IKPI )
{
    j27array[numsolutions]+=IK2PI;
}
sj27array[numsolutions] = IKsin(j27array[numsolutions]);
cj27array[numsolutions] = IKcos(j27array[numsolutions]);
numsolutions++;
}
}
bool j27valid[8]={true,true,true,true,true,true,true,true};
_nj27 = 8;
for(int ij27 = 0; ij27 < numsolutions; ++ij27)
    {
if( !j27valid[ij27] )
{
    continue;
}
    j27 = j27array[ij27]; cj27 = cj27array[ij27]; sj27 = sj27array[ij27];
htj27 = IKtan(j27/2);

_ij27[0] = ij27; _ij27[1] = -1;
for(int iij27 = ij27+1; iij27 < numsolutions; ++iij27)
{
if( j27valid[iij27] && IKabs(cj27array[ij27]-cj27array[iij27]) < IKFAST_SOLUTION_THRESH && IKabs(sj27array[ij27]-sj27array[iij27]) < IKFAST_SOLUTION_THRESH )
{
    j27valid[iij27]=false; _ij27[1] = iij27; break; 
}
}
{
IkReal j28eval[2];
IkReal x143=cj27*cj27;
IkReal x144=py*py;
IkReal x145=px*px;
IkReal x146=pz*pz;
IkReal x147=((100.0)*sj29);
IkReal x148=(py*sj27);
IkReal x149=((4.0)*sj29);
IkReal x150=(cj27*px*sj29);
IkReal x151=(x143*x145);
IkReal x152=(x144*x149);
j28eval[0]=((((20.0)*x150))+((x143*x144*x147))+(((-200.0)*x148*x150))+(((-1.0)*x144*x147))+(((-1.0)*sj29))+(((-1.0)*x147*x151))+(((-1.0)*x146*x147))+(((20.0)*sj29*x148)));
j28eval[1]=IKsign(((((-1.0)*x152))+(((0.8)*sj29*x148))+(((-0.04)*sj29))+(((-1.0)*x146*x149))+(((0.8)*x150))+(((-1.0)*x149*x151))+(((-8.0)*x148*x150))+((x143*x152))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[3];
bool bgotonextstatement = true;
do
{
IkReal x153=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x153;
evalcond[2]=x153;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x154=((321000.0)*cj30);
IkReal x155=(py*sj27);
IkReal x156=((321000.0)*sj30);
IkReal x157=(cj27*px);
j28eval[0]=((1.02430295950156)+cj30);
j28eval[1]=((IKabs(((((-1.0)*pz*x154))+(((32100.0)*sj30))+(((-400000.0)*pz))+(((-1.0)*x156*x157))+(((-1.0)*x155*x156)))))+(IKabs(((-40000.0)+(((-1.0)*pz*x156))+(((400000.0)*x155))+(((400000.0)*x157))+(((-32100.0)*cj30))+((x154*x157))+((x154*x155))))));
j28eval[2]=IKsign(((263041.0)+(((256800.0)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x158=(pz*sj30);
IkReal x159=(cj27*px);
IkReal x160=(py*sj27);
IkReal x161=((10.0)*cj30);
IkReal x162=((321.0)*cj30);
IkReal x163=((1000.0)*pz);
j28eval[0]=((1.24610591900312)+(((-1.0)*x159*x161))+(((-1.0)*x160*x161))+cj30+(((-10.0)*x158))+(((-12.4610591900312)*x160))+(((-12.4610591900312)*x159)));
j28eval[1]=((IKabs(((((-100.0)*pz))+(((128.4)*sj30))+((x159*x163))+((x160*x163))+(((103.041)*cj30*sj30)))))+(IKabs(((-160.0)+((pz*x163))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))))));
j28eval[2]=IKsign(((40.0)+(((-400.0)*x160))+(((-1.0)*x159*x162))+(((-1.0)*x160*x162))+(((-400.0)*x159))+(((32.1)*cj30))+(((-321.0)*x158))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=1.0;
j29=0;
IkReal x164=cj27*cj27;
IkReal x165=py*py;
IkReal x166=pz*pz;
IkReal x167=px*px;
IkReal x168=(cj27*px);
IkReal x169=((321.0)*sj30);
IkReal x170=(py*sj27);
IkReal x171=((321.0)*cj30);
IkReal x172=((321.0)*x170);
IkReal x173=((200.0)*x170);
IkReal x174=(x164*x165);
IkReal x175=(x164*x167);
j28eval[0]=((-1.0)+(((-100.0)*x166))+(((-100.0)*x165))+(((-100.0)*x175))+(((20.0)*x170))+(((20.0)*x168))+(((-1.0)*x168*x173))+(((100.0)*x174)));
j28eval[1]=((IKabs((((pz*x171))+((x168*x169))+((x169*x170))+(((400.0)*pz))+(((-32.1)*sj30)))))+(IKabs(((40.0)+((pz*x169))+(((-400.0)*x168))+(((-400.0)*x170))+(((-1.0)*x170*x171))+(((-1.0)*x168*x171))+(((32.1)*cj30))))));
j28eval[2]=IKsign(((-10.0)+x173+(((-2000.0)*x168*x170))+(((-1000.0)*x166))+(((-1000.0)*x165))+(((-1000.0)*x175))+(((200.0)*x168))+(((1000.0)*x174))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x176=py*py;
IkReal x177=cj27*cj27;
IkReal x178=(cj27*px);
IkReal x179=(py*sj27);
IkReal x180=((321.0)*cj30);
IkReal x181=((321.0)*sj30);
IkReal x182=((1000.0)*x177);
CheckValue<IkReal> x183=IKPowWithIntegerCheck(IKsign(((-10.0)+((x176*x182))+(((-1.0)*x182*(px*px)))+(((-1000.0)*(pz*pz)))+(((-2000.0)*x178*x179))+(((-1000.0)*x176))+(((200.0)*x179))+(((200.0)*x178)))),-1);
if(!x183.valid){
continue;
}
CheckValue<IkReal> x184 = IKatan2WithCheck(IkReal((((pz*x180))+((x178*x181))+((x179*x181))+(((400.0)*pz))+(((-32.1)*sj30)))),((40.0)+((pz*x181))+(((-1.0)*x178*x180))+(((-400.0)*x178))+(((-400.0)*x179))+(((-1.0)*x179*x180))+(((32.1)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x184.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x183.value)))+(x184.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x185=IKsin(j28);
IkReal x186=IKcos(j28);
IkReal x187=((0.321)*cj30);
IkReal x188=((0.321)*sj30);
IkReal x189=(cj27*px);
IkReal x190=(py*sj27);
IkReal x191=((1.0)*x190);
IkReal x192=(pz*x185);
IkReal x193=((0.8)*x186);
evalcond[0]=(((x186*x188))+(((0.4)*x185))+((x185*x187))+pz);
evalcond[1]=(((pz*x186))+((x185*x189))+x188+((x185*x190))+(((-0.1)*x185)));
evalcond[2]=((0.1)+((x186*x187))+(((0.4)*x186))+(((-1.0)*x191))+(((-1.0)*x189))+(((-1.0)*x185*x188)));
evalcond[3]=((0.4)+(((0.1)*x186))+(((-1.0)*x186*x191))+x192+x187+(((-1.0)*x186*x189)));
evalcond[4]=((-0.066959)+(((0.2)*x189))+(((0.2)*x190))+((x189*x193))+(((-1.0)*pp))+((x190*x193))+(((-0.08)*x186))+(((-0.8)*x192)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x645=((321.0)*cj30);
IkReal x646=(py*sj27);
IkReal x647=(cj27*px);
IkReal x648=((1000.0)*pz);
CheckValue<IkReal> x649=IKPowWithIntegerCheck(IKsign(((40.0)+(((-321.0)*pz*sj30))+(((-400.0)*x646))+(((-400.0)*x647))+(((-1.0)*x645*x646))+(((-1.0)*x645*x647))+(((32.1)*cj30)))),-1);
if(!x649.valid){
continue;
}
CheckValue<IkReal> x650 = IKatan2WithCheck(IkReal(((((-100.0)*pz))+(((128.4)*sj30))+((x646*x648))+(((103.041)*cj30*sj30))+((x647*x648)))),((-160.0)+((pz*x648))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x650.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x649.value)))+(x650.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x651=IKsin(j28);
IkReal x652=IKcos(j28);
IkReal x653=((0.321)*cj30);
IkReal x654=((0.321)*sj30);
IkReal x655=(cj27*px);
IkReal x656=(py*sj27);
IkReal x657=((1.0)*x656);
IkReal x658=(pz*x651);
IkReal x659=((0.8)*x652);
evalcond[0]=(((x652*x654))+((x651*x653))+(((0.4)*x651))+pz);
evalcond[1]=((((-0.1)*x651))+((pz*x652))+((x651*x656))+((x651*x655))+x654);
evalcond[2]=((0.1)+(((-1.0)*x651*x654))+(((-1.0)*x655))+((x652*x653))+(((-1.0)*x657))+(((0.4)*x652)));
evalcond[3]=((0.4)+x653+x658+(((0.1)*x652))+(((-1.0)*x652*x657))+(((-1.0)*x652*x655)));
evalcond[4]=((-0.066959)+(((-0.8)*x658))+(((-1.0)*pp))+((x656*x659))+((x655*x659))+(((-0.08)*x652))+(((0.2)*x656))+(((0.2)*x655)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x660=((321000.0)*cj30);
IkReal x661=(py*sj27);
IkReal x662=(cj27*px);
IkReal x663=((321000.0)*sj30);
CheckValue<IkReal> x664=IKPowWithIntegerCheck(IKsign(((263041.0)+(((256800.0)*cj30)))),-1);
if(!x664.valid){
continue;
}
CheckValue<IkReal> x665 = IKatan2WithCheck(IkReal(((((-1.0)*x662*x663))+(((32100.0)*sj30))+(((-1.0)*x661*x663))+(((-400000.0)*pz))+(((-1.0)*pz*x660)))),((-40000.0)+(((-32100.0)*cj30))+(((400000.0)*x661))+(((400000.0)*x662))+((x660*x661))+((x660*x662))+(((-1.0)*pz*x663))),IKFAST_ATAN2_MAGTHRESH);
if(!x665.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x664.value)))+(x665.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x666=IKsin(j28);
IkReal x667=IKcos(j28);
IkReal x668=((0.321)*cj30);
IkReal x669=((0.321)*sj30);
IkReal x670=(cj27*px);
IkReal x671=(py*sj27);
IkReal x672=((1.0)*x671);
IkReal x673=(pz*x666);
IkReal x674=((0.8)*x667);
evalcond[0]=(((x666*x668))+((x667*x669))+(((0.4)*x666))+pz);
evalcond[1]=(((x666*x671))+((x666*x670))+((pz*x667))+x669+(((-0.1)*x666)));
evalcond[2]=((0.1)+((x667*x668))+(((0.4)*x667))+(((-1.0)*x670))+(((-1.0)*x666*x669))+(((-1.0)*x672)));
evalcond[3]=((0.4)+(((-1.0)*x667*x670))+(((0.1)*x667))+(((-1.0)*x667*x672))+x668+x673);
evalcond[4]=((-0.066959)+(((-0.08)*x667))+((x671*x674))+(((0.2)*x671))+(((0.2)*x670))+((x670*x674))+(((-1.0)*pp))+(((-0.8)*x673)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x675=(px*sj27);
IkReal x676=(cj27*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=(x675+(((-1.0)*x676)));
evalcond[2]=(x676+(((-1.0)*x675)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[2], cj30array[2], sj30array[2];
bool j30valid[2]={false};
_nj30 = 2;
cj30array[0]=((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)));
if( cj30array[0] >= -1-IKFAST_SINCOS_THRESH && cj30array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j30valid[0] = j30valid[1] = true;
    j30array[0] = IKacos(cj30array[0]);
    sj30array[0] = IKsin(j30array[0]);
    cj30array[1] = cj30array[0];
    j30array[1] = -j30array[0];
    sj30array[1] = -sj30array[0];
}
else if( isnan(cj30array[0]) )
{
    // probably any value will work
    j30valid[0] = true;
    cj30array[0] = 1; sj30array[0] = 0; j30array[0] = 0;
}
for(int ij30 = 0; ij30 < 2; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 2; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];

{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x677=((321000.0)*cj30);
IkReal x678=(py*sj27);
IkReal x679=((321000.0)*sj30);
IkReal x680=(cj27*px);
j28eval[0]=((-1.02430295950156)+(((-1.0)*cj30)));
j28eval[1]=IKsign(((-263041.0)+(((-256800.0)*cj30))));
j28eval[2]=((IKabs((((pz*x677))+(((-1.0)*x678*x679))+(((32100.0)*sj30))+(((400000.0)*pz))+(((-1.0)*x679*x680)))))+(IKabs(((40000.0)+(((-400000.0)*x680))+(((-400000.0)*x678))+(((-1.0)*pz*x679))+(((32100.0)*cj30))+(((-1.0)*x677*x680))+(((-1.0)*x677*x678))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x681=(pz*sj30);
IkReal x682=(cj27*px);
IkReal x683=(py*sj27);
IkReal x684=((10.0)*cj30);
IkReal x685=((1000.0)*pz);
IkReal x686=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+((x682*x684))+((x683*x684))+(((-1.0)*cj30))+(((-10.0)*x681))+(((12.4610591900312)*x683))+(((12.4610591900312)*x682)));
j28eval[1]=((IKabs(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x682*x685))+(((-1.0)*x683*x685))+(((103.041)*cj30*sj30)))))+(IKabs(((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x685))))));
j28eval[2]=IKsign(((-40.0)+((x682*x686))+((x683*x686))+(((400.0)*x682))+(((400.0)*x683))+(((-321.0)*x681))+(((-32.1)*cj30))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
sj29=0;
cj29=-1.0;
j29=3.14159265358979;
IkReal x687=cj27*cj27;
IkReal x688=py*py;
IkReal x689=pz*pz;
IkReal x690=px*px;
IkReal x691=(cj27*px);
IkReal x692=((321.0)*sj30);
IkReal x693=(py*sj27);
IkReal x694=((321.0)*cj30);
IkReal x695=((321.0)*x693);
IkReal x696=((200.0)*x693);
IkReal x697=(x687*x688);
IkReal x698=(x687*x690);
j28eval[0]=((-1.0)+(((20.0)*x691))+(((20.0)*x693))+(((-100.0)*x689))+(((-100.0)*x688))+(((-100.0)*x698))+(((100.0)*x697))+(((-1.0)*x691*x696)));
j28eval[1]=((IKabs(((40.0)+(((-1.0)*x693*x694))+(((-400.0)*x693))+(((-400.0)*x691))+(((-1.0)*pz*x692))+(((-1.0)*x691*x694))+(((32.1)*cj30)))))+(IKabs((((pz*x694))+(((400.0)*pz))+(((-1.0)*x692*x693))+(((32.1)*sj30))+(((-1.0)*x691*x692))))));
j28eval[2]=IKsign(((-10.0)+(((-2000.0)*x691*x693))+(((-1000.0)*x698))+(((-1000.0)*x689))+(((-1000.0)*x688))+(((200.0)*x691))+x696+(((1000.0)*x697))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
continue; // no branches [j28]

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x699=py*py;
IkReal x700=cj27*cj27;
IkReal x701=(cj27*px);
IkReal x702=(py*sj27);
IkReal x703=((321.0)*cj30);
IkReal x704=((321.0)*sj30);
IkReal x705=((1000.0)*x700);
CheckValue<IkReal> x706=IKPowWithIntegerCheck(IKsign(((-10.0)+(((-1000.0)*x699))+(((-2000.0)*x701*x702))+(((-1000.0)*(pz*pz)))+(((-1.0)*x705*(px*px)))+(((200.0)*x701))+(((200.0)*x702))+((x699*x705)))),-1);
if(!x706.valid){
continue;
}
CheckValue<IkReal> x707 = IKatan2WithCheck(IkReal(((((-1.0)*x702*x704))+(((400.0)*pz))+(((32.1)*sj30))+(((-1.0)*x701*x704))+((pz*x703)))),((40.0)+(((-1.0)*pz*x704))+(((-1.0)*x702*x703))+(((-400.0)*x702))+(((-400.0)*x701))+(((32.1)*cj30))+(((-1.0)*x701*x703))),IKFAST_ATAN2_MAGTHRESH);
if(!x707.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x706.value)))+(x707.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x708=IKsin(j28);
IkReal x709=IKcos(j28);
IkReal x710=((0.321)*cj30);
IkReal x711=((0.321)*sj30);
IkReal x712=(py*sj27);
IkReal x713=(cj27*px);
IkReal x714=((1.0)*x712);
IkReal x715=(pz*x708);
IkReal x716=((1.0)*x709);
IkReal x717=((0.8)*x709);
evalcond[0]=((((0.4)*x708))+(((-1.0)*x709*x711))+pz+((x708*x710)));
evalcond[1]=((0.1)+(((0.4)*x709))+(((-1.0)*x713))+((x709*x710))+(((-1.0)*x714))+((x708*x711)));
evalcond[2]=((0.4)+(((-1.0)*x709*x714))+(((0.1)*x709))+x710+x715+(((-1.0)*x713*x716)));
evalcond[3]=((((-1.0)*pz*x716))+(((-1.0)*x708*x713))+(((0.1)*x708))+(((-1.0)*x708*x714))+x711);
evalcond[4]=((-0.066959)+(((-1.0)*pp))+(((-0.8)*x715))+(((0.2)*x712))+(((0.2)*x713))+((x712*x717))+((x713*x717))+(((-0.08)*x709)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x718=((321.0)*cj30);
IkReal x719=(py*sj27);
IkReal x720=(cj27*px);
IkReal x721=((1000.0)*pz);
CheckValue<IkReal> x722 = IKatan2WithCheck(IkReal(((((100.0)*pz))+(((128.4)*sj30))+(((-1.0)*x720*x721))+(((-1.0)*x719*x721))+(((103.041)*cj30*sj30)))),((160.0)+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))+(((-1.0)*pz*x721))),IKFAST_ATAN2_MAGTHRESH);
if(!x722.valid){
continue;
}
CheckValue<IkReal> x723=IKPowWithIntegerCheck(IKsign(((-40.0)+(((400.0)*x720))+(((400.0)*x719))+(((-321.0)*pz*sj30))+((x718*x720))+((x718*x719))+(((-32.1)*cj30)))),-1);
if(!x723.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x722.value)+(((1.5707963267949)*(x723.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x724=IKsin(j28);
IkReal x725=IKcos(j28);
IkReal x726=((0.321)*cj30);
IkReal x727=((0.321)*sj30);
IkReal x728=(py*sj27);
IkReal x729=(cj27*px);
IkReal x730=((1.0)*x728);
IkReal x731=(pz*x724);
IkReal x732=((1.0)*x725);
IkReal x733=((0.8)*x725);
evalcond[0]=((((-1.0)*x725*x727))+pz+((x724*x726))+(((0.4)*x724)));
evalcond[1]=((0.1)+(((-1.0)*x729))+(((-1.0)*x730))+((x725*x726))+((x724*x727))+(((0.4)*x725)));
evalcond[2]=((0.4)+(((-1.0)*x725*x730))+(((0.1)*x725))+x731+x726+(((-1.0)*x729*x732)));
evalcond[3]=((((-1.0)*x724*x730))+(((-1.0)*x724*x729))+(((0.1)*x724))+x727+(((-1.0)*pz*x732)));
evalcond[4]=((-0.066959)+(((-0.08)*x725))+((x728*x733))+((x729*x733))+(((-1.0)*pp))+(((-0.8)*x731))+(((0.2)*x729))+(((0.2)*x728)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x734=(cj27*px);
IkReal x735=((321000.0)*cj30);
IkReal x736=((321000.0)*sj30);
IkReal x737=((321000.0)*py*sj27);
CheckValue<IkReal> x738 = IKatan2WithCheck(IkReal(((((32100.0)*sj30))+(((-1.0)*py*sj27*x736))+(((-1.0)*x734*x736))+(((400000.0)*pz))+((pz*x735)))),((40000.0)+(((-400000.0)*py*sj27))+(((-1.0)*py*sj27*x735))+(((-1.0)*x734*x735))+(((-400000.0)*x734))+(((32100.0)*cj30))+(((-1.0)*pz*x736))),IKFAST_ATAN2_MAGTHRESH);
if(!x738.valid){
continue;
}
CheckValue<IkReal> x739=IKPowWithIntegerCheck(IKsign(((-263041.0)+(((-256800.0)*cj30)))),-1);
if(!x739.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x738.value)+(((1.5707963267949)*(x739.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x740=IKsin(j28);
IkReal x741=IKcos(j28);
IkReal x742=((0.321)*cj30);
IkReal x743=((0.321)*sj30);
IkReal x744=(py*sj27);
IkReal x745=(cj27*px);
IkReal x746=((1.0)*x744);
IkReal x747=(pz*x740);
IkReal x748=((1.0)*x741);
IkReal x749=((0.8)*x741);
evalcond[0]=(((x740*x742))+pz+(((0.4)*x740))+(((-1.0)*x741*x743)));
evalcond[1]=((0.1)+((x740*x743))+((x741*x742))+(((-1.0)*x745))+(((0.4)*x741))+(((-1.0)*x746)));
evalcond[2]=((0.4)+(((-1.0)*x745*x748))+(((0.1)*x741))+(((-1.0)*x741*x746))+x747+x742);
evalcond[3]=((((0.1)*x740))+(((-1.0)*pz*x748))+(((-1.0)*x740*x746))+x743+(((-1.0)*x740*x745)));
evalcond[4]=((-0.066959)+((x745*x749))+((x744*x749))+(((-0.08)*x741))+(((-1.0)*pp))+(((0.2)*x744))+(((0.2)*x745))+(((-0.8)*x747)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28, j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x750=IKPowWithIntegerCheck(sj29,-1);
if(!x750.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x750.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x750.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x750.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[2];
evalcond[0]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*sj29*(IKsin(j30)))));
evalcond[1]=((0.253041)+(((0.2568)*(IKcos(j30))))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j28eval[3];
IkReal x751=(py*sj27);
IkReal x752=(cj29*sj30);
IkReal x753=(cj27*px);
IkReal x754=((10.0)*cj30);
IkReal x755=((1000.0)*pz);
IkReal x756=((321.0)*cj30);
j28eval[0]=((-1.24610591900312)+((x751*x754))+(((10.0)*pz*x752))+(((-1.0)*cj30))+(((12.4610591900312)*x753))+(((12.4610591900312)*x751))+((x753*x754)));
j28eval[1]=IKsign(((-40.0)+((x751*x756))+(((400.0)*x753))+(((400.0)*x751))+(((321.0)*pz*x752))+((x753*x756))+(((-32.1)*cj30))));
j28eval[2]=((IKabs(((160.0)+(((-1.0)*pz*x755))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30)))))+(IKabs(((((100.0)*pz))+(((-1.0)*x753*x755))+(((-1.0)*x751*x755))+(((-128.4)*x752))+(((-103.041)*cj30*x752))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[3];
IkReal x757=cj29*cj29;
IkReal x758=cj30*cj30;
IkReal x759=(cj27*px);
IkReal x760=((321000.0)*cj30);
IkReal x761=(py*sj27);
IkReal x762=((321000.0)*cj29*sj30);
IkReal x763=((103041.0)*x758);
j28eval[0]=((1.5527799613746)+(((-1.0)*x757*x758))+x757+x758+(((2.49221183800623)*cj30)));
j28eval[1]=IKsign(((160000.0)+(((256800.0)*cj30))+(((-1.0)*x757*x763))+(((103041.0)*x757))+x763));
j28eval[2]=((IKabs(((-40000.0)+(((-32100.0)*cj30))+((x760*x761))+((x759*x760))+(((400000.0)*x761))+(((400000.0)*x759))+(((-1.0)*pz*x762)))))+(IKabs(((((32100.0)*cj29*sj30))+(((-400000.0)*pz))+(((-1.0)*x761*x762))+(((-1.0)*x759*x762))+(((-1.0)*pz*x760))))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  || IKabs(j28eval[2]) < 0.0000010000000000  )
{
{
IkReal j28eval[2];
IkReal x764=(cj29*sj30);
IkReal x765=(py*sj27);
IkReal x766=(cj30*pz);
IkReal x767=(cj27*px);
j28eval[0]=((((-10.0)*x764*x765))+(((-10.0)*x764*x767))+x764+(((10.0)*x766))+(((12.4610591900312)*pz)));
j28eval[1]=IKsign(((((400.0)*pz))+(((321.0)*x766))+(((-321.0)*x764*x765))+(((-321.0)*x764*x767))+(((32.1)*x764))));
if( IKabs(j28eval[0]) < 0.0000010000000000  || IKabs(j28eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x768=((((0.321)*sj30))+(((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((1.5707963267949)+j29), 6.28318530717959))))));
evalcond[1]=x768;
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=x768;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x769=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x769);
rxp0_1=(px*r20);
rxp1_0=(r21*x769);
rxp1_1=(px*r21);
rxp2_0=(r22*x769);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x770=((-1.0)*py);
pz=0;
j29=1.5707963267949;
sj29=1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x770);
rxp0_1=(px*r20);
rxp1_0=(r21*x770);
rxp1_1=(px*r21);
rxp2_0=(r22*x770);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x771=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x771) < -0.00001)
continue;
IkReal x772=IKabs(IKsqrt(x771));
IkReal x778 = x771;
if(IKabs(x778)==0){
continue;
}
IkReal x773=pow(x778,-0.5);
CheckValue<IkReal> x779=IKPowWithIntegerCheck(x772,-1);
if(!x779.valid){
continue;
}
IkReal x774=x779.value;
IkReal x775=((10.0)*px*x773);
IkReal x776=((10.0)*py*x773);
if((((1.0)+(((-1.0)*(x774*x774))))) < -0.00001)
continue;
IkReal x777=IKsqrt(((1.0)+(((-1.0)*(x774*x774)))));
if( (x774) < -1-IKFAST_SINCOS_THRESH || (x774) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x780 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x780.valid){
continue;
}
IkReal gconst24=((((-1.0)*(IKasin(x774))))+(((-1.0)*(x780.value))));
IkReal gconst25=(((x774*x776))+((x775*x777)));
IkReal gconst26=(((x774*x775))+(((-1.0)*x776*x777)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x781=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x781.valid){
continue;
}
if( (x781.value) < -1-IKFAST_SINCOS_THRESH || (x781.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x782 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x782.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x781.value))+j27+(x782.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x784=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst25*py))+(((-1.0)*gconst26*px))),-1);
if(!x784.valid){
continue;
}
IkReal x783=x784.value;
cj28array[0]=((((-0.321)*cj30*x783))+(((-0.4)*x783)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x785=IKsin(j28);
IkReal x786=IKcos(j28);
IkReal x787=(gconst25*py);
IkReal x788=(gconst26*px);
IkReal x789=((0.321)*cj30);
IkReal x790=((1.0)*x785);
IkReal x791=((0.8)*x786);
evalcond[0]=(((x785*x789))+(((0.4)*x785)));
evalcond[1]=((((-1.0)*x788*x790))+(((0.1)*x785))+(((-1.0)*x787*x790)));
evalcond[2]=((0.1)+((x786*x789))+(((-1.0)*x787))+(((-1.0)*x788))+(((0.4)*x786)));
evalcond[3]=((-0.32)+((x788*x791))+((x787*x791))+(((-0.08)*x786))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x792=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x799 = x792;
if(IKabs(x799)==0){
continue;
}
IkReal x793=pow(x799,-0.5);
if((x792) < -0.00001)
continue;
IkReal x794=IKabs(IKsqrt(x792));
CheckValue<IkReal> x800=IKPowWithIntegerCheck(x794,-1);
if(!x800.valid){
continue;
}
IkReal x795=x800.value;
IkReal x796=((10.0)*px*x793);
IkReal x797=((10.0)*py*x793);
if((((1.0)+(((-1.0)*(x795*x795))))) < -0.00001)
continue;
IkReal x798=IKsqrt(((1.0)+(((-1.0)*(x795*x795)))));
CheckValue<IkReal> x801 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x801.valid){
continue;
}
if( (x795) < -1-IKFAST_SINCOS_THRESH || (x795) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal gconst27=((3.14159265358979)+(((-1.0)*(x801.value)))+(IKasin(x795)));
IkReal gconst28=((((-1.0)*x796*x798))+((x795*x797)));
IkReal gconst29=(((x797*x798))+((x795*x796)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x802=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x802.valid){
continue;
}
if( (x802.value) < -1-IKFAST_SINCOS_THRESH || (x802.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x803 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x803.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x802.value))))+j27+(x803.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x805=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst29*px))+(((-1.0)*gconst28*py))),-1);
if(!x805.valid){
continue;
}
IkReal x804=x805.value;
cj28array[0]=((((-0.4)*x804))+(((-0.321)*cj30*x804)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x806=IKsin(j28);
IkReal x807=IKcos(j28);
IkReal x808=(gconst28*py);
IkReal x809=((0.321)*cj30);
IkReal x810=((0.8)*x807);
IkReal x811=((1.0)*gconst29*px);
evalcond[0]=(((x806*x809))+(((0.4)*x806)));
evalcond[1]=((((-1.0)*x806*x808))+(((0.1)*x806))+(((-1.0)*x806*x811)));
evalcond[2]=((0.1)+(((-1.0)*x808))+(((-1.0)*x811))+(((0.4)*x807))+((x807*x809)));
evalcond[3]=((-0.32)+((x808*x810))+(((-0.08)*x807))+((gconst29*px*x810))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x813=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x813.valid){
continue;
}
IkReal x812=x813.value;
cj28array[0]=(((py*sj27*x812))+((cj27*px*x812))+(((-0.1)*x812)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x814=IKsin(j28);
IkReal x815=IKcos(j28);
IkReal x816=((0.321)*cj30);
IkReal x817=(cj27*px);
IkReal x818=((1.0)*x814);
IkReal x819=(py*sj27*x815);
evalcond[0]=((((0.4)*x814))+((x814*x816)));
evalcond[1]=((((-1.0)*x817*x818))+(((-1.0)*py*sj27*x818))+(((0.1)*x814)));
evalcond[2]=((0.4)+(((-1.0)*x815*x817))+(((-1.0)*x819))+x816+(((0.1)*x815)));
evalcond[3]=((-0.32)+(((0.8)*x819))+(((-0.2568)*cj30))+(((0.8)*x815*x817))+(((-0.08)*x815)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x821=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x821.valid){
continue;
}
IkReal x820=x821.value;
cj28array[0]=((((-0.4)*x820))+(((-0.321)*cj30*x820)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x822=IKsin(j28);
IkReal x823=IKcos(j28);
IkReal x824=(py*sj27);
IkReal x825=(cj27*px);
IkReal x826=((0.321)*cj30);
IkReal x827=((0.8)*x823);
IkReal x828=((1.0)*x822);
evalcond[0]=((((0.4)*x822))+((x822*x826)));
evalcond[1]=((((0.1)*x822))+(((-1.0)*x824*x828))+(((-1.0)*x825*x828)));
evalcond[2]=((0.1)+(((0.4)*x823))+(((-1.0)*x825))+(((-1.0)*x824))+((x823*x826)));
evalcond[3]=((-0.32)+(((-0.08)*x823))+((x824*x827))+((x825*x827))+(((-0.2568)*cj30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x829=((0.321)*sj30);
IkReal x830=(cj27*py);
IkReal x831=(px*sj27);
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((4.71238898038469)+j29), 6.28318530717959))))));
evalcond[1]=((((-1.0)*x829))+(((-1.0)*x830))+x831);
evalcond[2]=((0.253041)+(((0.2568)*cj30))+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
evalcond[3]=((((-1.0)*x831))+x829+x830);
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28eval[1];
IkReal x832=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x832);
rxp0_1=(px*r20);
rxp1_0=(r21*x832);
rxp1_1=(px*r21);
rxp2_0=(r22*x832);
rxp2_1=(px*r22);
j28eval[0]=((1.0)+(((-10.0)*cj27*px))+(((-10.0)*py*sj27)));
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal j28eval[1];
IkReal x833=((-1.0)*py);
pz=0;
j29=-1.5707963267949;
sj29=-1.0;
cj29=0;
pp=((px*px)+(py*py));
npx=(((px*r00))+((py*r10)));
npy=(((px*r01))+((py*r11)));
npz=(((px*r02))+((py*r12)));
rxp0_0=(r20*x833);
rxp0_1=(px*r20);
rxp1_0=(r21*x833);
rxp1_1=(px*r21);
rxp2_0=(r22*x833);
rxp2_1=(px*r22);
j28eval[0]=((1.24610591900312)+cj30);
if( IKabs(j28eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
IkReal x834=((((100.0)*(px*px)))+(((100.0)*(py*py))));
if((x834) < -0.00001)
continue;
IkReal x835=IKabs(IKsqrt(x834));
IkReal x841 = x834;
if(IKabs(x841)==0){
continue;
}
IkReal x836=pow(x841,-0.5);
CheckValue<IkReal> x842=IKPowWithIntegerCheck(x835,-1);
if(!x842.valid){
continue;
}
IkReal x837=x842.value;
IkReal x838=((10.0)*px*x836);
IkReal x839=((10.0)*py*x836);
if((((1.0)+(((-1.0)*(x837*x837))))) < -0.00001)
continue;
IkReal x840=IKsqrt(((1.0)+(((-1.0)*(x837*x837)))));
if( (x837) < -1-IKFAST_SINCOS_THRESH || (x837) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x843 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x843.valid){
continue;
}
IkReal gconst30=((((-1.0)*(IKasin(x837))))+(((-1.0)*(x843.value))));
IkReal gconst31=(((x838*x840))+((x837*x839)));
IkReal gconst32=(((x837*x838))+(((-1.0)*x839*x840)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x844=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x844.valid){
continue;
}
if( (x844.value) < -1-IKFAST_SINCOS_THRESH || (x844.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x845 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x845.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((IKasin(x844.value))+j27+(x845.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x847=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst32*px))+(((-1.0)*gconst31*py))),-1);
if(!x847.valid){
continue;
}
IkReal x846=x847.value;
cj28array[0]=((((-0.4)*x846))+(((-0.321)*cj30*x846)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x848=IKsin(j28);
IkReal x849=IKcos(j28);
IkReal x850=(gconst31*py);
IkReal x851=(gconst32*px);
IkReal x852=((0.321)*cj30);
IkReal x853=((0.8)*x849);
evalcond[0]=(((x848*x852))+(((0.4)*x848)));
evalcond[1]=(((x848*x851))+((x848*x850))+(((-0.1)*x848)));
evalcond[2]=((0.1)+(((-1.0)*x851))+(((-1.0)*x850))+(((0.4)*x849))+((x849*x852)));
evalcond[3]=((-0.32)+((x850*x853))+(((-0.08)*x849))+(((-0.2568)*cj30))+((x851*x853)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x854=((((100.0)*(px*px)))+(((100.0)*(py*py))));
IkReal x861 = x854;
if(IKabs(x861)==0){
continue;
}
IkReal x855=pow(x861,-0.5);
if((x854) < -0.00001)
continue;
IkReal x856=IKabs(IKsqrt(x854));
CheckValue<IkReal> x862=IKPowWithIntegerCheck(x856,-1);
if(!x862.valid){
continue;
}
IkReal x857=x862.value;
IkReal x858=((10.0)*px*x855);
IkReal x859=((10.0)*py*x855);
if((((1.0)+(((-1.0)*(x857*x857))))) < -0.00001)
continue;
IkReal x860=IKsqrt(((1.0)+(((-1.0)*(x857*x857)))));
if( (x857) < -1-IKFAST_SINCOS_THRESH || (x857) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x863 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x863.valid){
continue;
}
IkReal gconst33=((3.14159265358979)+(IKasin(x857))+(((-1.0)*(x863.value))));
IkReal gconst34=((((-1.0)*x858*x860))+((x857*x859)));
IkReal gconst35=(((x859*x860))+((x857*x858)));
if((((((100.0)*(px*px)))+(((100.0)*(py*py))))) < -0.00001)
continue;
CheckValue<IkReal> x864=IKPowWithIntegerCheck(IKabs(IKsqrt(((((100.0)*(px*px)))+(((100.0)*(py*py)))))),-1);
if(!x864.valid){
continue;
}
if( (x864.value) < -1-IKFAST_SINCOS_THRESH || (x864.value) > 1+IKFAST_SINCOS_THRESH )
    continue;
CheckValue<IkReal> x865 = IKatan2WithCheck(IkReal(((-10.0)*px)),((-10.0)*py),IKFAST_ATAN2_MAGTHRESH);
if(!x865.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(((-1.0)*(IKasin(x864.value))))+j27+(x865.value))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x867=IKPowWithIntegerCheck(((0.1)+(((-1.0)*gconst34*py))+(((-1.0)*gconst35*px))),-1);
if(!x867.valid){
continue;
}
IkReal x866=x867.value;
cj28array[0]=((((-0.4)*x866))+(((-0.321)*cj30*x866)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x868=IKsin(j28);
IkReal x869=IKcos(j28);
IkReal x870=(gconst34*py);
IkReal x871=(gconst35*px);
IkReal x872=((0.321)*cj30);
IkReal x873=((0.8)*x869);
evalcond[0]=(((x868*x872))+(((0.4)*x868)));
evalcond[1]=(((x868*x871))+((x868*x870))+(((-0.1)*x868)));
evalcond[2]=((0.1)+(((-1.0)*x870))+(((-1.0)*x871))+((x869*x872))+(((0.4)*x869)));
evalcond[3]=((-0.32)+((x871*x873))+((x870*x873))+(((-0.2568)*cj30))+(((-0.08)*x869)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x875=IKPowWithIntegerCheck(((0.4)+(((0.321)*cj30))),-1);
if(!x875.valid){
continue;
}
IkReal x874=x875.value;
cj28array[0]=(((cj27*px*x874))+(((-0.1)*x874))+((py*sj27*x874)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x876=IKsin(j28);
IkReal x877=IKcos(j28);
IkReal x878=((0.321)*cj30);
IkReal x879=(py*sj27*x877);
IkReal x880=(cj27*px*x877);
evalcond[0]=(((x876*x878))+(((0.4)*x876)));
evalcond[1]=(((cj27*px*x876))+(((-0.1)*x876))+((py*sj27*x876)));
evalcond[2]=((0.4)+(((0.1)*x877))+(((-1.0)*x879))+(((-1.0)*x880))+x878);
evalcond[3]=((-0.32)+(((0.8)*x880))+(((-0.2568)*cj30))+(((-0.08)*x877))+(((0.8)*x879)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
CheckValue<IkReal> x882=IKPowWithIntegerCheck(((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))),-1);
if(!x882.valid){
continue;
}
IkReal x881=x882.value;
cj28array[0]=((((-0.4)*x881))+(((-0.321)*cj30*x881)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[4];
IkReal x883=IKsin(j28);
IkReal x884=IKcos(j28);
IkReal x885=(py*sj27);
IkReal x886=(cj27*px);
IkReal x887=((0.321)*cj30);
IkReal x888=((0.8)*x884);
evalcond[0]=(((x883*x887))+(((0.4)*x883)));
evalcond[1]=(((x883*x885))+((x883*x886))+(((-0.1)*x883)));
evalcond[2]=((0.1)+(((-1.0)*x885))+(((-1.0)*x886))+(((0.4)*x884))+((x884*x887)));
evalcond[3]=((-0.32)+((x886*x888))+(((-0.2568)*cj30))+((x885*x888))+(((-0.08)*x884)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(((3.14159265358979)+j30), 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[2]=((0.509841)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-0.13869625520111)+(((1.3869625520111)*py*sj27))+(((1.3869625520111)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x889=IKcos(j28);
IkReal x890=px*px;
CheckValue<IkReal> x899=IKPowWithIntegerCheck(py,-1);
if(!x899.valid){
continue;
}
IkReal x891=x899.value;
IkReal x892=IKsin(j28);
IkReal x893=(py*sj27);
IkReal x894=(x890*x891);
IkReal x895=((1.0)*x889);
IkReal x896=(sj29*x892);
IkReal x897=(cj29*x892);
IkReal x898=((0.8)*sj27*x889);
evalcond[0]=((0.721)*x892);
evalcond[1]=((0.721)+(((-1.0)*cj27*px*x895))+(((-1.0)*x893*x895))+(((0.1)*x889)));
evalcond[2]=((-0.5768)+((x894*x898))+(((0.8)*x889*x893))+(((-0.08)*x889)));
evalcond[3]=((((-0.1)*x897))+((sj27*x894*x897))+((x893*x897)));
evalcond[4]=((((-1.0)*sj27*x894*x896))+(((-1.0)*x893*x896))+(((0.1)*x896)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(pz))+(IKabs(((-3.14159265358979)+(IKfmod(j30, 6.28318530717959))))));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[2]=((-0.003759)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j28array[2], cj28array[2], sj28array[2];
bool j28valid[2]={false};
_nj28 = 2;
cj28array[0]=((-1.26582278481013)+(((12.6582278481013)*py*sj27))+(((12.6582278481013)*cj27*px)));
if( cj28array[0] >= -1-IKFAST_SINCOS_THRESH && cj28array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j28valid[0] = j28valid[1] = true;
    j28array[0] = IKacos(cj28array[0]);
    sj28array[0] = IKsin(j28array[0]);
    cj28array[1] = cj28array[0];
    j28array[1] = -j28array[0];
    sj28array[1] = -sj28array[0];
}
else if( isnan(cj28array[0]) )
{
    // probably any value will work
    j28valid[0] = true;
    cj28array[0] = 1; sj28array[0] = 0; j28array[0] = 0;
}
for(int ij28 = 0; ij28 < 2; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 2; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[5];
IkReal x900=IKcos(j28);
IkReal x901=px*px;
CheckValue<IkReal> x910=IKPowWithIntegerCheck(py,-1);
if(!x910.valid){
continue;
}
IkReal x902=x910.value;
IkReal x903=IKsin(j28);
IkReal x904=(py*sj27);
IkReal x905=(x901*x902);
IkReal x906=((1.0)*x900);
IkReal x907=(sj29*x903);
IkReal x908=(cj29*x903);
IkReal x909=((0.8)*sj27*x900);
evalcond[0]=((0.079)*x903);
evalcond[1]=((0.079)+(((-1.0)*cj27*px*x906))+(((-1.0)*x904*x906))+(((0.1)*x900)));
evalcond[2]=((-0.0632)+((x905*x909))+(((0.8)*x900*x904))+(((-0.08)*x900)));
evalcond[3]=(((sj27*x905*x908))+(((-0.1)*x908))+((x904*x908)));
evalcond[4]=((((-1.0)*x904*x907))+(((-1.0)*sj27*x905*x907))+(((0.1)*x907)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j28]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x911=cj27*cj27;
IkReal x912=py*py;
IkReal x913=(cj27*px);
IkReal x914=(cj29*sj30);
IkReal x915=(py*sj27);
IkReal x916=((1000.0)*pz);
IkReal x917=((1000.0)*x911);
CheckValue<IkReal> x918=IKPowWithIntegerCheck(IKsign(((((321.0)*cj30*pz))+(((-321.0)*x913*x914))+(((400.0)*pz))+(((-321.0)*x914*x915))+(((32.1)*x914)))),-1);
if(!x918.valid){
continue;
}
CheckValue<IkReal> x919 = IKatan2WithCheck(IkReal(((-150.0)+((x917*(px*px)))+(((-200.0)*x913))+(((-200.0)*x915))+(((2000.0)*x913*x915))+(((-1.0)*x912*x917))+(((1000.0)*x912))+(((-103.041)*(cj30*cj30)))+(((-256.8)*cj30)))),((((-100.0)*pz))+(((-103.041)*cj30*x914))+(((-128.4)*x914))+((x915*x916))+((x913*x916))),IKFAST_ATAN2_MAGTHRESH);
if(!x919.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x918.value)))+(x919.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x920=IKsin(j28);
IkReal x921=IKcos(j28);
IkReal x922=((0.321)*cj30);
IkReal x923=(py*sj27);
IkReal x924=((0.321)*sj30);
IkReal x925=((1.0)*sj29);
IkReal x926=(px*sj27);
IkReal x927=(cj27*px);
IkReal x928=(cj27*py);
IkReal x929=((1.0)*x923);
IkReal x930=(pz*x920);
IkReal x931=(cj29*x920);
IkReal x932=(pz*x921);
IkReal x933=((0.8)*x921);
IkReal x934=(sj29*x920);
evalcond[0]=(((x920*x922))+((cj29*x921*x924))+pz+(((0.4)*x920)));
evalcond[1]=((0.1)+(((-1.0)*x929))+(((-1.0)*x924*x931))+((x921*x922))+(((-1.0)*x927))+(((0.4)*x921)));
evalcond[2]=((0.4)+(((0.1)*x921))+(((-1.0)*x921*x929))+(((-1.0)*x921*x927))+x930+x922);
evalcond[3]=((-0.066959)+(((-0.08)*x921))+((x927*x933))+(((0.2)*x927))+(((0.2)*x923))+(((-0.8)*x930))+(((-1.0)*pp))+((x923*x933)));
evalcond[4]=((((-1.0)*x920*x923*x925))+(((0.1)*x934))+(((-1.0)*x925*x932))+(((-1.0)*x920*x925*x927))+((cj29*x926))+(((-1.0)*cj29*x928)));
evalcond[5]=((((-0.1)*x931))+(((-1.0)*x925*x928))+((x927*x931))+((cj29*x932))+((x923*x931))+((sj29*x926))+x924);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x935=cj29*cj29;
IkReal x936=cj30*cj30;
IkReal x937=(cj27*px);
IkReal x938=((321000.0)*cj30);
IkReal x939=(py*sj27);
IkReal x940=((321000.0)*cj29*sj30);
IkReal x941=((103041.0)*x935);
CheckValue<IkReal> x942=IKPowWithIntegerCheck(IKsign(((160000.0)+(((256800.0)*cj30))+(((103041.0)*x936))+(((-1.0)*x936*x941))+x941)),-1);
if(!x942.valid){
continue;
}
CheckValue<IkReal> x943 = IKatan2WithCheck(IkReal(((((32100.0)*cj29*sj30))+(((-1.0)*x939*x940))+(((-400000.0)*pz))+(((-1.0)*pz*x938))+(((-1.0)*x937*x940)))),((-40000.0)+(((-1.0)*pz*x940))+((x937*x938))+(((-32100.0)*cj30))+((x938*x939))+(((400000.0)*x937))+(((400000.0)*x939))),IKFAST_ATAN2_MAGTHRESH);
if(!x943.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x942.value)))+(x943.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x944=IKsin(j28);
IkReal x945=IKcos(j28);
IkReal x946=((0.321)*cj30);
IkReal x947=(py*sj27);
IkReal x948=((0.321)*sj30);
IkReal x949=((1.0)*sj29);
IkReal x950=(px*sj27);
IkReal x951=(cj27*px);
IkReal x952=(cj27*py);
IkReal x953=((1.0)*x947);
IkReal x954=(pz*x944);
IkReal x955=(cj29*x944);
IkReal x956=(pz*x945);
IkReal x957=((0.8)*x945);
IkReal x958=(sj29*x944);
evalcond[0]=(pz+((x944*x946))+((cj29*x945*x948))+(((0.4)*x944)));
evalcond[1]=((0.1)+((x945*x946))+(((-1.0)*x951))+(((0.4)*x945))+(((-1.0)*x953))+(((-1.0)*x948*x955)));
evalcond[2]=((0.4)+(((-1.0)*x945*x951))+(((-1.0)*x945*x953))+x954+x946+(((0.1)*x945)));
evalcond[3]=((-0.066959)+(((-0.08)*x945))+((x951*x957))+(((-0.8)*x954))+(((0.2)*x947))+(((-1.0)*pp))+((x947*x957))+(((0.2)*x951)));
evalcond[4]=((((0.1)*x958))+(((-1.0)*cj29*x952))+((cj29*x950))+(((-1.0)*x944*x947*x949))+(((-1.0)*x949*x956))+(((-1.0)*x944*x949*x951)));
evalcond[5]=(((x951*x955))+((sj29*x950))+(((-0.1)*x955))+((cj29*x956))+((x947*x955))+(((-1.0)*x949*x952))+x948);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x959=(py*sj27);
IkReal x960=(cj29*sj30);
IkReal x961=((321.0)*cj30);
IkReal x962=(cj27*px);
IkReal x963=((1000.0)*pz);
CheckValue<IkReal> x964=IKPowWithIntegerCheck(IKsign(((-40.0)+(((321.0)*pz*x960))+((x961*x962))+(((400.0)*x959))+(((400.0)*x962))+((x959*x961))+(((-32.1)*cj30)))),-1);
if(!x964.valid){
continue;
}
CheckValue<IkReal> x965 = IKatan2WithCheck(IkReal(((((-1.0)*x962*x963))+(((-103.041)*cj30*x960))+(((100.0)*pz))+(((-1.0)*x959*x963))+(((-128.4)*x960)))),((160.0)+(((-1.0)*pz*x963))+(((103.041)*(cj30*cj30)))+(((256.8)*cj30))),IKFAST_ATAN2_MAGTHRESH);
if(!x965.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(((1.5707963267949)*(x964.value)))+(x965.value));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[6];
IkReal x966=IKsin(j28);
IkReal x967=IKcos(j28);
IkReal x968=((0.321)*cj30);
IkReal x969=(py*sj27);
IkReal x970=((0.321)*sj30);
IkReal x971=((1.0)*sj29);
IkReal x972=(px*sj27);
IkReal x973=(cj27*px);
IkReal x974=(cj27*py);
IkReal x975=((1.0)*x969);
IkReal x976=(pz*x966);
IkReal x977=(cj29*x966);
IkReal x978=(pz*x967);
IkReal x979=((0.8)*x967);
IkReal x980=(sj29*x966);
evalcond[0]=(((cj29*x967*x970))+pz+((x966*x968))+(((0.4)*x966)));
evalcond[1]=((0.1)+(((-1.0)*x973))+((x967*x968))+(((-1.0)*x970*x977))+(((0.4)*x967))+(((-1.0)*x975)));
evalcond[2]=((0.4)+(((-1.0)*x967*x973))+(((0.1)*x967))+(((-1.0)*x967*x975))+x976+x968);
evalcond[3]=((-0.066959)+((x969*x979))+(((-0.8)*x976))+((x973*x979))+(((-1.0)*pp))+(((0.2)*x973))+(((0.2)*x969))+(((-0.08)*x967)));
evalcond[4]=((((-1.0)*cj29*x974))+(((0.1)*x980))+(((-1.0)*x971*x978))+((cj29*x972))+(((-1.0)*x966*x969*x971))+(((-1.0)*x966*x971*x973)));
evalcond[5]=(((x969*x977))+(((-0.1)*x977))+((sj29*x972))+(((-1.0)*x971*x974))+((x973*x977))+((cj29*x978))+x970);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j28array[1], cj28array[1], sj28array[1];
bool j28valid[1]={false};
_nj28 = 1;
IkReal x981=cj27*cj27;
IkReal x982=px*px;
IkReal x983=py*py;
IkReal x984=((1.0)*pz);
IkReal x985=(cj27*px);
IkReal x986=((5.0)*pp);
IkReal x987=(cj29*py);
IkReal x988=((4.0)*cj27);
IkReal x989=(pz*sj29);
IkReal x990=(cj29*sj27);
IkReal x991=(py*sj27*sj29);
IkReal x992=((4.0)*cj29*px);
IkReal x993=(sj29*x981);
IkReal x994=((4.0)*x983);
CheckValue<IkReal> x995 = IKatan2WithCheck(IkReal(((((0.4)*px*x990))+(((-0.4)*cj27*x987))+((x986*x989))+(((-4.0)*px*x987))+(((-1.0)*sj29*x984*x985))+(((-1.0)*x984*x991))+(((8.0)*px*x981*x987))+(((-1.0)*x982*x988*x990))+((x983*x988*x990))+(((0.334795)*x989)))),((((-4.0)*px*pz*x990))+(((-0.434795)*sj29*x985))+(((0.5)*pp*sj29))+(((-1.0)*sj29*x985*x986))+(((-1.0)*x983*x993))+((sj29*x983))+(((2.0)*x985*x991))+(((0.0334795)*sj29))+((pz*x987*x988))+(((-1.0)*x986*x991))+(((-0.434795)*x991))+((x982*x993))),IKFAST_ATAN2_MAGTHRESH);
if(!x995.valid){
continue;
}
CheckValue<IkReal> x996=IKPowWithIntegerCheck(IKsign((((x993*x994))+(((-4.0)*pz*x989))+(((0.8)*sj29*x985))+(((-1.0)*sj29*x994))+(((-8.0)*x985*x991))+(((-0.04)*sj29))+(((0.8)*x991))+(((-4.0)*x982*x993)))),-1);
if(!x996.valid){
continue;
}
j28array[0]=((-1.5707963267949)+(x995.value)+(((1.5707963267949)*(x996.value))));
sj28array[0]=IKsin(j28array[0]);
cj28array[0]=IKcos(j28array[0]);
if( j28array[0] > IKPI )
{
    j28array[0]-=IK2PI;
}
else if( j28array[0] < -IKPI )
{    j28array[0]+=IK2PI;
}
j28valid[0] = true;
for(int ij28 = 0; ij28 < 1; ++ij28)
{
if( !j28valid[ij28] )
{
    continue;
}
_ij28[0] = ij28; _ij28[1] = -1;
for(int iij28 = ij28+1; iij28 < 1; ++iij28)
{
if( j28valid[iij28] && IKabs(cj28array[ij28]-cj28array[iij28]) < IKFAST_SOLUTION_THRESH && IKabs(sj28array[ij28]-sj28array[iij28]) < IKFAST_SOLUTION_THRESH )
{
    j28valid[iij28]=false; _ij28[1] = iij28; break; 
}
}
j28 = j28array[ij28]; cj28 = cj28array[ij28]; sj28 = sj28array[ij28];
{
IkReal evalcond[2];
IkReal x997=IKcos(j28);
IkReal x998=IKsin(j28);
IkReal x999=(py*sj27);
IkReal x1000=((1.0)*cj27);
IkReal x1001=(cj27*px);
IkReal x1002=((0.8)*x997);
IkReal x1003=(sj29*x998);
evalcond[0]=((-0.066959)+(((0.2)*x1001))+(((-1.0)*pp))+(((-0.08)*x997))+((x1002*x999))+(((-0.8)*pz*x998))+((x1001*x1002))+(((0.2)*x999)));
evalcond[1]=((((-1.0)*pz*sj29*x997))+(((0.1)*x1003))+((cj29*px*sj27))+(((-1.0)*cj29*py*x1000))+(((-1.0)*px*x1000*x1003))+(((-1.0)*x1003*x999)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j30eval[1];
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=cj28;
j30eval[1]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal j30eval[2];
j30eval[0]=sj29;
j30eval[1]=sj28;
if( IKabs(j30eval[0]) < 0.0000010000000000  || IKabs(j30eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
IkReal x1004=(cj27*px);
IkReal x1005=((0.8)*cj28);
IkReal x1006=(py*sj27);
IkReal x1007=((((-1.0)*cj27*py))+((px*sj27)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=x1007;
evalcond[2]=((-0.066959)+(((0.2)*x1006))+(((0.2)*x1004))+(((-0.08)*cj28))+(((-1.0)*pp))+((x1004*x1005))+((x1005*x1006))+(((-0.8)*pz*sj28)));
evalcond[3]=x1007;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1008=((3.11526479750779)*cj28);
IkReal x1009=(py*sj27);
IkReal x1010=((3.11526479750779)*sj28);
IkReal x1011=(cj27*px);
if( IKabs(((((-1.0)*x1010*x1011))+(((-1.0)*pz*x1008))+(((-1.0)*x1009*x1010))+(((0.311526479750779)*sj28)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+((x1008*x1009))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1010))+((x1008*x1011)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x1010*x1011))+(((-1.0)*pz*x1008))+(((-1.0)*x1009*x1010))+(((0.311526479750779)*sj28))))+IKsqr(((-1.24610591900312)+((x1008*x1009))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1010))+((x1008*x1011))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-1.0)*x1010*x1011))+(((-1.0)*pz*x1008))+(((-1.0)*x1009*x1010))+(((0.311526479750779)*sj28))), ((-1.24610591900312)+((x1008*x1009))+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1010))+((x1008*x1011))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1012=IKcos(j30);
IkReal x1013=IKsin(j30);
IkReal x1014=(py*sj27);
IkReal x1015=(cj27*px);
IkReal x1016=((0.321)*x1012);
IkReal x1017=((0.321)*x1013);
evalcond[0]=((((0.4)*sj28))+((cj28*x1017))+pz+((sj28*x1016)));
evalcond[1]=((0.253041)+(((0.2568)*x1012))+(((-1.0)*pp))+(((0.2)*x1015))+(((0.2)*x1014)));
evalcond[2]=(x1017+((cj28*pz))+((sj28*x1015))+((sj28*x1014))+(((-0.1)*sj28)));
CheckValue<IkReal> x1018=IKPowWithIntegerCheck(py,-1);
if(!x1018.valid){
continue;
}
evalcond[3]=((0.31630125)+x1016+(((-1.25)*pp))+(((0.25)*x1014))+(((0.25)*sj27*(px*px)*(x1018.value))));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1016))+(((-1.0)*sj28*x1017))+(((-1.0)*x1014))+(((-1.0)*x1015)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1019=(cj27*px);
IkReal x1020=((0.8)*cj28);
IkReal x1021=(cj27*py);
IkReal x1022=(px*sj27);
IkReal x1023=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=(x1022+(((-1.0)*x1021)));
evalcond[2]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1019*x1020))+((x1020*x1023))+(((0.2)*x1023))+(((0.2)*x1019))+(((-0.8)*pz*sj28)));
evalcond[3]=(x1021+(((-1.0)*x1022)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1024=((3.11526479750779)*cj28);
IkReal x1025=(py*sj27);
IkReal x1026=((3.11526479750779)*sj28);
IkReal x1027=(cj27*px);
if( IKabs((((x1026*x1027))+(((-0.311526479750779)*sj28))+((x1025*x1026))+((pz*x1024)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1026))+((x1024*x1027))+((x1024*x1025)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((x1026*x1027))+(((-0.311526479750779)*sj28))+((x1025*x1026))+((pz*x1024))))+IKsqr(((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1026))+((x1024*x1027))+((x1024*x1025))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((((x1026*x1027))+(((-0.311526479750779)*sj28))+((x1025*x1026))+((pz*x1024))), ((-1.24610591900312)+(((-0.311526479750779)*cj28))+(((-1.0)*pz*x1026))+((x1024*x1027))+((x1024*x1025))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1028=IKcos(j30);
IkReal x1029=IKsin(j30);
IkReal x1030=(cj27*px);
IkReal x1031=((1.0)*sj28);
IkReal x1032=((0.25)*sj27);
IkReal x1033=(py*sj27);
IkReal x1034=((0.321)*x1028);
IkReal x1035=((0.321)*x1029);
evalcond[0]=((((0.4)*sj28))+(((-1.0)*cj28*x1035))+pz+((sj28*x1034)));
evalcond[1]=((0.253041)+(((0.2568)*x1028))+(((-1.0)*pp))+(((0.2)*x1030))+(((0.2)*x1033)));
CheckValue<IkReal> x1036=IKPowWithIntegerCheck(py,-1);
if(!x1036.valid){
continue;
}
evalcond[2]=((0.31630125)+((x1032*(px*px)*(x1036.value)))+x1034+(((-1.25)*pp))+((py*x1032)));
evalcond[3]=(x1035+(((0.1)*sj28))+(((-1.0)*x1031*x1033))+(((-1.0)*x1030*x1031))+(((-1.0)*cj28*pz)));
evalcond[4]=((0.1)+((cj28*x1034))+(((-1.0)*x1030))+(((-1.0)*x1033))+(((0.4)*cj28))+((sj28*x1035)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j28))), 6.28318530717959)));
evalcond[1]=((-0.146959)+((cj27*px))+(((-1.0)*pp))+((py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+(((-1.0)*pz*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=1.0;
j28=0;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1037=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1037)));
evalcond[2]=((0.353041)+(((0.321)*x1037))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1038=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1038)));
evalcond[2]=((0.353041)+(((0.321)*x1038))+(((-1.0)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1039=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1039)));
evalcond[1]=((0.353041)+(((0.321)*x1039))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1040=IKcos(j30);
evalcond[0]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1040)));
evalcond[1]=((0.353041)+(((0.321)*x1040))+(((-1.0)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1041=IKPowWithIntegerCheck(sj29,-1);
if(!x1041.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1041.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1041.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1041.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1042=IKcos(j30);
IkReal x1043=IKsin(j30);
IkReal x1044=(px*sj27);
IkReal x1045=((1.0)*cj27*py);
IkReal x1046=((0.321)*x1043);
evalcond[0]=(pz+((cj29*x1046)));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1042)));
evalcond[2]=((0.353041)+(((0.321)*x1042))+(((-1.0)*pp)));
evalcond[3]=(((sj29*x1046))+x1044+(((-1.0)*x1045)));
evalcond[4]=((((-1.0)*sj29*x1045))+((sj29*x1044))+x1046+((cj29*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1047=IKPowWithIntegerCheck(cj29,-1);
if(!x1047.valid){
continue;
}
if( IKabs(((-3.11526479750779)*pz*(x1047.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.09981619937695)+(((3.11526479750779)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz*(x1047.value)))+IKsqr(((-1.09981619937695)+(((3.11526479750779)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz*(x1047.value)), ((-1.09981619937695)+(((3.11526479750779)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1048=IKcos(j30);
IkReal x1049=IKsin(j30);
IkReal x1050=(px*sj27);
IkReal x1051=((1.0)*cj27*py);
IkReal x1052=((0.321)*x1049);
evalcond[0]=(pz+((cj29*x1052)));
evalcond[1]=((0.2824328)+(((-0.8)*pp))+(((0.2568)*x1048)));
evalcond[2]=((0.353041)+(((0.321)*x1048))+(((-1.0)*pp)));
evalcond[3]=((((-1.0)*x1051))+x1050+((sj29*x1052)));
evalcond[4]=(x1052+((cj29*pz))+(((-1.0)*sj29*x1051))+((sj29*x1050)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j28)))), 6.28318530717959)));
evalcond[1]=((0.013041)+(((-0.6)*cj27*px))+(((-1.0)*pp))+(((-0.6)*py*sj27)));
evalcond[2]=(((cj29*px*sj27))+(((-1.0)*cj27*cj29*py))+((pz*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=0;
cj28=-1.0;
j28=3.14159265358979;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1053=IKcos(j30);
evalcond[0]=((((-0.321)*(IKsin(j30))))+pz);
evalcond[1]=((0.257388)+(((0.2568)*x1053))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1053))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-3.11526479750779)*pz)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-3.11526479750779)*pz))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-3.11526479750779)*pz), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1054=IKcos(j30);
evalcond[0]=(pz+(((0.321)*(IKsin(j30)))));
evalcond[1]=((0.257388)+(((0.2568)*x1054))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1054))+(((-1.66666666666667)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1055=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1055))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1055))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1056=IKcos(j30);
evalcond[0]=((0.257388)+(((0.2568)*x1056))+(((-1.33333333333333)*pp)));
evalcond[1]=((0.321735)+(((0.321)*x1056))+(((-1.66666666666667)*pp)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1057=IKPowWithIntegerCheck(sj29,-1);
if(!x1057.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1057.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1057.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1057.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1058=IKcos(j30);
IkReal x1059=IKsin(j30);
IkReal x1060=(px*sj27);
IkReal x1061=((1.0)*cj27*py);
IkReal x1062=((0.321)*x1059);
evalcond[0]=(pz+(((-1.0)*cj29*x1062)));
evalcond[1]=((0.257388)+(((0.2568)*x1058))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1058))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1060+(((-1.0)*x1061))+((sj29*x1062)));
evalcond[4]=(x1062+(((-1.0)*sj29*x1061))+(((-1.0)*cj29*pz))+((sj29*x1060)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1063=IKPowWithIntegerCheck(cj29,-1);
if(!x1063.valid){
continue;
}
if( IKabs(((3.11526479750779)*pz*(x1063.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.00228971962617)+(((5.19210799584631)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((3.11526479750779)*pz*(x1063.value)))+IKsqr(((-1.00228971962617)+(((5.19210799584631)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((3.11526479750779)*pz*(x1063.value)), ((-1.00228971962617)+(((5.19210799584631)*pp))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1064=IKcos(j30);
IkReal x1065=IKsin(j30);
IkReal x1066=(px*sj27);
IkReal x1067=((1.0)*cj27*py);
IkReal x1068=((0.321)*x1065);
evalcond[0]=(pz+(((-1.0)*cj29*x1068)));
evalcond[1]=((0.257388)+(((0.2568)*x1064))+(((-1.33333333333333)*pp)));
evalcond[2]=((0.321735)+(((0.321)*x1064))+(((-1.66666666666667)*pp)));
evalcond[3]=(x1066+(((-1.0)*x1067))+((sj29*x1068)));
evalcond[4]=(x1068+(((-1.0)*sj29*x1067))+(((-1.0)*cj29*pz))+((sj29*x1066)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1069=(cj27*px);
IkReal x1070=((1.0)*py);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.8)*pz))+(((0.2)*x1069))+(((-1.0)*pp))+(((0.2)*py*sj27)));
evalcond[2]=((((-1.0)*cj27*cj29*x1070))+(((-1.0)*sj27*sj29*x1070))+((cj29*px*sj27))+(((-1.0)*sj29*x1069))+(((0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=1.0;
cj28=0;
j28=1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1071=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1071))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1071)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1072=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1072))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1072)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1073=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1073))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1073)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1074=IKcos(j30);
evalcond[0]=((0.4)+(((0.321)*x1074))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1074)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1075=IKPowWithIntegerCheck(cj29,-1);
if(!x1075.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1075.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1075.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1075.value)*(((100.0)+(((-1000.0)*cj27*px))+(((-1000.0)*py*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1076=IKcos(j30);
IkReal x1077=IKsin(j30);
IkReal x1078=((1.0)*py);
IkReal x1079=(cj27*px);
IkReal x1080=(px*sj27);
IkReal x1081=((0.321)*x1077);
evalcond[0]=((0.4)+(((0.321)*x1076))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1076)));
evalcond[2]=(x1080+((sj29*x1081))+(((-1.0)*cj27*x1078)));
evalcond[3]=((0.1)+(((-1.0)*sj27*x1078))+(((-1.0)*x1079))+(((-1.0)*cj29*x1081)));
evalcond[4]=(((cj29*py*sj27))+x1081+((sj29*x1080))+(((-1.0)*cj27*sj29*x1078))+((cj29*x1079))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1082=IKPowWithIntegerCheck(sj29,-1);
if(!x1082.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1082.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((-3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1082.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((-3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1082.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((-3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1083=IKcos(j30);
IkReal x1084=IKsin(j30);
IkReal x1085=((1.0)*py);
IkReal x1086=(cj27*px);
IkReal x1087=(px*sj27);
IkReal x1088=((0.321)*x1084);
evalcond[0]=((0.4)+(((0.321)*x1083))+pz);
evalcond[1]=((0.32)+(((0.8)*pz))+(((0.2568)*x1083)));
evalcond[2]=(x1087+((sj29*x1088))+(((-1.0)*cj27*x1085)));
evalcond[3]=((0.1)+(((-1.0)*x1086))+(((-1.0)*sj27*x1085))+(((-1.0)*cj29*x1088)));
evalcond[4]=(((cj29*py*sj27))+x1088+((sj29*x1087))+(((-1.0)*cj27*sj29*x1085))+((cj29*x1086))+(((-0.1)*cj29)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1089=(py*sj27);
IkReal x1090=(cj27*px);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j28)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((0.8)*pz))+(((0.2)*x1089))+(((-1.0)*pp))+(((0.2)*x1090)));
evalcond[2]=(((cj29*px*sj27))+((sj29*x1089))+(((-1.0)*cj27*cj29*py))+((sj29*x1090))+(((-0.1)*sj29)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=sj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal j30eval[1];
sj28=-1.0;
cj28=0;
j28=-1.5707963267949;
j30eval[0]=cj29;
if( IKabs(j30eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1091=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1091))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1091))+(((-0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+((px*sj27))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1092=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1092))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1092))+(((-0.8)*pz)));
evalcond[2]=((((-1.0)*cj27*py))+(((-0.321)*(IKsin(j30))))+((px*sj27)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j29))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((-0.311526479750779)+(((3.11526479750779)*cj27*px))+(((3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1093=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1093))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1093))+(((-0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j29)))), 6.28318530717959)));
evalcond[1]=((((-1.0)*cj27*py))+((px*sj27)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.311526479750779)+(((-3.11526479750779)*cj27*px))+(((-3.11526479750779)*py*sj27))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[3];
IkReal x1094=IKcos(j30);
evalcond[0]=((-0.4)+(((-0.321)*x1094))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1094))+(((-0.8)*pz)));
evalcond[2]=((0.1)+(((-1.0)*py*sj27))+(((-1.0)*cj27*px))+(((-0.321)*(IKsin(j30)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1095=IKPowWithIntegerCheck(cj29,-1);
if(!x1095.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1095.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1095.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1095.value)*(((-100.0)+(((1000.0)*cj27*px))+(((1000.0)*py*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1096=IKcos(j30);
IkReal x1097=IKsin(j30);
IkReal x1098=((1.0)*py);
IkReal x1099=(px*sj27);
IkReal x1100=((1.0)*cj27*px);
IkReal x1101=((0.321)*x1097);
evalcond[0]=((-0.4)+(((-0.321)*x1096))+pz);
evalcond[1]=((0.32)+(((0.2568)*x1096))+(((-0.8)*pz)));
evalcond[2]=(x1099+((sj29*x1101))+(((-1.0)*cj27*x1098)));
evalcond[3]=((0.1)+((cj29*x1101))+(((-1.0)*x1100))+(((-1.0)*sj27*x1098)));
evalcond[4]=(x1101+(((-1.0)*cj29*sj27*x1098))+((sj29*x1099))+(((0.1)*cj29))+(((-1.0)*cj29*x1100))+(((-1.0)*cj27*sj29*x1098)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1102=IKPowWithIntegerCheck(sj29,-1);
if(!x1102.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1102.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.24610591900312)+(((3.11526479750779)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1102.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-1.24610591900312)+(((3.11526479750779)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1102.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-1.24610591900312)+(((3.11526479750779)*pz))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1103=IKcos(j30);
IkReal x1104=IKsin(j30);
IkReal x1105=((1.0)*py);
IkReal x1106=(px*sj27);
IkReal x1107=((1.0)*cj27*px);
IkReal x1108=((0.321)*x1104);
evalcond[0]=((-0.4)+(((-0.321)*x1103))+pz);
evalcond[1]=((0.32)+(((-0.8)*pz))+(((0.2568)*x1103)));
evalcond[2]=(x1106+(((-1.0)*cj27*x1105))+((sj29*x1108)));
evalcond[3]=((0.1)+((cj29*x1108))+(((-1.0)*sj27*x1105))+(((-1.0)*x1107)));
evalcond[4]=(x1108+(((-1.0)*cj27*sj29*x1105))+((sj29*x1106))+(((0.1)*cj29))+(((-1.0)*cj29*x1107))+(((-1.0)*cj29*sj27*x1105)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1109=(cj27*px);
IkReal x1110=((0.8)*cj28);
IkReal x1111=(py*sj27);
IkReal x1112=((1.0)*sj28);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+((x1109*x1110))+((x1110*x1111))+(((-0.08)*cj28))+(((-1.0)*pp))+(((0.2)*x1111))+(((-0.8)*pz*sj28))+(((0.2)*x1109)));
evalcond[2]=((((-1.0)*x1109*x1112))+(((0.1)*sj28))+(((-1.0)*cj28*pz))+(((-1.0)*x1111*x1112)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((3.11526479750779)*cj27*py))+(((-3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1113=IKcos(j30);
IkReal x1114=((1.0)*py);
IkReal x1115=(cj27*px);
IkReal x1116=((0.321)*x1113);
evalcond[0]=((((0.4)*sj28))+((sj28*x1116))+pz);
evalcond[1]=((((-1.0)*cj27*x1114))+((px*sj27))+(((0.321)*(IKsin(j30)))));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*py*sj27))+(((0.2)*x1115))+(((0.2568)*x1113)));
evalcond[3]=((0.1)+((cj28*x1116))+(((-1.0)*sj27*x1114))+(((0.4)*cj28))+(((-1.0)*x1115)));
evalcond[4]=((0.4)+(((-1.0)*cj28*x1115))+(((-1.0)*cj28*sj27*x1114))+x1116+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1117=(cj27*px);
IkReal x1118=((0.8)*cj28);
IkReal x1119=(py*sj27);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j29)))), 6.28318530717959)));
evalcond[1]=((-0.066959)+(((-0.08)*cj28))+(((-1.0)*pp))+((x1117*x1118))+(((0.2)*x1119))+(((0.2)*x1117))+(((-0.8)*pz*sj28))+((x1118*x1119)));
evalcond[2]=(((cj28*pz))+((sj28*x1117))+((sj28*x1119))+(((-0.1)*sj28)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
if( IKabs(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((((-3.11526479750779)*cj27*py))+(((3.11526479750779)*px*sj27))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[5];
IkReal x1120=IKcos(j30);
IkReal x1121=((1.0)*py);
IkReal x1122=(cj27*px);
IkReal x1123=((0.321)*x1120);
evalcond[0]=((((0.4)*sj28))+((sj28*x1123))+pz);
evalcond[1]=((((-0.321)*(IKsin(j30))))+(((-1.0)*cj27*x1121))+((px*sj27)));
evalcond[2]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1122))+(((0.2568)*x1120))+(((0.2)*py*sj27)));
evalcond[3]=((0.1)+(((0.4)*cj28))+(((-1.0)*sj27*x1121))+(((-1.0)*x1122))+((cj28*x1123)));
evalcond[4]=((0.4)+x1123+(((-1.0)*cj28*sj27*x1121))+(((-1.0)*cj28*x1122))+(((0.1)*cj28))+((pz*sj28)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j30]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1129=IKPowWithIntegerCheck(sj29,-1);
if(!x1129.valid){
continue;
}
IkReal x1124=x1129.value;
IkReal x1125=((0.00311526479750779)*x1124);
IkReal x1126=(cj28*cj29);
IkReal x1127=((1000.0)*cj27*py);
IkReal x1128=((1000.0)*px*sj27);
CheckValue<IkReal> x1130=IKPowWithIntegerCheck(sj28,-1);
if(!x1130.valid){
continue;
}
if( IKabs((x1125*((x1127+(((-1.0)*x1128)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1125*(x1130.value)*(((((-1.0)*x1126*x1127))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+((x1126*x1128)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1125*((x1127+(((-1.0)*x1128))))))+IKsqr((x1125*(x1130.value)*(((((-1.0)*x1126*x1127))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+((x1126*x1128))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2((x1125*((x1127+(((-1.0)*x1128))))), (x1125*(x1130.value)*(((((-1.0)*x1126*x1127))+(((-400.0)*sj28*sj29))+(((-1000.0)*pz*sj29))+((x1126*x1128))))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1131=IKsin(j30);
IkReal x1132=IKcos(j30);
IkReal x1133=((1.0)*py);
IkReal x1134=(cj29*sj28);
IkReal x1135=(cj27*px);
IkReal x1136=(cj28*cj29);
IkReal x1137=(py*sj27);
IkReal x1138=(px*sj27);
IkReal x1139=((0.321)*x1131);
IkReal x1140=((0.321)*x1132);
evalcond[0]=(x1138+((sj29*x1139))+(((-1.0)*cj27*x1133)));
evalcond[1]=((0.253041)+(((-1.0)*pp))+(((0.2)*x1137))+(((0.2)*x1135))+(((0.2568)*x1132)));
evalcond[2]=((((0.4)*sj28))+((x1136*x1139))+((sj28*x1140))+pz);
evalcond[3]=((0.4)+x1140+(((-1.0)*cj28*x1135))+(((0.1)*cj28))+((pz*sj28))+(((-1.0)*cj28*sj27*x1133)));
evalcond[4]=((0.1)+(((0.4)*cj28))+((cj28*x1140))+(((-1.0)*x1134*x1139))+(((-1.0)*sj27*x1133))+(((-1.0)*x1135)));
evalcond[5]=(x1139+((sj29*x1138))+(((-0.1)*x1134))+((x1134*x1135))+((x1134*x1137))+((pz*x1136))+(((-1.0)*cj27*sj29*x1133)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
IkReal x1141=((250.0)*sj28);
IkReal x1142=(py*sj27);
IkReal x1143=(cj27*px);
CheckValue<IkReal> x1144=IKPowWithIntegerCheck(cj28,-1);
if(!x1144.valid){
continue;
}
CheckValue<IkReal> x1145=IKPowWithIntegerCheck(cj29,-1);
if(!x1145.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1144.value)*(x1145.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1141*x1142))+((x1141*x1143))+(((-1250.0)*pp*sj28)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1143))+(((-0.778816199376947)*x1142)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1144.value)*(x1145.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1141*x1142))+((x1141*x1143))+(((-1250.0)*pp*sj28))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1143))+(((-0.778816199376947)*x1142))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1144.value)*(x1145.value)*(((((-1000.0)*pz))+(((-83.69875)*sj28))+((x1141*x1142))+((x1141*x1143))+(((-1250.0)*pp*sj28))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*x1143))+(((-0.778816199376947)*x1142))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1146=IKsin(j30);
IkReal x1147=IKcos(j30);
IkReal x1148=((1.0)*py);
IkReal x1149=(cj29*sj28);
IkReal x1150=(cj27*px);
IkReal x1151=(cj28*cj29);
IkReal x1152=(py*sj27);
IkReal x1153=(px*sj27);
IkReal x1154=((0.321)*x1146);
IkReal x1155=((0.321)*x1147);
evalcond[0]=(x1153+((sj29*x1154))+(((-1.0)*cj27*x1148)));
evalcond[1]=((0.253041)+(((0.2)*x1152))+(((0.2)*x1150))+(((-1.0)*pp))+(((0.2568)*x1147)));
evalcond[2]=((((0.4)*sj28))+((sj28*x1155))+pz+((x1151*x1154)));
evalcond[3]=((0.4)+x1155+(((-1.0)*cj28*sj27*x1148))+(((-1.0)*cj28*x1150))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*x1149*x1154))+(((0.4)*cj28))+((cj28*x1155))+(((-1.0)*x1150))+(((-1.0)*sj27*x1148)));
evalcond[5]=(((pz*x1151))+x1154+((x1149*x1150))+((x1149*x1152))+((sj29*x1153))+(((-1.0)*cj27*sj29*x1148))+(((-0.1)*x1149)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j30array[1], cj30array[1], sj30array[1];
bool j30valid[1]={false};
_nj30 = 1;
CheckValue<IkReal> x1156=IKPowWithIntegerCheck(sj29,-1);
if(!x1156.valid){
continue;
}
if( IKabs(((0.00311526479750779)*(x1156.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.00311526479750779)*(x1156.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))))+IKsqr(((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j30array[0]=IKatan2(((0.00311526479750779)*(x1156.value)*(((((1000.0)*cj27*py))+(((-1000.0)*px*sj27))))), ((-0.98536214953271)+(((3.89408099688474)*pp))+(((-0.778816199376947)*py*sj27))+(((-0.778816199376947)*cj27*px))));
sj30array[0]=IKsin(j30array[0]);
cj30array[0]=IKcos(j30array[0]);
if( j30array[0] > IKPI )
{
    j30array[0]-=IK2PI;
}
else if( j30array[0] < -IKPI )
{    j30array[0]+=IK2PI;
}
j30valid[0] = true;
for(int ij30 = 0; ij30 < 1; ++ij30)
{
if( !j30valid[ij30] )
{
    continue;
}
_ij30[0] = ij30; _ij30[1] = -1;
for(int iij30 = ij30+1; iij30 < 1; ++iij30)
{
if( j30valid[iij30] && IKabs(cj30array[ij30]-cj30array[iij30]) < IKFAST_SOLUTION_THRESH && IKabs(sj30array[ij30]-sj30array[iij30]) < IKFAST_SOLUTION_THRESH )
{
    j30valid[iij30]=false; _ij30[1] = iij30; break; 
}
}
j30 = j30array[ij30]; cj30 = cj30array[ij30]; sj30 = sj30array[ij30];
{
IkReal evalcond[6];
IkReal x1157=IKsin(j30);
IkReal x1158=IKcos(j30);
IkReal x1159=((1.0)*py);
IkReal x1160=(cj29*sj28);
IkReal x1161=(cj27*px);
IkReal x1162=(cj28*cj29);
IkReal x1163=(py*sj27);
IkReal x1164=(px*sj27);
IkReal x1165=((0.321)*x1157);
IkReal x1166=((0.321)*x1158);
evalcond[0]=(x1164+(((-1.0)*cj27*x1159))+((sj29*x1165)));
evalcond[1]=((0.253041)+(((0.2568)*x1158))+(((-1.0)*pp))+(((0.2)*x1161))+(((0.2)*x1163)));
evalcond[2]=((((0.4)*sj28))+((x1162*x1165))+pz+((sj28*x1166)));
evalcond[3]=((0.4)+x1166+(((-1.0)*cj28*sj27*x1159))+(((-1.0)*cj28*x1161))+(((0.1)*cj28))+((pz*sj28)));
evalcond[4]=((0.1)+(((-1.0)*sj27*x1159))+(((0.4)*cj28))+(((-1.0)*x1160*x1165))+(((-1.0)*x1161))+((cj28*x1166)));
evalcond[5]=(x1165+(((-1.0)*cj27*sj29*x1159))+((pz*x1162))+(((-0.1)*x1160))+((x1160*x1163))+((x1160*x1161))+((sj29*x1164)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x194=(sj27*sj29);
IkReal x195=(cj27*sj29);
IkReal x196=(cj28*sj29);
IkReal x197=(cj28*cj30);
IkReal x198=((1.0)*sj30);
IkReal x199=((1.0)*cj29);
IkReal x200=(cj29*x198);
IkReal x201=((1.0)*cj30*sj28);
IkReal x202=((((-1.0)*x197*x199))+((sj28*sj30)));
IkReal x203=((((-1.0)*sj27*x199))+((sj28*x195)));
IkReal x204=(((sj28*x194))+((cj27*cj29)));
IkReal x205=(x197+(((-1.0)*sj28*x200)));
IkReal x206=(cj27*x205);
IkReal x207=((((-1.0)*cj30*sj28*x199))+(((-1.0)*cj28*x198)));
IkReal x208=((((-1.0)*x201))+(((-1.0)*cj28*x200)));
IkReal x209=(cj27*x207);
IkReal x210=(((sj30*x195))+((sj27*x205)));
IkReal x211=((((-1.0)*sj30*x194))+x206);
IkReal x212=(((cj30*x195))+((sj27*x207)));
IkReal x213=((((-1.0)*cj30*x194))+x209);
new_r00=(((r20*x202))+((r00*(((((-1.0)*cj30*x194))+x209))))+((r10*x212)));
new_r01=(((r11*x212))+((r21*x202))+((r01*x213)));
new_r02=(((r22*x202))+((r12*x212))+((r02*x213)));
new_r10=(((r20*x196))+((r00*x203))+((r10*x204)));
new_r11=(((r11*x204))+((r01*x203))+((r21*x196)));
new_r12=(((r22*x196))+((r12*x204))+((r02*x203)));
new_r20=(((r20*x208))+((r00*x211))+((r10*x210)));
new_r21=(((r11*x210))+((r21*x208))+((r01*x211)));
new_r22=(((r22*x208))+((r02*(((((-1.0)*x194*x198))+x206))))+((r12*x210)));
{
IkReal j32array[2], cj32array[2], sj32array[2];
bool j32valid[2]={false};
_nj32 = 2;
cj32array[0]=new_r22;
if( cj32array[0] >= -1-IKFAST_SINCOS_THRESH && cj32array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j32valid[0] = j32valid[1] = true;
    j32array[0] = IKacos(cj32array[0]);
    sj32array[0] = IKsin(j32array[0]);
    cj32array[1] = cj32array[0];
    j32array[1] = -j32array[0];
    sj32array[1] = -sj32array[0];
}
else if( isnan(cj32array[0]) )
{
    // probably any value will work
    j32valid[0] = true;
    cj32array[0] = 1; sj32array[0] = 0; j32array[0] = 0;
}
for(int ij32 = 0; ij32 < 2; ++ij32)
{
if( !j32valid[ij32] )
{
    continue;
}
_ij32[0] = ij32; _ij32[1] = -1;
for(int iij32 = ij32+1; iij32 < 2; ++iij32)
{
if( j32valid[iij32] && IKabs(cj32array[ij32]-cj32array[iij32]) < IKFAST_SOLUTION_THRESH && IKabs(sj32array[ij32]-sj32array[iij32]) < IKFAST_SOLUTION_THRESH )
{
    j32valid[iij32]=false; _ij32[1] = iij32; break; 
}
}
j32 = j32array[ij32]; cj32 = cj32array[ij32]; sj32 = sj32array[ij32];

{
IkReal j31eval[2];
IkReal x214=(sj27*sj29);
IkReal x215=(cj27*sj29);
IkReal x216=(cj28*sj29);
IkReal x217=(cj28*cj30);
IkReal x218=((1.0)*sj30);
IkReal x219=((1.0)*cj29);
IkReal x220=(cj29*x218);
IkReal x221=((1.0)*cj30*sj28);
IkReal x222=x202;
IkReal x223=x203;
IkReal x224=x204;
IkReal x225=((((-1.0)*sj28*x220))+x217);
IkReal x226=(cj27*x225);
IkReal x227=x207;
IkReal x228=((((-1.0)*cj28*x220))+(((-1.0)*x221)));
IkReal x229=(cj27*x227);
IkReal x230=(((sj30*x215))+((sj27*x225)));
IkReal x231=(x226+(((-1.0)*sj30*x214)));
IkReal x232=(((cj30*x215))+((sj27*x227)));
IkReal x233=(x229+(((-1.0)*cj30*x214)));
new_r00=(((r20*x222))+((r10*x232))+((r00*((x229+(((-1.0)*cj30*x214)))))));
new_r01=(((r11*x232))+((r01*x233))+((r21*x222)));
new_r02=(((r02*x233))+((r22*x222))+((r12*x232)));
new_r10=(((r00*x223))+((r10*x224))+((r20*x216)));
new_r11=(((r21*x216))+((r01*x223))+((r11*x224)));
new_r12=(((r12*x224))+((r22*x216))+((r02*x223)));
new_r20=(((r20*x228))+((r10*x230))+((r00*x231)));
new_r21=(((r11*x230))+((r01*x231))+((r21*x228)));
new_r22=(((r22*x228))+((r02*((x226+(((-1.0)*x214*x218))))))+((r12*x230)));
j31eval[0]=sj32;
j31eval[1]=IKsign(sj32);
if( IKabs(j31eval[0]) < 0.0000010000000000  || IKabs(j31eval[1]) < 0.0000010000000000  )
{
{
IkReal j31eval[1];
IkReal x234=(sj27*sj29);
IkReal x235=(cj27*sj29);
IkReal x236=(cj28*sj29);
IkReal x237=(cj28*cj30);
IkReal x238=((1.0)*sj30);
IkReal x239=((1.0)*cj29);
IkReal x240=(cj29*x238);
IkReal x241=((1.0)*cj30*sj28);
IkReal x242=x202;
IkReal x243=x203;
IkReal x244=x204;
IkReal x245=(x237+(((-1.0)*sj28*x240)));
IkReal x246=(cj27*x245);
IkReal x247=x207;
IkReal x248=((((-1.0)*x241))+(((-1.0)*cj28*x240)));
IkReal x249=(cj27*x247);
IkReal x250=(((sj27*x245))+((sj30*x235)));
IkReal x251=(x246+(((-1.0)*sj30*x234)));
IkReal x252=(((sj27*x247))+((cj30*x235)));
IkReal x253=(x249+(((-1.0)*cj30*x234)));
new_r00=(((r00*((x249+(((-1.0)*cj30*x234))))))+((r10*x252))+((r20*x242)));
new_r01=(((r11*x252))+((r01*x253))+((r21*x242)));
new_r02=(((r22*x242))+((r12*x252))+((r02*x253)));
new_r10=(((r20*x236))+((r00*x243))+((r10*x244)));
new_r11=(((r01*x243))+((r11*x244))+((r21*x236)));
new_r12=(((r02*x243))+((r12*x244))+((r22*x236)));
new_r20=(((r00*x251))+((r10*x250))+((r20*x248)));
new_r21=(((r11*x250))+((r01*x251))+((r21*x248)));
new_r22=(((r22*x248))+((r12*x250))+((r02*((x246+(((-1.0)*x234*x238)))))));
j31eval[0]=sj32;
if( IKabs(j31eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[6];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x255 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x255.valid){
continue;
}
IkReal x254=x255.value;
j31array[0]=((-1.0)*x254);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x254)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x256=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x256)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x256))+((cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x256))))+IKsqr(((((-1.0)*new_r01*x256))+((cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x256))), ((((-1.0)*new_r01*x256))+((cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x257=IKsin(j33);
IkReal x258=IKcos(j33);
IkReal x259=((1.0)*sj31);
IkReal x260=((1.0)*x258);
IkReal x261=(sj31*x257);
IkReal x262=((1.0)*x257);
IkReal x263=(cj31*x260);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x257);
evalcond[1]=(((cj31*x257))+((sj31*x258))+new_r01);
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x260)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x262))+(((-1.0)*new_r00*x259)));
evalcond[4]=((((-1.0)*new_r01*x259))+((cj31*new_r11))+(((-1.0)*x260)));
evalcond[5]=(x261+new_r00+(((-1.0)*x263)));
evalcond[6]=(x261+new_r11+(((-1.0)*x263)));
evalcond[7]=((((-1.0)*cj31*x262))+new_r10+(((-1.0)*x258*x259)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j31array[2], cj31array[2], sj31array[2];
bool j31valid[2]={false};
_nj31 = 2;
CheckValue<IkReal> x265 = IKatan2WithCheck(IkReal(new_r02),new_r12,IKFAST_ATAN2_MAGTHRESH);
if(!x265.valid){
continue;
}
IkReal x264=x265.value;
j31array[0]=((-1.0)*x264);
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
j31array[1]=((3.14159265358979)+(((-1.0)*x264)));
sj31array[1]=IKsin(j31array[1]);
cj31array[1]=IKcos(j31array[1]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
if( j31array[1] > IKPI )
{
    j31array[1]-=IK2PI;
}
else if( j31array[1] < -IKPI )
{    j31array[1]+=IK2PI;
}
j31valid[1] = true;
for(int ij31 = 0; ij31 < 2; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 2; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[1];
evalcond[0]=(((new_r12*(IKcos(j31))))+(((-1.0)*new_r02*(IKsin(j31)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x266=((1.0)*sj31);
if( IKabs(((((-1.0)*new_r00*x266))+((cj31*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x266))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*x266))+((cj31*new_r01))))+IKsqr(((((-1.0)*new_r01*x266))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*new_r00*x266))+((cj31*new_r01))), ((((-1.0)*new_r01*x266))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x267=IKsin(j33);
IkReal x268=IKcos(j33);
IkReal x269=((1.0)*sj31);
IkReal x270=((1.0)*x267);
IkReal x271=(sj31*x268);
IkReal x272=((1.0)*x268);
IkReal x273=(cj31*x270);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x268);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x270)));
evalcond[2]=(((sj31*x267))+((cj31*x268))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x269))+(((-1.0)*x270)));
evalcond[4]=((((-1.0)*new_r01*x269))+((cj31*new_r11))+(((-1.0)*x272)));
evalcond[5]=(x271+(((-1.0)*x273))+new_r01);
evalcond[6]=(x271+(((-1.0)*x273))+new_r10);
evalcond[7]=((((-1.0)*cj31*x272))+(((-1.0)*x267*x269))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j31, j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x275=IKPowWithIntegerCheck(sj32,-1);
if(!x275.valid){
continue;
}
IkReal x274=x275.value;
CheckValue<IkReal> x276=IKPowWithIntegerCheck(new_r12,-1);
if(!x276.valid){
continue;
}
if( IKabs((x274*(x276.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r02*x274)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x274*(x276.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))))+IKsqr((new_r02*x274))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j31array[0]=IKatan2((x274*(x276.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj32*cj32)))))), (new_r02*x274));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x277=IKcos(j31);
IkReal x278=IKsin(j31);
IkReal x279=((1.0)*sj32);
IkReal x280=(new_r02*x277);
IkReal x281=(new_r12*x278);
IkReal x282=(sj32*x277);
IkReal x283=(sj32*x278);
evalcond[0]=((((-1.0)*x277*x279))+new_r02);
evalcond[1]=((((-1.0)*x278*x279))+new_r12);
evalcond[2]=((((-1.0)*new_r02*x278))+((new_r12*x277)));
evalcond[3]=(x281+x280+(((-1.0)*x279)));
evalcond[4]=(((cj32*new_r20))+((new_r00*x282))+((new_r10*x283)));
evalcond[5]=(((cj32*new_r21))+((new_r11*x283))+((new_r01*x282)));
evalcond[6]=((-1.0)+((cj32*new_r22))+((sj32*x281))+((sj32*x280)));
evalcond[7]=((((-1.0)*new_r22*x279))+((cj32*x281))+((cj32*x280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[2];
IkReal x284=(sj27*sj29);
IkReal x285=(cj27*sj29);
IkReal x286=(cj28*sj29);
IkReal x287=(cj28*cj30);
IkReal x288=((1.0)*sj30);
IkReal x289=((1.0)*cj29);
IkReal x290=(cj29*x288);
IkReal x291=((1.0)*cj30*sj28);
IkReal x292=x202;
IkReal x293=x203;
IkReal x294=x204;
IkReal x295=((((-1.0)*sj28*x290))+x287);
IkReal x296=(cj27*x295);
IkReal x297=x207;
IkReal x298=((((-1.0)*x291))+(((-1.0)*cj28*x290)));
IkReal x299=(cj27*x297);
IkReal x300=(((sj30*x285))+((sj27*x295)));
IkReal x301=(x296+(((-1.0)*sj30*x284)));
IkReal x302=(((cj30*x285))+((sj27*x297)));
IkReal x303=((((-1.0)*cj30*x284))+x299);
new_r00=(((r00*(((((-1.0)*cj30*x284))+x299))))+((r20*x292))+((r10*x302)));
new_r01=(((r11*x302))+((r01*x303))+((r21*x292)));
new_r02=(((r02*x303))+((r22*x292))+((r12*x302)));
new_r10=(((r00*x293))+((r10*x294))+((r20*x286)));
new_r11=(((r21*x286))+((r01*x293))+((r11*x294)));
new_r12=(((r12*x294))+((r22*x286))+((r02*x293)));
new_r20=(((r20*x298))+((r10*x300))+((r00*x301)));
new_r21=(((r11*x300))+((r01*x301))+((r21*x298)));
new_r22=(((r02*((x296+(((-1.0)*x284*x288))))))+((r22*x298))+((r12*x300)));
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
IkReal x304=(sj27*sj29);
IkReal x305=(cj27*sj29);
IkReal x306=(cj28*sj29);
IkReal x307=(cj28*cj30);
IkReal x308=((1.0)*sj30);
IkReal x309=((1.0)*cj29);
IkReal x310=(cj29*x308);
IkReal x311=((1.0)*cj30*sj28);
IkReal x312=x202;
IkReal x313=x203;
IkReal x314=x204;
IkReal x315=(x307+(((-1.0)*sj28*x310)));
IkReal x316=(cj27*x315);
IkReal x317=x207;
IkReal x318=((((-1.0)*cj28*x310))+(((-1.0)*x311)));
IkReal x319=(cj27*x317);
IkReal x320=(((sj27*x315))+((sj30*x305)));
IkReal x321=(x316+(((-1.0)*sj30*x304)));
IkReal x322=(((cj30*x305))+((sj27*x317)));
IkReal x323=((((-1.0)*cj30*x304))+x319);
new_r00=(((r20*x312))+((r00*(((((-1.0)*cj30*x304))+x319))))+((r10*x322)));
new_r01=(((r11*x322))+((r01*x323))+((r21*x312)));
new_r02=(((r02*x323))+((r12*x322))+((r22*x312)));
new_r10=(((r20*x306))+((r00*x313))+((r10*x314)));
new_r11=(((r11*x314))+((r21*x306))+((r01*x313)));
new_r12=(((r22*x306))+((r02*x313))+((r12*x314)));
new_r20=(((r00*x321))+((r20*x318))+((r10*x320)));
new_r21=(((r11*x320))+((r01*x321))+((r21*x318)));
new_r22=(((r12*x320))+((r02*((x316+(((-1.0)*x304*x308))))))+((r22*x318)));
j33eval[0]=sj31;
j33eval[1]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
IkReal x324=(sj27*sj29);
IkReal x325=(cj27*sj29);
IkReal x326=(cj28*sj29);
IkReal x327=(cj28*cj30);
IkReal x328=((1.0)*sj30);
IkReal x329=((1.0)*cj29);
IkReal x330=(cj29*x328);
IkReal x331=((1.0)*cj30*sj28);
IkReal x332=x202;
IkReal x333=x203;
IkReal x334=x204;
IkReal x335=((((-1.0)*sj28*x330))+x327);
IkReal x336=(cj27*x335);
IkReal x337=x207;
IkReal x338=((((-1.0)*cj28*x330))+(((-1.0)*x331)));
IkReal x339=(cj27*x337);
IkReal x340=(((sj30*x325))+((sj27*x335)));
IkReal x341=((((-1.0)*sj30*x324))+x336);
IkReal x342=(((sj27*x337))+((cj30*x325)));
IkReal x343=(x339+(((-1.0)*cj30*x324)));
new_r00=(((r00*((x339+(((-1.0)*cj30*x324))))))+((r20*x332))+((r10*x342)));
new_r01=(((r01*x343))+((r21*x332))+((r11*x342)));
new_r02=(((r22*x332))+((r02*x343))+((r12*x342)));
new_r10=(((r00*x333))+((r20*x326))+((r10*x334)));
new_r11=(((r01*x333))+((r11*x334))+((r21*x326)));
new_r12=(((r12*x334))+((r02*x333))+((r22*x326)));
new_r20=(((r00*x341))+((r20*x338))+((r10*x340)));
new_r21=(((r01*x341))+((r21*x338))+((r11*x340)));
new_r22=(((r22*x338))+((r02*((x336+(((-1.0)*x324*x328))))))+((r12*x340)));
j33eval[0]=cj31;
j33eval[1]=cj32;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x344=((((-1.0)*cj32))+new_r22);
IkReal x345=((((-1.0)*sj32))+new_r12);
IkReal x346=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x344;
evalcond[2]=x344;
evalcond[3]=new_r02;
evalcond[4]=x345;
evalcond[5]=x345;
evalcond[6]=(((new_r10*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r11*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));
evalcond[9]=(((cj32*new_r12))+(((-1.0)*new_r22*x346)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x347 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x347.valid){
continue;
}
CheckValue<IkReal> x348=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x348.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x347.value)+(((1.5707963267949)*(x348.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x349=IKsin(j33);
IkReal x350=IKcos(j33);
IkReal x351=((1.0)*new_r12);
IkReal x352=((1.0)*x350);
IkReal x353=((1.0)*x349);
evalcond[0]=(new_r20+((new_r12*x350)));
evalcond[1]=(((new_r22*x349))+new_r11);
evalcond[2]=((((-1.0)*x349*x351))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x352))+new_r10);
evalcond[4]=((((-1.0)*x353))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x352))+(((-1.0)*new_r01)));
evalcond[6]=(x349+((new_r11*new_r22))+(((-1.0)*new_r21*x351)));
evalcond[7]=((((-1.0)*x352))+((new_r10*new_r22))+(((-1.0)*new_r20*x351)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x354=((((-1.0)*cj32))+new_r22);
IkReal x355=((1.0)*sj32);
IkReal x356=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x354;
evalcond[2]=x354;
evalcond[3]=new_r02;
evalcond[4]=(sj32+new_r12);
evalcond[5]=((((-1.0)*x356))+(((-1.0)*x355)));
evalcond[6]=(((cj32*new_r20))+(((-1.0)*new_r10*x355)));
evalcond[7]=((((-1.0)*new_r11*x355))+((cj32*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*new_r12*x355))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x355))+(((-1.0)*cj32*x356)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x357=IKsin(j33);
IkReal x358=IKcos(j33);
IkReal x359=((1.0)*new_r10);
IkReal x360=((1.0)*new_r11);
IkReal x361=((1.0)*x358);
evalcond[0]=(new_r21+((new_r12*x357)));
evalcond[1]=((((-1.0)*x357))+new_r00);
evalcond[2]=((((-1.0)*x361))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x361))+new_r20);
evalcond[4]=(((new_r22*x357))+(((-1.0)*x360)));
evalcond[5]=((((-1.0)*x359))+(((-1.0)*new_r22*x361)));
evalcond[6]=((((-1.0)*new_r22*x360))+x357+((new_r12*new_r21)));
evalcond[7]=((((-1.0)*new_r22*x359))+(((-1.0)*x361))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x362=((1.0)*sj31);
IkReal x363=(((cj31*new_r12))+(((-1.0)*new_r02*x362)));
IkReal x364=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x365=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x366=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj31))+new_r02);
evalcond[3]=((((-1.0)*x362))+new_r12);
evalcond[4]=x363;
evalcond[5]=x363;
evalcond[6]=x366;
evalcond[7]=x365;
evalcond[8]=x364;
evalcond[9]=x364;
evalcond[10]=x365;
evalcond[11]=x366;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x367=IKcos(j33);
IkReal x368=IKsin(j33);
IkReal x369=((1.0)*new_r12);
IkReal x370=((1.0)*x368);
IkReal x371=((1.0)*x367);
evalcond[0]=(x367+new_r20);
evalcond[1]=((((-1.0)*x370))+new_r21);
evalcond[2]=(new_r01+((new_r12*x367)));
evalcond[3]=(new_r00+((new_r12*x368)));
evalcond[4]=(new_r11+(((-1.0)*new_r02*x371)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x370)));
evalcond[6]=((((-1.0)*new_r00*x369))+(((-1.0)*x370))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*x371))+((new_r02*new_r11))+(((-1.0)*new_r01*x369)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x372=(new_r10*sj31);
IkReal x373=(cj31*new_r00);
IkReal x374=(cj31*new_r02);
IkReal x375=(new_r11*sj31);
IkReal x376=(new_r12*sj31);
IkReal x377=(cj31*new_r01);
IkReal x378=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj31+new_r02);
evalcond[3]=(sj31+new_r12);
evalcond[4]=x378;
evalcond[5]=x378;
evalcond[6]=((1.0)+x376+x374);
evalcond[7]=(x377+x375);
evalcond[8]=(x373+x372);
evalcond[9]=((((-1.0)*x373))+(((-1.0)*x372)));
evalcond[10]=((((-1.0)*x377))+(((-1.0)*x375)));
evalcond[11]=((-1.0)+(((-1.0)*x374))+(((-1.0)*x376)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x379=IKcos(j33);
IkReal x380=IKsin(j33);
IkReal x381=((1.0)*new_r02);
IkReal x382=((1.0)*x379);
IkReal x383=((1.0)*x380);
evalcond[0]=(x380+new_r21);
evalcond[1]=((((-1.0)*x382))+new_r20);
evalcond[2]=(new_r11+((new_r02*x379)));
evalcond[3]=(((new_r02*x380))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x382))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x383))+new_r00);
evalcond[6]=((((-1.0)*new_r10*x381))+((new_r00*new_r12))+(((-1.0)*x383)));
evalcond[7]=((((-1.0)*new_r11*x381))+((new_r01*new_r12))+(((-1.0)*x382)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x384=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x385=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x384;
evalcond[7]=x384;
evalcond[8]=x385;
evalcond[9]=x385;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x386=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x386)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x386)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x386))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x386))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x386))), (((cj31*new_r00))+(((-1.0)*new_r01*x386))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x387=IKsin(j33);
IkReal x388=IKcos(j33);
IkReal x389=((1.0)*sj31);
IkReal x390=((1.0)*x388);
IkReal x391=(sj31*x387);
IkReal x392=((1.0)*x387);
IkReal x393=(cj31*x390);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x387);
evalcond[1]=(((sj31*x388))+((cj31*x387))+new_r01);
evalcond[2]=((((-1.0)*x390))+((cj31*new_r00))+((new_r10*sj31)));
evalcond[3]=((((-1.0)*x392))+((cj31*new_r10))+(((-1.0)*new_r00*x389)));
evalcond[4]=((((-1.0)*x390))+((cj31*new_r11))+(((-1.0)*new_r01*x389)));
evalcond[5]=((((-1.0)*x393))+x391+new_r00);
evalcond[6]=((((-1.0)*x393))+x391+new_r11);
evalcond[7]=((((-1.0)*cj31*x392))+new_r10+(((-1.0)*x388*x389)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x394=(cj31*new_r02);
IkReal x395=(new_r12*sj31);
IkReal x396=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x396;
evalcond[7]=x396;
evalcond[8]=(x395+x394);
evalcond[9]=((((-1.0)*x395))+(((-1.0)*x394)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x397=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x397)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x397))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x397))))+IKsqr(((((-1.0)*new_r01*x397))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x397))), ((((-1.0)*new_r01*x397))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x398=IKsin(j33);
IkReal x399=IKcos(j33);
IkReal x400=((1.0)*sj31);
IkReal x401=((1.0)*x398);
IkReal x402=(sj31*x399);
IkReal x403=((1.0)*x399);
IkReal x404=(cj31*x401);
evalcond[0]=(((cj31*new_r00))+x399+((new_r10*sj31)));
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x401)));
evalcond[2]=(((cj31*x399))+((sj31*x398))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x400))+(((-1.0)*x401)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x400))+(((-1.0)*x403)));
evalcond[5]=(x402+new_r01+(((-1.0)*x404)));
evalcond[6]=(x402+new_r10+(((-1.0)*x404)));
evalcond[7]=((((-1.0)*cj31*x403))+(((-1.0)*x398*x400))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x405=((((-1.0)*cj32))+new_r22);
IkReal x406=((((-1.0)*sj32))+new_r02);
IkReal x407=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x405;
evalcond[2]=x405;
evalcond[3]=x406;
evalcond[4]=new_r12;
evalcond[5]=x406;
evalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x407)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x408=IKcos(j33);
IkReal x409=IKsin(j33);
IkReal x410=((1.0)*new_r02);
IkReal x411=((1.0)*x408);
evalcond[0]=(new_r20+((new_r02*x408)));
evalcond[1]=(new_r10+(((-1.0)*x409)));
evalcond[2]=(new_r11+(((-1.0)*x411)));
evalcond[3]=(((new_r22*x409))+new_r01);
evalcond[4]=(new_r21+(((-1.0)*x409*x410)));
evalcond[5]=(new_r00+(((-1.0)*new_r22*x411)));
evalcond[6]=(((new_r01*new_r22))+x409+(((-1.0)*new_r21*x410)));
evalcond[7]=(((new_r00*new_r22))+(((-1.0)*new_r20*x410))+(((-1.0)*x411)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x412=((((-1.0)*cj32))+new_r22);
IkReal x413=((1.0)*sj32);
IkReal x414=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x412;
evalcond[2]=x412;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x414))+(((-1.0)*x413)));
evalcond[6]=(((cj32*new_r20))+(((-1.0)*new_r00*x413)));
evalcond[7]=(((cj32*new_r21))+(((-1.0)*new_r01*x413)));
evalcond[8]=((-1.0)+((cj32*new_r22))+(((-1.0)*new_r02*x413)));
evalcond[9]=((((-1.0)*cj32*x414))+(((-1.0)*new_r22*x413)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x415 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x415.valid){
continue;
}
CheckValue<IkReal> x416=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x416.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x415.value)+(((1.5707963267949)*(x416.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x417=IKsin(j33);
IkReal x418=IKcos(j33);
IkReal x419=((1.0)*new_r22);
IkReal x420=((1.0)*x418);
evalcond[0]=(new_r21+((new_r02*x417)));
evalcond[1]=((((-1.0)*new_r02*x420))+new_r20);
evalcond[2]=((((-1.0)*new_r10))+(((-1.0)*x417)));
evalcond[3]=((((-1.0)*x420))+(((-1.0)*new_r11)));
evalcond[4]=(((new_r22*x417))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x418*x419))+(((-1.0)*new_r00)));
evalcond[6]=(x417+((new_r02*new_r21))+(((-1.0)*new_r01*x419)));
evalcond[7]=((((-1.0)*x420))+((new_r02*new_r20))+(((-1.0)*new_r00*x419)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x422=IKPowWithIntegerCheck(sj32,-1);
if(!x422.valid){
continue;
}
IkReal x421=x422.value;
CheckValue<IkReal> x423=IKPowWithIntegerCheck(cj31,-1);
if(!x423.valid){
continue;
}
CheckValue<IkReal> x424=IKPowWithIntegerCheck(cj32,-1);
if(!x424.valid){
continue;
}
if( IKabs((x421*(x423.value)*(x424.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x421)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x421*(x423.value)*(x424.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x421))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x421*(x423.value)*(x424.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x421));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x425=IKsin(j33);
IkReal x426=IKcos(j33);
IkReal x427=(cj31*cj32);
IkReal x428=((1.0)*sj31);
IkReal x429=(new_r11*sj31);
IkReal x430=(new_r10*sj31);
IkReal x431=((1.0)*sj32);
IkReal x432=((1.0)*x426);
IkReal x433=((1.0)*x425);
IkReal x434=(sj31*x425);
evalcond[0]=(new_r20+((sj32*x426)));
evalcond[1]=((((-1.0)*x425*x431))+new_r21);
evalcond[2]=(((cj31*new_r01))+x429+((cj32*x425)));
evalcond[3]=((((-1.0)*x433))+((cj31*new_r10))+(((-1.0)*new_r00*x428)));
evalcond[4]=((((-1.0)*x432))+((cj31*new_r11))+(((-1.0)*new_r01*x428)));
evalcond[5]=(((x425*x427))+((sj31*x426))+new_r01);
evalcond[6]=(((cj31*new_r00))+x430+(((-1.0)*cj32*x432)));
evalcond[7]=((((-1.0)*x427*x432))+x434+new_r00);
evalcond[8]=(((cj32*x434))+(((-1.0)*cj31*x432))+new_r11);
evalcond[9]=((((-1.0)*cj32*x426*x428))+(((-1.0)*cj31*x433))+new_r10);
evalcond[10]=(x425+((cj32*x429))+((new_r01*x427))+(((-1.0)*new_r21*x431)));
evalcond[11]=((((-1.0)*x432))+((cj32*x430))+(((-1.0)*new_r20*x431))+((new_r00*x427)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x436=IKPowWithIntegerCheck(sj32,-1);
if(!x436.valid){
continue;
}
IkReal x435=x436.value;
CheckValue<IkReal> x437=IKPowWithIntegerCheck(sj31,-1);
if(!x437.valid){
continue;
}
if( IKabs((x435*(x437.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x435)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x435*(x437.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x435))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x435*(x437.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x435));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x438=IKsin(j33);
IkReal x439=IKcos(j33);
IkReal x440=(cj31*cj32);
IkReal x441=((1.0)*sj31);
IkReal x442=(new_r11*sj31);
IkReal x443=(new_r10*sj31);
IkReal x444=((1.0)*sj32);
IkReal x445=((1.0)*x439);
IkReal x446=((1.0)*x438);
IkReal x447=(sj31*x438);
evalcond[0]=(((sj32*x439))+new_r20);
evalcond[1]=((((-1.0)*x438*x444))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x438))+x442);
evalcond[3]=((((-1.0)*x446))+(((-1.0)*new_r00*x441))+((cj31*new_r10)));
evalcond[4]=((((-1.0)*x445))+((cj31*new_r11))+(((-1.0)*new_r01*x441)));
evalcond[5]=(((sj31*x439))+((x438*x440))+new_r01);
evalcond[6]=(((cj31*new_r00))+x443+(((-1.0)*cj32*x445)));
evalcond[7]=(x447+new_r00+(((-1.0)*x440*x445)));
evalcond[8]=(((cj32*x447))+(((-1.0)*cj31*x445))+new_r11);
evalcond[9]=((((-1.0)*cj31*x446))+new_r10+(((-1.0)*cj32*x439*x441)));
evalcond[10]=(((new_r01*x440))+((cj32*x442))+x438+(((-1.0)*new_r21*x444)));
evalcond[11]=(((new_r00*x440))+(((-1.0)*x445))+((cj32*x443))+(((-1.0)*new_r20*x444)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x448=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x448.valid){
continue;
}
CheckValue<IkReal> x449 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x449.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x448.value)))+(x449.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x450=IKsin(j33);
IkReal x451=IKcos(j33);
IkReal x452=(cj31*cj32);
IkReal x453=((1.0)*sj31);
IkReal x454=(new_r11*sj31);
IkReal x455=(new_r10*sj31);
IkReal x456=((1.0)*sj32);
IkReal x457=((1.0)*x451);
IkReal x458=((1.0)*x450);
IkReal x459=(sj31*x450);
evalcond[0]=(((sj32*x451))+new_r20);
evalcond[1]=((((-1.0)*x450*x456))+new_r21);
evalcond[2]=(((cj31*new_r01))+x454+((cj32*x450)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x453))+(((-1.0)*x458)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*new_r01*x453))+(((-1.0)*x457)));
evalcond[5]=(((x450*x452))+new_r01+((sj31*x451)));
evalcond[6]=((((-1.0)*cj32*x457))+((cj31*new_r00))+x455);
evalcond[7]=(x459+(((-1.0)*x452*x457))+new_r00);
evalcond[8]=(new_r11+((cj32*x459))+(((-1.0)*cj31*x457)));
evalcond[9]=((((-1.0)*cj32*x451*x453))+new_r10+(((-1.0)*cj31*x458)));
evalcond[10]=((((-1.0)*new_r21*x456))+((new_r01*x452))+x450+((cj32*x454)));
evalcond[11]=((((-1.0)*new_r20*x456))+((new_r00*x452))+(((-1.0)*x457))+((cj32*x455)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j31array[1], cj31array[1], sj31array[1];
bool j31valid[1]={false};
_nj31 = 1;
CheckValue<IkReal> x460=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x460.valid){
continue;
}
CheckValue<IkReal> x461 = IKatan2WithCheck(IkReal(new_r12),new_r02,IKFAST_ATAN2_MAGTHRESH);
if(!x461.valid){
continue;
}
j31array[0]=((-1.5707963267949)+(((1.5707963267949)*(x460.value)))+(x461.value));
sj31array[0]=IKsin(j31array[0]);
cj31array[0]=IKcos(j31array[0]);
if( j31array[0] > IKPI )
{
    j31array[0]-=IK2PI;
}
else if( j31array[0] < -IKPI )
{    j31array[0]+=IK2PI;
}
j31valid[0] = true;
for(int ij31 = 0; ij31 < 1; ++ij31)
{
if( !j31valid[ij31] )
{
    continue;
}
_ij31[0] = ij31; _ij31[1] = -1;
for(int iij31 = ij31+1; iij31 < 1; ++iij31)
{
if( j31valid[iij31] && IKabs(cj31array[ij31]-cj31array[iij31]) < IKFAST_SOLUTION_THRESH && IKabs(sj31array[ij31]-sj31array[iij31]) < IKFAST_SOLUTION_THRESH )
{
    j31valid[iij31]=false; _ij31[1] = iij31; break; 
}
}
j31 = j31array[ij31]; cj31 = cj31array[ij31]; sj31 = sj31array[ij31];
{
IkReal evalcond[8];
IkReal x462=IKcos(j31);
IkReal x463=IKsin(j31);
IkReal x464=((1.0)*sj32);
IkReal x465=(new_r02*x462);
IkReal x466=(new_r12*x463);
IkReal x467=(sj32*x462);
IkReal x468=(sj32*x463);
evalcond[0]=((((-1.0)*x462*x464))+new_r02);
evalcond[1]=((((-1.0)*x463*x464))+new_r12);
evalcond[2]=(((new_r12*x462))+(((-1.0)*new_r02*x463)));
evalcond[3]=((((-1.0)*x464))+x466+x465);
evalcond[4]=(((new_r10*x468))+((new_r00*x467))+((cj32*new_r20)));
evalcond[5]=(((new_r11*x468))+((new_r01*x467))+((cj32*new_r21)));
evalcond[6]=((-1.0)+((sj32*x466))+((sj32*x465))+((cj32*new_r22)));
evalcond[7]=((((-1.0)*new_r22*x464))+((cj32*x465))+((cj32*x466)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j33eval[2];
IkReal x469=(sj27*sj29);
IkReal x470=(cj27*sj29);
IkReal x471=(cj28*sj29);
IkReal x472=(cj28*cj30);
IkReal x473=((1.0)*sj30);
IkReal x474=((1.0)*cj29);
IkReal x475=(cj29*x473);
IkReal x476=((1.0)*cj30*sj28);
IkReal x477=x202;
IkReal x478=x203;
IkReal x479=x204;
IkReal x480=((((-1.0)*sj28*x475))+x472);
IkReal x481=(cj27*x480);
IkReal x482=x207;
IkReal x483=((((-1.0)*cj28*x475))+(((-1.0)*x476)));
IkReal x484=(cj27*x482);
IkReal x485=(((sj27*x480))+((sj30*x470)));
IkReal x486=((((-1.0)*sj30*x469))+x481);
IkReal x487=(((sj27*x482))+((cj30*x470)));
IkReal x488=(x484+(((-1.0)*cj30*x469)));
new_r00=(((r20*x477))+((r10*x487))+((r00*((x484+(((-1.0)*cj30*x469)))))));
new_r01=(((r21*x477))+((r11*x487))+((r01*x488)));
new_r02=(((r02*x488))+((r12*x487))+((r22*x477)));
new_r10=(((r10*x479))+((r20*x471))+((r00*x478)));
new_r11=(((r21*x471))+((r11*x479))+((r01*x478)));
new_r12=(((r02*x478))+((r12*x479))+((r22*x471)));
new_r20=(((r20*x483))+((r10*x485))+((r00*x486)));
new_r21=(((r11*x485))+((r21*x483))+((r01*x486)));
new_r22=(((r12*x485))+((r22*x483))+((r02*(((((-1.0)*x469*x473))+x481)))));
j33eval[0]=sj32;
j33eval[1]=IKsign(sj32);
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[2];
IkReal x489=(sj27*sj29);
IkReal x490=(cj27*sj29);
IkReal x491=(cj28*sj29);
IkReal x492=(cj28*cj30);
IkReal x493=((1.0)*sj30);
IkReal x494=((1.0)*cj29);
IkReal x495=(cj29*x493);
IkReal x496=((1.0)*cj30*sj28);
IkReal x497=x202;
IkReal x498=x203;
IkReal x499=x204;
IkReal x500=(x492+(((-1.0)*sj28*x495)));
IkReal x501=(cj27*x500);
IkReal x502=x207;
IkReal x503=((((-1.0)*x496))+(((-1.0)*cj28*x495)));
IkReal x504=(cj27*x502);
IkReal x505=(((sj27*x500))+((sj30*x490)));
IkReal x506=((((-1.0)*sj30*x489))+x501);
IkReal x507=(((sj27*x502))+((cj30*x490)));
IkReal x508=((((-1.0)*cj30*x489))+x504);
new_r00=(((r10*x507))+((r00*(((((-1.0)*cj30*x489))+x504))))+((r20*x497)));
new_r01=(((r01*x508))+((r11*x507))+((r21*x497)));
new_r02=(((r22*x497))+((r12*x507))+((r02*x508)));
new_r10=(((r10*x499))+((r00*x498))+((r20*x491)));
new_r11=(((r11*x499))+((r21*x491))+((r01*x498)));
new_r12=(((r02*x498))+((r22*x491))+((r12*x499)));
new_r20=(((r20*x503))+((r10*x505))+((r00*x506)));
new_r21=(((r21*x503))+((r01*x506))+((r11*x505)));
new_r22=(((r02*(((((-1.0)*x489*x493))+x501))))+((r22*x503))+((r12*x505)));
j33eval[0]=sj31;
j33eval[1]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  )
{
{
IkReal j33eval[3];
IkReal x509=(sj27*sj29);
IkReal x510=(cj27*sj29);
IkReal x511=(cj28*sj29);
IkReal x512=(cj28*cj30);
IkReal x513=((1.0)*sj30);
IkReal x514=((1.0)*cj29);
IkReal x515=(cj29*x513);
IkReal x516=((1.0)*cj30*sj28);
IkReal x517=x202;
IkReal x518=x203;
IkReal x519=x204;
IkReal x520=(x512+(((-1.0)*sj28*x515)));
IkReal x521=(cj27*x520);
IkReal x522=x207;
IkReal x523=((((-1.0)*cj28*x515))+(((-1.0)*x516)));
IkReal x524=(cj27*x522);
IkReal x525=(((sj27*x520))+((sj30*x510)));
IkReal x526=(x521+(((-1.0)*sj30*x509)));
IkReal x527=(((cj30*x510))+((sj27*x522)));
IkReal x528=(x524+(((-1.0)*cj30*x509)));
new_r00=(((r20*x517))+((r10*x527))+((r00*((x524+(((-1.0)*cj30*x509)))))));
new_r01=(((r11*x527))+((r21*x517))+((r01*x528)));
new_r02=(((r02*x528))+((r12*x527))+((r22*x517)));
new_r10=(((r20*x511))+((r10*x519))+((r00*x518)));
new_r11=(((r01*x518))+((r11*x519))+((r21*x511)));
new_r12=(((r02*x518))+((r22*x511))+((r12*x519)));
new_r20=(((r20*x523))+((r10*x525))+((r00*x526)));
new_r21=(((r21*x523))+((r11*x525))+((r01*x526)));
new_r22=(((r12*x525))+((r22*x523))+((r02*((x521+(((-1.0)*x509*x513)))))));
j33eval[0]=cj31;
j33eval[1]=cj32;
j33eval[2]=sj32;
if( IKabs(j33eval[0]) < 0.0000010000000000  || IKabs(j33eval[1]) < 0.0000010000000000  || IKabs(j33eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[12];
bool bgotonextstatement = true;
do
{
IkReal x529=((((-1.0)*cj32))+new_r22);
IkReal x530=((((-1.0)*sj32))+new_r12);
IkReal x531=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x529;
evalcond[2]=x529;
evalcond[3]=new_r02;
evalcond[4]=x530;
evalcond[5]=x530;
evalcond[6]=(((new_r10*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r11*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r12*sj32))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*new_r22*x531))+((cj32*new_r12)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
CheckValue<IkReal> x533=IKPowWithIntegerCheck(IKsign(new_r12),-1);
if(!x533.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x532.value)+(((1.5707963267949)*(x533.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x534=IKsin(j33);
IkReal x535=IKcos(j33);
IkReal x536=((1.0)*new_r12);
IkReal x537=((1.0)*x535);
IkReal x538=((1.0)*x534);
evalcond[0]=(((new_r12*x535))+new_r20);
evalcond[1]=(((new_r22*x534))+new_r11);
evalcond[2]=((((-1.0)*x534*x536))+new_r21);
evalcond[3]=((((-1.0)*new_r22*x537))+new_r10);
evalcond[4]=((((-1.0)*x538))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*x537))+(((-1.0)*new_r01)));
evalcond[6]=((((-1.0)*new_r21*x536))+x534+((new_r11*new_r22)));
evalcond[7]=((((-1.0)*x537))+(((-1.0)*new_r20*x536))+((new_r10*new_r22)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x539=((((-1.0)*cj32))+new_r22);
IkReal x540=((1.0)*sj32);
IkReal x541=((1.0)*new_r12);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j31)))), 6.28318530717959)));
evalcond[1]=x539;
evalcond[2]=x539;
evalcond[3]=new_r02;
evalcond[4]=(sj32+new_r12);
evalcond[5]=((((-1.0)*x541))+(((-1.0)*x540)));
evalcond[6]=((((-1.0)*new_r10*x540))+((cj32*new_r20)));
evalcond[7]=((((-1.0)*new_r11*x540))+((cj32*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*new_r12*x540))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*cj32*x541))+(((-1.0)*new_r22*x540)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r00)+IKsqr(new_r01)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r00, new_r01);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x542=IKsin(j33);
IkReal x543=IKcos(j33);
IkReal x544=((1.0)*new_r10);
IkReal x545=((1.0)*new_r11);
IkReal x546=((1.0)*x543);
evalcond[0]=(((new_r12*x542))+new_r21);
evalcond[1]=((((-1.0)*x542))+new_r00);
evalcond[2]=((((-1.0)*x546))+new_r01);
evalcond[3]=((((-1.0)*new_r12*x546))+new_r20);
evalcond[4]=((((-1.0)*x545))+((new_r22*x542)));
evalcond[5]=((((-1.0)*new_r22*x546))+(((-1.0)*x544)));
evalcond[6]=((((-1.0)*new_r22*x545))+((new_r12*new_r21))+x542);
evalcond[7]=((((-1.0)*new_r22*x544))+(((-1.0)*x546))+((new_r12*new_r20)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x547=((1.0)*sj31);
IkReal x548=(((cj31*new_r12))+(((-1.0)*new_r02*x547)));
IkReal x549=(((cj31*new_r00))+((new_r10*sj31)));
IkReal x550=(((cj31*new_r01))+((new_r11*sj31)));
IkReal x551=((-1.0)+((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=((((-1.0)*cj31))+new_r02);
evalcond[3]=((((-1.0)*x547))+new_r12);
evalcond[4]=x548;
evalcond[5]=x548;
evalcond[6]=x551;
evalcond[7]=x550;
evalcond[8]=x549;
evalcond[9]=x549;
evalcond[10]=x550;
evalcond[11]=x551;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r21)+IKsqr(((-1.0)*new_r20))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r21, ((-1.0)*new_r20));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x552=IKcos(j33);
IkReal x553=IKsin(j33);
IkReal x554=((1.0)*new_r12);
IkReal x555=((1.0)*x553);
IkReal x556=((1.0)*x552);
evalcond[0]=(x552+new_r20);
evalcond[1]=((((-1.0)*x555))+new_r21);
evalcond[2]=(((new_r12*x552))+new_r01);
evalcond[3]=(((new_r12*x553))+new_r00);
evalcond[4]=(new_r11+(((-1.0)*new_r02*x556)));
evalcond[5]=(new_r10+(((-1.0)*new_r02*x555)));
evalcond[6]=((((-1.0)*new_r00*x554))+(((-1.0)*x555))+((new_r02*new_r10)));
evalcond[7]=((((-1.0)*new_r01*x554))+(((-1.0)*x556))+((new_r02*new_r11)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x557=(new_r10*sj31);
IkReal x558=(cj31*new_r00);
IkReal x559=(cj31*new_r02);
IkReal x560=(new_r11*sj31);
IkReal x561=(new_r12*sj31);
IkReal x562=(cj31*new_r01);
IkReal x563=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j32)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=(cj31+new_r02);
evalcond[3]=(sj31+new_r12);
evalcond[4]=x563;
evalcond[5]=x563;
evalcond[6]=((1.0)+x559+x561);
evalcond[7]=(x562+x560);
evalcond[8]=(x558+x557);
evalcond[9]=((((-1.0)*x557))+(((-1.0)*x558)));
evalcond[10]=((((-1.0)*x560))+(((-1.0)*x562)));
evalcond[11]=((-1.0)+(((-1.0)*x559))+(((-1.0)*x561)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  && IKabs(evalcond[10]) < 0.0000010000000000  && IKabs(evalcond[11]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r21))+IKsqr(new_r20)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((-1.0)*new_r21), new_r20);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x564=IKcos(j33);
IkReal x565=IKsin(j33);
IkReal x566=((1.0)*new_r02);
IkReal x567=((1.0)*x564);
IkReal x568=((1.0)*x565);
evalcond[0]=(x565+new_r21);
evalcond[1]=(new_r20+(((-1.0)*x567)));
evalcond[2]=(((new_r02*x564))+new_r11);
evalcond[3]=(((new_r02*x565))+new_r10);
evalcond[4]=((((-1.0)*new_r12*x567))+new_r01);
evalcond[5]=((((-1.0)*new_r12*x568))+new_r00);
evalcond[6]=(((new_r00*new_r12))+(((-1.0)*new_r10*x566))+(((-1.0)*x568)));
evalcond[7]=(((new_r01*new_r12))+(((-1.0)*new_r11*x566))+(((-1.0)*x567)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x569=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
IkReal x570=(((cj31*new_r02))+((new_r12*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j32))), 6.28318530717959)));
evalcond[1]=((-1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x569;
evalcond[7]=x569;
evalcond[8]=x570;
evalcond[9]=x570;
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x571=((1.0)*sj31);
if( IKabs(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x571)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj31*new_r00))+(((-1.0)*new_r01*x571)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x571))))+IKsqr((((cj31*new_r00))+(((-1.0)*new_r01*x571))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(((((-1.0)*cj31*new_r01))+(((-1.0)*new_r00*x571))), (((cj31*new_r00))+(((-1.0)*new_r01*x571))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x572=IKsin(j33);
IkReal x573=IKcos(j33);
IkReal x574=((1.0)*sj31);
IkReal x575=((1.0)*x573);
IkReal x576=(sj31*x572);
IkReal x577=((1.0)*x572);
IkReal x578=(cj31*x575);
evalcond[0]=(((cj31*new_r01))+((new_r11*sj31))+x572);
evalcond[1]=(((cj31*x572))+new_r01+((sj31*x573)));
evalcond[2]=(((cj31*new_r00))+((new_r10*sj31))+(((-1.0)*x575)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x577))+(((-1.0)*new_r00*x574)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x575))+(((-1.0)*new_r01*x574)));
evalcond[5]=((((-1.0)*x578))+x576+new_r00);
evalcond[6]=((((-1.0)*x578))+x576+new_r11);
evalcond[7]=((((-1.0)*x573*x574))+new_r10+(((-1.0)*cj31*x577)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x579=(cj31*new_r02);
IkReal x580=(new_r12*sj31);
IkReal x581=(((cj31*new_r12))+(((-1.0)*new_r02*sj31)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j32)))), 6.28318530717959)));
evalcond[1]=((1.0)+new_r22);
evalcond[2]=new_r20;
evalcond[3]=new_r02;
evalcond[4]=new_r12;
evalcond[5]=new_r21;
evalcond[6]=x581;
evalcond[7]=x581;
evalcond[8]=(x579+x580);
evalcond[9]=((((-1.0)*x580))+(((-1.0)*x579)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
IkReal x582=((1.0)*sj31);
if( IKabs((((cj31*new_r01))+(((-1.0)*new_r00*x582)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x582))+(((-1.0)*cj31*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj31*new_r01))+(((-1.0)*new_r00*x582))))+IKsqr(((((-1.0)*new_r01*x582))+(((-1.0)*cj31*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((((cj31*new_r01))+(((-1.0)*new_r00*x582))), ((((-1.0)*new_r01*x582))+(((-1.0)*cj31*new_r00))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x583=IKsin(j33);
IkReal x584=IKcos(j33);
IkReal x585=((1.0)*sj31);
IkReal x586=((1.0)*x583);
IkReal x587=(sj31*x584);
IkReal x588=((1.0)*x584);
IkReal x589=(cj31*x586);
evalcond[0]=(((cj31*new_r00))+((new_r10*sj31))+x584);
evalcond[1]=(((cj31*new_r01))+((new_r11*sj31))+(((-1.0)*x586)));
evalcond[2]=(((cj31*x584))+((sj31*x583))+new_r00);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x586))+(((-1.0)*new_r00*x585)));
evalcond[4]=((((-1.0)*new_r01*x585))+((cj31*new_r11))+(((-1.0)*x588)));
evalcond[5]=(x587+new_r01+(((-1.0)*x589)));
evalcond[6]=(x587+new_r10+(((-1.0)*x589)));
evalcond[7]=((((-1.0)*cj31*x588))+(((-1.0)*x583*x585))+new_r11);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x590=((((-1.0)*cj32))+new_r22);
IkReal x591=((((-1.0)*sj32))+new_r02);
IkReal x592=((1.0)*sj32);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j31))), 6.28318530717959)));
evalcond[1]=x590;
evalcond[2]=x590;
evalcond[3]=x591;
evalcond[4]=new_r12;
evalcond[5]=x591;
evalcond[6]=(((new_r00*sj32))+((cj32*new_r20)));
evalcond[7]=(((new_r01*sj32))+((cj32*new_r21)));
evalcond[8]=((-1.0)+((new_r02*sj32))+((cj32*new_r22)));
evalcond[9]=(((cj32*new_r02))+(((-1.0)*new_r22*x592)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
if( IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r10)+IKsqr(new_r11)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2(new_r10, new_r11);
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x593=IKcos(j33);
IkReal x594=IKsin(j33);
IkReal x595=((1.0)*new_r02);
IkReal x596=((1.0)*x593);
evalcond[0]=(((new_r02*x593))+new_r20);
evalcond[1]=((((-1.0)*x594))+new_r10);
evalcond[2]=((((-1.0)*x596))+new_r11);
evalcond[3]=(new_r01+((new_r22*x594)));
evalcond[4]=((((-1.0)*x594*x595))+new_r21);
evalcond[5]=((((-1.0)*new_r22*x596))+new_r00);
evalcond[6]=((((-1.0)*new_r21*x595))+((new_r01*new_r22))+x594);
evalcond[7]=((((-1.0)*new_r20*x595))+((new_r00*new_r22))+(((-1.0)*x596)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x597=((((-1.0)*cj32))+new_r22);
IkReal x598=((1.0)*sj32);
IkReal x599=((1.0)*new_r02);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j31)))), 6.28318530717959)));
evalcond[1]=x597;
evalcond[2]=x597;
evalcond[3]=(sj32+new_r02);
evalcond[4]=new_r12;
evalcond[5]=((((-1.0)*x598))+(((-1.0)*x599)));
evalcond[6]=((((-1.0)*new_r00*x598))+((cj32*new_r20)));
evalcond[7]=((((-1.0)*new_r01*x598))+((cj32*new_r21)));
evalcond[8]=((-1.0)+(((-1.0)*new_r02*x598))+((cj32*new_r22)));
evalcond[9]=((((-1.0)*cj32*x599))+(((-1.0)*new_r22*x598)));
if( IKabs(evalcond[0]) < 0.0000010000000000  && IKabs(evalcond[1]) < 0.0000010000000000  && IKabs(evalcond[2]) < 0.0000010000000000  && IKabs(evalcond[3]) < 0.0000010000000000  && IKabs(evalcond[4]) < 0.0000010000000000  && IKabs(evalcond[5]) < 0.0000010000000000  && IKabs(evalcond[6]) < 0.0000010000000000  && IKabs(evalcond[7]) < 0.0000010000000000  && IKabs(evalcond[8]) < 0.0000010000000000  && IKabs(evalcond[9]) < 0.0000010000000000  )
{
bgotonextstatement=false;
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x600 = IKatan2WithCheck(IkReal(((-1.0)*new_r21)),new_r20,IKFAST_ATAN2_MAGTHRESH);
if(!x600.valid){
continue;
}
CheckValue<IkReal> x601=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x601.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(x600.value)+(((1.5707963267949)*(x601.value))));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[8];
IkReal x602=IKsin(j33);
IkReal x603=IKcos(j33);
IkReal x604=((1.0)*new_r22);
IkReal x605=((1.0)*x603);
evalcond[0]=(((new_r02*x602))+new_r21);
evalcond[1]=((((-1.0)*new_r02*x605))+new_r20);
evalcond[2]=((((-1.0)*x602))+(((-1.0)*new_r10)));
evalcond[3]=((((-1.0)*new_r11))+(((-1.0)*x605)));
evalcond[4]=(((new_r22*x602))+(((-1.0)*new_r01)));
evalcond[5]=((((-1.0)*x603*x604))+(((-1.0)*new_r00)));
evalcond[6]=(x602+(((-1.0)*new_r01*x604))+((new_r02*new_r21)));
evalcond[7]=((((-1.0)*x605))+((new_r02*new_r20))+(((-1.0)*new_r00*x604)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j33]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x607=IKPowWithIntegerCheck(sj32,-1);
if(!x607.valid){
continue;
}
IkReal x606=x607.value;
CheckValue<IkReal> x608=IKPowWithIntegerCheck(cj31,-1);
if(!x608.valid){
continue;
}
CheckValue<IkReal> x609=IKPowWithIntegerCheck(cj32,-1);
if(!x609.valid){
continue;
}
if( IKabs((x606*(x608.value)*(x609.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x606)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x606*(x608.value)*(x609.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))))+IKsqr(((-1.0)*new_r20*x606))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x606*(x608.value)*(x609.value)*((((new_r20*sj31))+(((-1.0)*new_r01*sj32))))), ((-1.0)*new_r20*x606));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x610=IKsin(j33);
IkReal x611=IKcos(j33);
IkReal x612=(cj31*cj32);
IkReal x613=((1.0)*sj31);
IkReal x614=(new_r11*sj31);
IkReal x615=(new_r10*sj31);
IkReal x616=((1.0)*sj32);
IkReal x617=((1.0)*x611);
IkReal x618=((1.0)*x610);
IkReal x619=(sj31*x610);
evalcond[0]=(((sj32*x611))+new_r20);
evalcond[1]=((((-1.0)*x610*x616))+new_r21);
evalcond[2]=(((cj31*new_r01))+((cj32*x610))+x614);
evalcond[3]=(((cj31*new_r10))+(((-1.0)*x618))+(((-1.0)*new_r00*x613)));
evalcond[4]=(((cj31*new_r11))+(((-1.0)*x617))+(((-1.0)*new_r01*x613)));
evalcond[5]=(((sj31*x611))+new_r01+((x610*x612)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x617))+x615);
evalcond[7]=((((-1.0)*x612*x617))+x619+new_r00);
evalcond[8]=(((cj32*x619))+new_r11+(((-1.0)*cj31*x617)));
evalcond[9]=((((-1.0)*cj32*x611*x613))+new_r10+(((-1.0)*cj31*x618)));
evalcond[10]=((((-1.0)*new_r21*x616))+((cj32*x614))+x610+((new_r01*x612)));
evalcond[11]=(((cj32*x615))+(((-1.0)*x617))+(((-1.0)*new_r20*x616))+((new_r00*x612)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x621=IKPowWithIntegerCheck(sj32,-1);
if(!x621.valid){
continue;
}
IkReal x620=x621.value;
CheckValue<IkReal> x622=IKPowWithIntegerCheck(sj31,-1);
if(!x622.valid){
continue;
}
if( IKabs((x620*(x622.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r20*x620)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x620*(x622.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))))+IKsqr(((-1.0)*new_r20*x620))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j33array[0]=IKatan2((x620*(x622.value)*(((((-1.0)*new_r00*sj32))+(((-1.0)*cj31*cj32*new_r20))))), ((-1.0)*new_r20*x620));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x623=IKsin(j33);
IkReal x624=IKcos(j33);
IkReal x625=(cj31*cj32);
IkReal x626=((1.0)*sj31);
IkReal x627=(new_r11*sj31);
IkReal x628=(new_r10*sj31);
IkReal x629=((1.0)*sj32);
IkReal x630=((1.0)*x624);
IkReal x631=((1.0)*x623);
IkReal x632=(sj31*x623);
evalcond[0]=(((sj32*x624))+new_r20);
evalcond[1]=((((-1.0)*x623*x629))+new_r21);
evalcond[2]=(((cj31*new_r01))+x627+((cj32*x623)));
evalcond[3]=((((-1.0)*new_r00*x626))+((cj31*new_r10))+(((-1.0)*x631)));
evalcond[4]=((((-1.0)*new_r01*x626))+((cj31*new_r11))+(((-1.0)*x630)));
evalcond[5]=(((sj31*x624))+new_r01+((x623*x625)));
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x630))+x628);
evalcond[7]=(x632+(((-1.0)*x625*x630))+new_r00);
evalcond[8]=((((-1.0)*cj31*x630))+new_r11+((cj32*x632)));
evalcond[9]=((((-1.0)*cj32*x624*x626))+(((-1.0)*cj31*x631))+new_r10);
evalcond[10]=(((new_r01*x625))+(((-1.0)*new_r21*x629))+x623+((cj32*x627)));
evalcond[11]=((((-1.0)*x630))+((new_r00*x625))+(((-1.0)*new_r20*x629))+((cj32*x628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j33array[1], cj33array[1], sj33array[1];
bool j33valid[1]={false};
_nj33 = 1;
CheckValue<IkReal> x633=IKPowWithIntegerCheck(IKsign(sj32),-1);
if(!x633.valid){
continue;
}
CheckValue<IkReal> x634 = IKatan2WithCheck(IkReal(new_r21),((-1.0)*new_r20),IKFAST_ATAN2_MAGTHRESH);
if(!x634.valid){
continue;
}
j33array[0]=((-1.5707963267949)+(((1.5707963267949)*(x633.value)))+(x634.value));
sj33array[0]=IKsin(j33array[0]);
cj33array[0]=IKcos(j33array[0]);
if( j33array[0] > IKPI )
{
    j33array[0]-=IK2PI;
}
else if( j33array[0] < -IKPI )
{    j33array[0]+=IK2PI;
}
j33valid[0] = true;
for(int ij33 = 0; ij33 < 1; ++ij33)
{
if( !j33valid[ij33] )
{
    continue;
}
_ij33[0] = ij33; _ij33[1] = -1;
for(int iij33 = ij33+1; iij33 < 1; ++iij33)
{
if( j33valid[iij33] && IKabs(cj33array[ij33]-cj33array[iij33]) < IKFAST_SOLUTION_THRESH && IKabs(sj33array[ij33]-sj33array[iij33]) < IKFAST_SOLUTION_THRESH )
{
    j33valid[iij33]=false; _ij33[1] = iij33; break; 
}
}
j33 = j33array[ij33]; cj33 = cj33array[ij33]; sj33 = sj33array[ij33];
{
IkReal evalcond[12];
IkReal x635=IKsin(j33);
IkReal x636=IKcos(j33);
IkReal x637=(cj31*cj32);
IkReal x638=((1.0)*sj31);
IkReal x639=(new_r11*sj31);
IkReal x640=(new_r10*sj31);
IkReal x641=((1.0)*sj32);
IkReal x642=((1.0)*x636);
IkReal x643=((1.0)*x635);
IkReal x644=(sj31*x635);
evalcond[0]=(((sj32*x636))+new_r20);
evalcond[1]=((((-1.0)*x635*x641))+new_r21);
evalcond[2]=(((cj31*new_r01))+x639+((cj32*x635)));
evalcond[3]=(((cj31*new_r10))+(((-1.0)*new_r00*x638))+(((-1.0)*x643)));
evalcond[4]=((((-1.0)*new_r01*x638))+((cj31*new_r11))+(((-1.0)*x642)));
evalcond[5]=(((x635*x637))+((sj31*x636))+new_r01);
evalcond[6]=(((cj31*new_r00))+(((-1.0)*cj32*x642))+x640);
evalcond[7]=(x644+(((-1.0)*x637*x642))+new_r00);
evalcond[8]=(((cj32*x644))+new_r11+(((-1.0)*cj31*x642)));
evalcond[9]=(new_r10+(((-1.0)*cj32*x636*x638))+(((-1.0)*cj31*x643)));
evalcond[10]=(((new_r01*x637))+(((-1.0)*new_r21*x641))+x635+((cj32*x639)));
evalcond[11]=(((cj32*x640))+((new_r00*x637))+(((-1.0)*x642))+(((-1.0)*new_r20*x641)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j27;
vinfos[0].indices[0] = _ij27[0];
vinfos[0].indices[1] = _ij27[1];
vinfos[0].maxsolutions = _nj27;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j28;
vinfos[1].indices[0] = _ij28[0];
vinfos[1].indices[1] = _ij28[1];
vinfos[1].maxsolutions = _nj28;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j29;
vinfos[2].indices[0] = _ij29[0];
vinfos[2].indices[1] = _ij29[1];
vinfos[2].maxsolutions = _nj29;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j30;
vinfos[3].indices[0] = _ij30[0];
vinfos[3].indices[1] = _ij30[1];
vinfos[3].maxsolutions = _nj30;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j31;
vinfos[4].indices[0] = _ij31[0];
vinfos[4].indices[1] = _ij31[1];
vinfos[4].maxsolutions = _nj31;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j32;
vinfos[5].indices[0] = _ij32[0];
vinfos[5].indices[1] = _ij32[1];
vinfos[5].maxsolutions = _nj32;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j33;
vinfos[6].indices[0] = _ij33[0];
vinfos[6].indices[1] = _ij33[1];
vinfos[6].maxsolutions = _nj33;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "f720334422c04aa0c3fc731126ce5f95"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000048"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif

#include "plugindefs.h" 
namespace IKFAST_NAMESPACE {
IkSolverBasePtr CreateIkSolver(EnvironmentBasePtr penv, std::istream& sinput, const std::vector<dReal>& vfreeinc) {
    boost::shared_ptr<ikfast::IkFastFunctions<IkReal> > ikfunctions(new ikfast::IkFastFunctions<IkReal>());
    ikfunctions->_ComputeIk = IKFAST_NAMESPACE::ComputeIk;
    ikfunctions->_ComputeFk = IKFAST_NAMESPACE::ComputeFk;
    ikfunctions->_GetNumFreeParameters = IKFAST_NAMESPACE::GetNumFreeParameters;
    ikfunctions->_GetFreeParameters = IKFAST_NAMESPACE::GetFreeParameters;
    ikfunctions->_GetNumJoints = IKFAST_NAMESPACE::GetNumJoints;
    ikfunctions->_GetIkRealSize = IKFAST_NAMESPACE::GetIkRealSize;
    ikfunctions->_GetIkFastVersion = IKFAST_NAMESPACE::GetIkFastVersion;
    ikfunctions->_GetIkType = IKFAST_NAMESPACE::GetIkType;
    ikfunctions->_GetKinematicsHash = IKFAST_NAMESPACE::GetKinematicsHash;
    return CreateIkFastSolver(penv,sinput,ikfunctions,vfreeinc);
}
} // end namespace
